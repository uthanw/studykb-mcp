# 2026年

# 数据结构考研复习指导

王道论坛 组编

電子工業出版社

Publishing House of Electronics Industry

北京·BEIJING

# 内容简介

本书是计算机专业硕士研究生入学考试“数据结构”课程的复习用书，内容包括绪论，线性表，栈、队列和数组，串，树与二叉树，图，查找，排序等。全书严格按照最新计算机考研大纲数据结构部分的要求，对大纲所涉及的知识点进行集中梳理，力求内容精练、重点突出、深入浅出。本书精选部分名校的历年考研真题，并给出详细的解题思路，力求实现讲练结合、灵活掌握、举一反三的效果。

本书既可作为考生参加计算机专业硕士研究生入学考试的复习用书，又可作为计算机专业学生学习“数据结构”课程的辅导用书。

未经许可，不得以任何方式复制或抄袭本书之部分或全部内容。

版权所有，侵权必究。

# 图书在版编目（CIP）数据

2026年数据结构考研复习指导/王道论坛组编

北京：电子工业出版社，2025.1.--ISBN978-7-121

-49364-5

I. TP311.12

中国国家版本馆CIP数据核字第2024UY5100号

责任编辑：谭海平

印刷：保定市中画美凯印刷有限公司

装 订：保定市中画美凯印刷有限公司

出版发行：电子工业出版社

北京市海淀区万寿路173信箱 邮编：100036

开 本：  $787\times 1092$  1/16 印张：25.75 字数：726.8千字

版 次：2025年1月第1版

印 次：2025年1月第1次印刷

定价：78.00元

凡所购买电子工业出版社图书有缺损问题，请向购买书店调换。若书店售缺，请与本社发行部联系，联系及邮购电话：（010）88254888，88258888。

质量投诉请发邮件至zlts@phei.com.cn，盗版侵权举报请发邮件至dbqq@phei.com.cn。

本书咨询联系方式：（010）88254552，tan02@phei.com.cn。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1385ab86b0b3b17e045845d2362a8fc528d3ece5c97ba1e73130aa982c03981a.jpg)


# B站搜索“王道计算机教育”

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cdf11eadec2bc7db5476ba25174b196c826b8c832d32a4961bb28566d68f7a73.jpg)



代表作


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5c29b8e48e4de48c2f11fedce072faca1ab522fb9d88db52a4c9e6a5d7fd9f3c.jpg)



王道计机考研作系统



NEW


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9826a19e606a90edf1fc852db3c69b7eca2357f2c041292c539cfe4a9945eb99.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/10063e30ae00c3d0bc51405dcae525e5fac44f881d4f3c632f2ce45bc7b10148.jpg)



王道计计算机考研计算机网络



NEW


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a0cc1c2599d78ec24a2b23abb130b43723edfc4da513f093d29595576a14bca2.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8384da41139e352051cf222318d7c178bb85039a62dce8f9ce6448d33ff197b6.jpg)



王道计算考研数据结构



NEW



一


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7c3d70791f04ba55bb3fb8015c110c21c301557c6bdda3cf6e1a451003ff2f3b.jpg)



29:01:33



预约



直增预约：26考研408如何做三轮规...


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/19b5a55a606d4cdb9f089381d69c8d2cfb9f0593c21c73a023a8ee2f67857f27.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d36010266459993f0a3722371a86b6a42ac35e893d9f6a75d3779fac24472dcc.jpg)



一



直播饮品：叠合给球球员带来哪些？


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/562e1444bdf218251e0b6f42a84552f4e13d540500d096ba2d353b5d8e1250db.jpg)


扫描二维码

兑换配套课件等资源

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/df896eba619f7d013e3a5d8ff9cb5ff6acda6bd3c989c0e0f9ab1de5f629eacd.jpg)


扫码关注

“王道在线”

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c52c9ccc8b5e12a853e86fd7409f9a17f696ab1449880fa4fa0a3368ab32c87b.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/399119943affa8c6e5332eebe8d37e5db20260119845bc2a7480226718d88ad6.jpg)


兑换中心

兑换码

邀请码

输入兑换码

例：H7xWBrYt

兑换记录>

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/16962689fe1f83b3ce43bb5fe8c0849293f88805f4125a37bf2f87cf609f9b4a.jpg)


进入公众号菜单

“兑换中心”

兑换遇到问题请加微信

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/82ca44febb640fbe461a596a760cd39d8d67fef15464272309e6032fab1e99fb.jpg)


盗版书无兑换码请勿购买配套视频不包含答疑服务

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/430521cea4c5040e9587896922a44eabed418c99ffdf073b5c93852de12a7d5d.jpg)


# 本书配套资源介绍

# 【关于配套视频的说明】

1.配套的考点精讲视频和习题讲解视频将持续更新和迭代。读者若有任何问题或建议，欢迎在评论区留言。王道会采纳有价值的留言，并及时优化视频。

2.兑换码仅用于兑换配套课件资源，视频均免费发布在B站。

3.兑换码贴于封面右下角，区分大小写，且无空格，兑换一次即失效。

4. 请支持正版，用户的支持也是王道持续做好课程和内容的动力。

# 前言

“王道考研系列”的定位是考试类辅导书。本书主要分为考点讲解部分和习题讲解部分，前者的篇幅约占  $35\%$  ，后者的篇幅约占  $65\%$  。考点讲解部分按照统考大纲梳理考点，主要参考了一些权威教材，如严蔚敏老师的《数据结构》、李春葆老师的《数据结构教程》等，并且融合了作者的总结与理解，在此对这些老师表示致敬和感谢！习题讲解部分主要精选自多所名校的自命题考研真题、教材配套习题册、同类辅导书，或者改编自统考真题。

由于篇幅限制，考点讲解部分较为精炼，对学科基础较为薄弱的读者来说，可能难以理解。为此，我们提供了配套的考点精讲视频和习题讲解视频。考点精讲视频有形象丰富的动画演示、由浅入深的考点分析，相信能打通读者复习过程中的“任督二脉”。往年有不少读者反馈视频和王道书不太匹配，这是因为王道书的出版时间远早于课程制作时间，而咸鱼老师录制课程时会参考众多的优秀教材（不限于王道书）；后面，我们将逐步解决这个问题。此外，之前的习题讲解视频主要由高分学长录制，质量参差不齐，今年将改由王道全职老师“全盘更新”，且只提供更新后的习题讲解视频，但更新速度可能赶不上读者的复习速度，还请谅解。

考点精讲视频和习题讲解视频免费发布在B站账号“王道计算机教育”上。

“王道考研系列”是计算机考研学子口碑相传的辅导书，自2011版首次推出以来，就始终占据同类书销量的榜首位置，这就是口碑的力量。有这么多学长的成功经验，相信读者只要合理地利用本套书，并采用科学的复习方法，就一定能收获属于自己的那份回报。

针对考研学子的需求，我们还开发了除本书配套视频外的一系列计算机考研课程，包括C语言督学课、408基础课、408暑期强化课、408冲刺串讲课、机试课、复习规划、伴学督学、一对一指导、全程实时答疑和择校服务等。王道的课程同样是市面上领先的计算机考研课程，对学科基础较为薄弱的读者来说，相信这些课程和服务定能助你一臂之力。

“不包就业、不包推荐，培养有态度的码农。”王道训练营是王道团队打造的线下魔鬼式编程训练营。打下编程功底、增强项目经验，彻底转行入行，不再迷茫，期待有梦想的你！

参与本书编写的人员主要有赵霖、罗乐、徐秀瑛、赵淑芬、赵淑芳、罗庆学、赵晓宇、喻云珍、余勇、刘政学等。予人玫瑰，手有余香，王道论坛伴你一路同行！

对本书的任何建议，或发现有错误，欢迎扫码与我们联系，以便及时优化或纠错。

# 致读者

——关于王道单科辅导书使用方法的道友建议

我是“二战考生”，2012年第一次考研成绩为333分（专业代码408，成绩为81分），痛定思痛后决心再战。潜心复习了半年后终于以392分（专业代码408，成绩为124分）考入上海交通大学计算机科技与技术专业，这半年里我的专业课成绩提高了43分，成了提分主力。从未达到录取线到考出比较满意的成绩，从蒙头乱撞到有了自己明确的复习思路，我想这也是风华哥从诸多高分选手中选择我给大家介绍经验的一个原因吧。

整个专业课的复习是围绕王道辅导书展开的，从一遍、两遍、三遍看单科辅导书的积累提升，到做8套模拟题时的强化巩固，再到看思路分析时的醍醐灌顶。王道辅导书能两次押中算法原题固然有运气成分，但这也从侧面说明编者的编写思路和选题方向与真题很接近。

下面说一说我的具体复习过程。

每天划给专业课的时间是  $3\sim 4$  小时。第一遍仔细看课本，看完一章做一章单科辅导书上的习题（红笔标注错题)，这一遍共持续2个月。第二遍主攻单科辅导书（红笔标注重难点)，辅看课本。第二遍看单科辅导书和课本的速度快了很多，但感觉收获更多，常有温故知新的感觉，理解更深刻。（风华注：建议这里再速看第三遍，特别针对错题和重难点。模拟题做完后再跳看第四遍。）

以上是打基础阶段，注意：我仔细精读了两遍单科辅导书和课本，以便尽量弄懂每个知识点和习题。大概11月上旬开始做模拟题和思路分析，其间遇到不熟悉的地方不断回头查阅单科辅导书和课本。8套模拟题的考点覆盖得很全面，所以大家做题时如果忘记了某个知识点，千万不要慌张，赶紧回去看这个知识点，最后的模拟就是查漏补缺。模拟题一定要严格按考试时间（3小时）去做，注意应试技巧，做完试题后再回头研究错题。算法题的最优解法不太好想，如果实在没思路，建议直接“暴力”解决，结果正确也能有10分，总比苦拼出15分来而将后面比较好拿分的题耽误了好（这是我第一次考研的切身教训）。最后剩了几天看标注的错题，第三遍跳看单科辅导书，考前一夜浏览完网络，踏实地睡着了……

考完专业课，走出考场终于长舒一口气，考试情况也心中有数。回想这半年的复习，耐住了寂寞和诱惑，雨雪风霜从未间断地跑去自习，考研这人生一站终归没有辜负我的良苦用心。佛教徒说世间万物生来平等，都要落入春华秋实的代谢中去；辩证唯物主义认为事物作为过程存在，凡是存在的终归要结束。你不去为活得多姿多彩而拼搏，真到了和青春说再见时，你是否会可惜虚度了青春？风华哥说过，我们都是有梦想的青年，我们正在逆袭，你呢？

感谢风华哥的信任，给我这个机会为大家分享专业课复习经验，作为一个铁杆道友在王道受益匪浅，也借此机会回报王道论坛。祝大家金榜题名！

# 王道训练营

王道是道友们考研路上值得信赖的好伙伴，十多年来陪伴了数百万计算机考研人，不离不弃。王道尊重的不是考研这个行当，而是考研学生的精神和梦想。考研可能是同学们实现梦想的起点，但专业功底和学习能力更是受用终生的资本，它决定了未来在技术道路上能走多远。从考研图书，到辅导课程，再到编程培训，王道只专注于计算机考研及编程领域。

计算机专业是一个靠实力吃饭的专业。王道团队中很多人的经历或许和现在的你们相似，也经历过本科时的迷茫，无非是自知能力太弱，以致底气不足。学历只是敲门砖，同样是名校硕士，有人如鱼得水，最终成为“Offer帝”，有人却始终难入“编程与算法之门”，再次体会迷茫的痛苦。我们坚信一个写不出合格代码的计算机专业学生，即便考上了研究生，也只是给未来的失业判了个“缓期执行”。我们也希望所做的事情能帮助同学们少走弯路。

考研结束后的日子，或许是一段难得的提升编程能力的连续时光，趁着还有时间，应该去弥补本科期间应掌握的能力，缩小与“科班大佬们”的差距。

把参加王道训练营视为一次对自己的投资，投资自身和未来才是最好的投资。

# 王道训练营简介

# 1. 面向就业

希望转行就业，但编程能力偏弱的学生。

考研并不是人生的唯一出路，努力拼搏奋斗的经历总是难忘的，但不论结果如何，都不应有太大的遗憾。不少考研路上的“失败者”在王道都到达了自己在技术发展上的新里程碑，我们相信一个肯持续努力、积极上进的学生一定会找到自己正确的人生方向。

再不抓住当下，未来或将持续迷茫，逝去了的青春不复返。在充分竞争的技术领域，当前的能力决定了你能找一份怎样的工作，踏实的态度和学习的能力决定了你未来能走多远。

王道训练营致力于给有梦想、肯拼搏、敢奋斗的道友提供最好的平台！

# 2. 面向硕士

希望提升能力，刚考上计算机相关专业的准硕士。

考研逐年火爆，能考上名校确实是重要的转折，但硕士文凭早已不再稀缺。考研高分并不等于高薪Offer，学历也不能保证你拿到好Offer，名校的光环能让你获得更多面试机会，但真正要拿到好Offer，比拼的是实力。同为名校硕士，Offer的成色可能千差万别，有人轻松拿到腾讯、阿里、字节、百度等优秀公司的Offer，有人面试却屡屡碰壁，最后只能“将就”签约。

人生中关键性的转折点不多，但往往能对自己的未来产生深远的影响，甚至决定了你未来的走向，高考、选专业、考研、找工作都是如此，把握住关键转折点需要眼光和努力。

# 3. 报名要求

- 具有本科学历，愿意通过奋斗去把握自己的人生，愿意重回高三冲刺式的学习状态。

- 完成开课前的作业，用作业考察态度，合格者才能获得最终的参加资格，宁缺毋滥！对于意志不够坚定的同学而言，这些作业也算是设置的一道门槛，决定了是否有参加的资格。

作业完成情况是最重要的考核标准，我们不会歧视跨度大的同学，坚定转行的同学往往会更努力。专业跨度大、学校弱这些是无法改变的标签，唯一可以改变的就是通过持续努力来提升自身的技能，而通过高强度的短期训练是完全有可能逆袭的，太多的往期学员已有过证明。

# 4. 学习成效

迅速提升编程能力，结合项目实战，逐步打下坚实的编程基础，培养积极、主动的学习能力。以动手编程为驱动的教学模式，弥补你在编程、思维上的不足，也为未来的深入学习提供方向指导，让你掌握学习编程的方法，引导你进入“编程与算法之门”。

道友们在训练营里从“菜鸟”逐步成长，训练营中不少往期准硕士学员后来陆续拿到了阿里、腾讯、字节、百度、美团、小米等一线互联网大厂的Offer。这就是竞争力！

# 王道训练营优势

这里都是道友，他们信任王道，乐于分享与交流，氛围好而纯粹。

一起经历过考研训练的生活、学习，大家很快会成为互帮互助的好战友，相互学习、共同进步，在转行的道路上，这就是最好的圈子。正如某期学员所言：“来了你就发现，这里无关程序员以外的任何东西，这是一个过程，一个对自己认真、对自己负责的过程。”

考研绝非人生的唯一出路，给自己换一条路走，去职场上好好发展或许会更好。即便考上研究生也不意味着高枕无忧，人生的道路还很漫长。

王道团队成员皆具有扎实的编程功底，他们用自己的技术和态度去影响训练营的学员，尽可能指导学员走上正确的发展道路是对道友信任的回报，也是一种责任！

王道训练营是一个平台，网罗王道论坛上有梦想、有态度的青年，并为他们的梦想提供土壤和圈子。王道始终相信“物竞天择，适者生存”，这里的生存不是指简简单单地活着，而是指活得有价值、活得有态度！

# 王道训练营课程

王道训练营开设4种班型：

- Linux C 和  $\mathrm{C} + +$  短期班（ $40\sim 45$  天，初试后开课，复试冲刺）

- Java EE 方向（4 个月，武汉校区）

- Linux C/C++方向（4个月，武汉校区）

- Python大数据方向（3个半月，直播授课或深圳校区）

短期班的作用是在初试后及春节期间，快速提升学员的编程水平和项目经验，给复试、面试加分。其他3种班型既面向有就业需求的学员，又适合想提升能力或打算继续考研的学员。

要想了解王道训练营，可以关注王道论坛“王道训练营”版面，或者扫码加老师微信。

# 目录

# 第1章 绪论

# 1.1 数据结构的基本概念 1

1.1.1 基本概念和术语

1.1.2 数据结构三要素 2

1.1.3 本节试题精选

1.1.4 答案与解析 4

# 1.2 算法和算法评价 4

1.2.1 算法的基本概念 4

1.2.2 算法效率的度量 5

1.2.3 本节试题精选

1.2.4 答案与解析 8

# 归纳总结 11

# 思维拓展 11

# 第2章 线性表 12

# 2.1 线性表的定义和基本操作 12

2.1.1 线性表的定义 12

2.1.2 线性表的基本操作 13

2.1.3 本节试题精选 13

2.1.4 答案与解析 14

# 2.2 线性表的顺序表示 14

2.2.1 顺序表的定义· 14

2.2.2 顺序表上基本操作的实现 ..... 15

2.2.3 本节试题精选 17

2.2.4 答案与解析 20

# 2.3 线性表的链式表示 29

2.3.1 单链表的定义 29

2.3.2 单链表上基本操作的实现 30

2.3.3 双链表 35

2.3.4 循环链表 36

2.3.5 静态链表 37

2.3.6 顺序表和链表的比较 37

2.3.7 本节试题精选 38

2.3.8 答案与解析 44

# 归纳总结 61

# 思维拓展 61

# 第3章栈、队列和数组 62

# 3.1 栈 62

# 3.1.1 栈的基本概念 62

3.1.2 栈的顺序存储结构 63

3.1.3 栈的链式存储结构 65

3.1.4 本节试题精选 66

3.1.5 答案与解析 69

# 3.2 队列 75

3.2.1 队列的基本概念 75

3.2.2 队列的顺序存储结构 76

3.2.3 队列的链式存储结构 78

3.2.4 双端队列 80

3.2.5 本节试题精选 81

3.2.6 答案与解析 84

# 3.3 栈和队列的应用 89

3.3.1 栈在括号匹配中的应用 89

3.3.2 栈在表达式求值中的应用 90

3.3.3 栈在递归中的应用 92

3.3.4 队列在层次遍历中的应用 93

3.3.5 队列在计算机系统中的应用 94

3.3.6 本节试题精选 94

3.3.7 答案与解析 96

# 3.4 数组和特殊矩阵 100

3.4.1 数组的定义 100

3.4.2 数组的存储结构 100

3.4.3 特殊矩阵的压缩存储 101

3.4.4 稀疏矩阵 104

3.4.5 本节试题精选 104

3.4.6 答案与解析 106

# 归纳总结 108

# 思维拓展 108

# 第4章 串

# *4.1 串的定义和实现 ………………………………………… 109

4.1.1 串的定义 … 109

4.1.2 串的基本操作 … 110

4.1.3 串的存储结构 ..... 110

# 4.2 串的模式匹配 … 111

4.2.1 简单的模式匹配算法 111

4.2.2 串的模式匹配算法——KMP算法 … 112

4.2.3 KMP算法的进一步优化 117

4.2.4 本节试题精选 118

4.2.5 答案与解析 119

# 归纳总结 123

# 思维拓展 123

# 第5章 树与二叉树 124

# 5.1 树的基本概念 124

5.1.1 树的定义 124

5.1.2 基本术语 125

5.1.3 树的性质 126

5.1.4 本节试题精选 126

5.1.5 答案与解析 127

# 5.2 二叉树的概念 130

5.2.1 二叉树的定义及其主要特性 … 130

5.2.2 二叉树的存储结构 ..... 132

5.2.3 本节试题精选 133

5.2.4 答案与解析 136

# 5.3 二叉树的遍历和线索二叉树 … 140

5.3.1 二叉树的遍历 … 140

5.3.2 线索二叉树 145

5.3.3 本节试题精选 148

5.3.4 答案与解析 154

# 5.4 树、森林 171

5.4.1 树的存储结构 171

5.4.2 树、森林与二叉树的转换 172

5.4.3 树和森林的遍历 174

5.4.4 本节试题精选 175

5.4.5 答案与解析 177

# 5.5 树与二叉树的应用 183

5.5.1 哈夫曼树和哈夫曼编码 ..... 183

5.5.2 并查集 186

5.5.3 本节试题精选 188

5.5.4 答案与解析 190

# 归纳总结 196

# 思维拓展 196

# 第6章 图 198

# 6.1 图的基本概念 198

6.1.1 图的定义 198

6.1.2 本节试题精选 201

6.1.3 答案与解析 203

# 6.2 图的存储及基本操作 206

6.2.1 邻接矩阵法 ..... 206

6.2.2 邻接表法 207

6.2.3 十字链表 209

6.2.4 邻接多重表 209

6.2.5 图的基本操作 210

6.2.6 本节试题精选 211

6.2.7 答案与解析 214

# 6.3 图的遍历 219

6.3.1 广度优先搜索 ..... 219

6.3.2 深度优先搜索 222

6.3.3 图的遍历与图的连通性 223

6.3.4 本节试题精选 223

6.3.5 答案与解析 226

6.4 图的应用 231

6.4.1 最小生成树 231

6.4.2 最短路径 234

6.4.3 有向无环图描述表达式 ..... 237

6.4.4 拓扑排序 238

6.4.5 关键路径 240

6.4.6 本节试题精选 242

6.4.7 答案与解析 252

归纳总结 267

思维拓展 268

# 第7章 查找 269

7.1 查找的基本概念 269

7.2 顺序查找和折半查找 ..... 270

7.2.1 顺序查找 270

7.2.2 折半查找 272

7.2.3 分块查找 273

7.2.4 本节试题精选 274

7.2.5 答案与解析 277

7.3 树形查找 283

7.3.1 二叉排序树（BST） 283

7.3.2 平衡二叉树 287

7.3.3 红黑树 291

7.3.4 本节试题精选 ..... 296

7.3.5 答案与解析 300

7.4 B树和B+树 310

7.4.1 B树及其基本操作 311

7.4.2 B+树的基本概念 314

7.4.3 本节试题精选 315

7.4.4 答案与解析 317

7.5散列（Hash）表 323

7.5.1 散列表的基本概念 323

7.5.2 散列函数的构造方法 324

7.5.3 处理冲突的方法 324

7.5.4 散列查找及性能分析的应用 326

7.5.5 本节试题精选 327

7.5.6 答案与解析 330

归纳总结 336

思维拓展 336

# 第8章 排序 337

8.1 排序的基本概念 338

8.1.1 排序的定义 338

8.1.2 本节试题精选 338

8.1.3 答案与解析 339

8.2 插入排序 339

8.2.1 直接插入排序 339

8.2.2 折半插入排序 340

8.2.3 希尔排序 341

8.2.4 本节试题精选 342

8.2.5 答案与解析 344

8.3 交换排序 346

8.3.1 冒泡排序 347

8.3.2 快速排序 348

8.3.3 本节试题精选 350

8.3.4 答案与解析 353

8.4 选择排序 357

8.4.1 简单选择排序 358

8.4.2 堆排序 358

8.4.3 本节试题精选 361

8.4.4 答案与解析 364

8.5 归并排序、基数排序和计数排序 370

8.5.1 归并排序 370

8.5.2 基数排序 371

*8.5.3 计数排序 373

8.5.4 本节试题精选 375

8.5.5 答案与解析 377

8.6 各种内部排序算法的比较及应用 380

8.6.1 内部排序算法的比较 380

8.6.2 内部排序算法的应用 381

8.6.3 本节试题精选 382

8.6.4 答案与解析 384

8.7 外部排序 387

8.7.1 外部排序的基本概念 387

8.7.2 外部排序的方法 387

8.7.3 多路平衡归并与败者树 388

8.7.4 置换-选择排序（生成初始归并段） 389

8.7.5 最佳归并树 390

8.7.6 本节试题精选 392

8.7.7 答案与解析 394

归纳总结 398

思维拓展 399

参考文献 400

# 绪论

# 【考纲内容】

（一）数据结构的基本概念

（二）算法的基本概念

算法的时间复杂度和空间复杂度

# 【知识框架】


扫一扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f323360d65538b8ccf4a1e0af23f85e4068890fcb9f021175f2cca57032de984.jpg)



视频讲解


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/49b452d442e56020cea17c66971a862c69a02c9cc21a69229a3223c0dc3af338.jpg)


# 【复习提示】

本章内容是数据结构概述，并不在考研大纲中。读者可通过对本章的学习，初步了解数据结构的基本内容和基本方法。分析算法的时间复杂度和空间复杂度是本章重点，需要熟练掌握，算法设计题通常都会要求分析时间复杂度、空间复杂度，同时会出现考查时间复杂度的选择题。

# 1.1 数据结构的基本概念

# 1.1.1 基本概念和术语

# 1. 数据

数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。

# 2. 数据元素

数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

# 3. 数据对象

数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合  $N = \{0, \pm 1, \pm 2, \dots\}$ 。

# 4. 数据类型

数据类型是一个值的集合和定义在此集合上的一组操作的总称。

1）原子类型。其值不可再分的数据类型。

2）结构类型。其值可以再分解为若干成分（分量）的数据类型。

3）抽象数据类型（ADT）。一个数学模型及定义在该数学模型上的一组操作。它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。

# 5. 数据结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。

数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构<sup>①</sup>。

# 1.1.2 数据结构三要素

# 1. 数据的逻辑结构

逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如图1.1所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ac69059725cb4fce2dd93fde14395a82e0cc83da2c702e720d6a98c6119e834d.jpg)



图1.1 数据的逻辑结构分类


1）集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系，如图1.2(a)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d40debcf2a865ce5cabc463a3d56ff655a81f72c5c758cedbe7fed470fd638b8.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9c29b267328370e0a5b9bcf8e5b64610d103b06c7efda45129999798e80bf987.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bc1f46a1c274cd70bad250f4d1eea070cad22e2f32162ab4edba1493bd7b979b.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/99766a16ea92f2973d83614ced4782f63dd064392ae6b97731f605e544750949.jpg)



图1.2 四类基本结构关系示例图


2）线性结构。结构中的数据元素之间只存在一对一的关系，如图1.2(b)所示。

3）树形结构。结构中的数据元素之间存在一对多的关系，如图1.2(c)所示。

4）图状结构或网状结构。结构中的数据元素之间存在多对多的关系，如图1.2(d)所示。

# 2. 数据的存储结构

存储结构是指数据结构在计算机中的表示（也称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。

1）顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。

2）链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。

3）索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。

4）散列存储。根据元素的关键字直接计算出该元素的存储地址，也称哈希（Hash）存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

# 3. 数据的运算

施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。

# 1.1.3 本节试题精选

# 一、单项选择题

01. 可以用（）定义一个完整的数据结构。

A. 数据元素

B. 数据对象

C. 数据关系

D. 抽象数据类型

02. 下列四种数据结构中，（）是非线性数据结构。

A. 树

B. 字符串

C. 队列

D. 栈

03. 下列选项中，属于逻辑结构的是（）。

A. 顺序表

B. 哈希表

C. 有序表

D. 单链表

04. 下列关于数据结构的说法中，正确的是（）。

A. 数据的逻辑结构独立于其存储结构

B. 数据的存储结构独立于其逻辑结构

C. 数据的逻辑结构唯一决定其存储结构

D. 数据结构仅由其逻辑结构和存储结构决定

05. 在存储数据时，通常不仅要存储各数据元素的值，而且要存储（）。

A. 数据的操作方法

B. 数据元素的类型

C. 数据元素之间的关系

D. 数据的存取方法

# 二、综合应用题

01. 对于两种不同的数据结构，逻辑结构或物理结构一定不相同吗？

02. 试举一例，说明对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同。

# 1.1.4 答案与解析

# 一、单项选择题

# 01. D

抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用（数据对象、数据关系、基本操作集）这样的三元组来表示，从而构成一个完整的数据结构定义。

# 02. A

树和图是典型的非线性数据结构，其他选项都属于线性数据结构。

# 03. C

顺序表、哈希表和单链表是三种不同的数据结构，既描述逻辑结构，又描述存储结构和数据运算。而有序表是指关键字有序的线性表，仅描述元素之间的逻辑关系，它既可以链式存储，又可以顺序存储，所以属于逻辑结构。

# 04. A

数据的逻辑结构是从面向实际问题的角度出发的，只采用抽象表达方式，独立于存储结构，数据的存储方式有多种不同的选择；而数据的存储结构是逻辑结构在计算机上的映射，它不能独立于逻辑结构而存在。数据结构包括三个要素，缺一不可。

# 05. C

在存储数据时，不仅要存储数据元素的值，而且要存储数据元素之间的关系。

# 二、综合应用题

# 01.【解答】

应该注意到，数据的运算也是数据结构的一个重要方面。

对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同。比如二叉树和二叉排序树，二叉排序树可以采用二叉树的逻辑表示和存储方式，前者通常用于表示层次关系，而后者通常用于排序和查找。虽然它们的运算都有建立树、插入结点、删除结点和查找结点等功能，但对于二叉树和二叉排序树，这些运算的定义是不同的，以查找结点为例，二叉树的平均时间复杂度为  $O(n)$ ，而二叉排序树的平均时间复杂度为  $O(\log_2n)$ 。

# 02.【解答】

线性表既可以用顺序存储方式实现，又可以用链式存储方式实现。在顺序存储方式下，在线性表中插入和删除元素，平均要移动近一半的元素，时间复杂度为  $O(n)$  ；而在链式存储方式下，插入和删除的时间复杂度都是  $O(1)$  。

# 1.2 算法和算法评价

# 1.2.1 算法的基本概念

算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列五个重要特性：

1）有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。

2）确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3）可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。

4）输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。

5）输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

通常，设计一个“好”的算法应考虑达到以下目标：

1）正确性。算法应能够正确地解决求解问题。

2）可读性。算法应具有良好的可读性，以帮助人们理解。

3）健壮性。算法能对输入的非法数据做出反应或处理，而不会产生莫名其妙的输出。

4）高效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。

# 1.2.2 算法效率的度量

命题追踪 （算法题）分析时空复杂度（2010—2013、2015、2016、2018—2021）

算法效率的度量是通过时间复杂度和空间复杂度来描述的。

# 1. 时间复杂度

命题追踪 分析算法的时间复杂度（2011—2014、2017、2019、2022）

一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为  $T(n)$ ，它是该算法问题规模  $n$  的函数，时间复杂度主要分析  $T(n)$  的数量级。算法中基本运算（最深层循环中的语句）的频度与  $T(n)$  同数量级，因此通常将算法中基本运算的执行次数的数量级作为该算法的时间复杂度<sup>①</sup>。于是，算法的时间复杂度记为

$$
T (n) = O (f (n))
$$

式中，  $O$  的含义是  $T(n)$  的数量级，其严格的数学定义是：若  $T(n)$  和  $f(n)$  是定义在正整数集合上的两个函数，则存在正常数  $C$  和  $n_0$  ，使得当  $n\geq n_0$  时，都满足  $0\leqslant T(n)\leqslant Cf(n)$

算法的时间复杂度不仅依赖于问题的规模  $n$ ，也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组 A[0...n-1] 中，查找给定值  $k$  的算法大致如下：

```txt
(1)  $i = n - 1$    
(2)while  $(\mathrm{i} > = 0\& \& (\mathrm{A}[i]! = k))$    
(3） i--;  
(4)return i;
```

该算法中语句3（基本运算）的频度不仅与问题规模  $n$  有关，而且与下列因素有关：

① 若A中没有与k相等的元素，则语句3的频度  $f(n) = n$ 。

② 若A的最后一个元素等于k，则语句3的频度  $f(n)$  是常数0。

最坏时间复杂度是指在最坏情况下，算法的时间复杂度。

平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。

最好时间复杂度是指在最好情况下，算法的时间复杂度。

一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。

在分析一个程序的时间复杂性时，有以下两条规则：

1）加法规则：  $T(n) = T_{1}(n) + T_{2}(n) = O(f(n)) + O(g(n)) = O(\max (f(n),g(n)))$

2）乘法规则：  $T(n) = T_{1}(n)\times T_{2}(n) = O(f(n))\times O(g(n)) = O(f(n)\times g(n))$

例如，设  $\mathsf{a}\{\} ,\mathsf{b}\{\} ,\mathsf{c}\{\}$  三个语句块的时间复杂度分别为  $O(1),O(n),O(n^{2})$  ，则

```txt
① a{ b{} c{} } //时间复杂度为  $O(n^{2})$  ，满足加法规则
```

$②$  a{ b{} c{} 1 //时间复杂度为  $O(n^{3})$  ，满足乘法规则

常见的渐近时间复杂度为

$$
O (1) <   O (\log_ {2} n) <   O (n) <   O (n \log_ {2} n) <   O (n ^ {2}) <   O (n ^ {3}) <   O (2 ^ {n}) <   O (n!) <   O (n ^ {n})
$$

# 2. 空间复杂度

算法的空间复杂度  $S(n)$  定义为该算法所需的存储空间，它是问题规模  $n$  的函数，记为

$$
S (n) = O (g (n))
$$

一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。例如，若算法中新建了几个与输入数据规模  $n$  相同的辅助数组，则空间复杂度为  $O(n)$ 。

算法原地工作是指算法所需的辅助空间为常量，即  $O(1)$ 。

# 1.2.3 本节试题精选

# 一、单项选择题

01. 一个算法应该具有（）等重要特性。

A. 可维护性、可读性和可行性

B. 可行性、确定性和有穷性

C. 确定性、有穷性和可靠性

D. 可读性、正确性和可行性

02. 下列关于算法的说法中，正确的是（）。

A. 算法的时间效率取决于算法执行所花的CPU时间

B. 在算法设计中不允许用牺牲空间效率的方式来换取好的时间效率

C. 算法必须具备有穷性、确定性等五个特性

D. 通常用时间效率和空间效率来衡量算法的优劣

03. 某算法的时间复杂度为  $O(n^{2})$  ，则表示该算法的（）。

A. 问题规模是  $n^{2}$

B. 执行时间等于  $n^{2}$

C. 执行时间与  $n^{2}$  成正比

D. 问题规模与  $n^{2}$  成正比

04. 若某算法的空间复杂度为  $O(1)$ ，则表示该算法（）。

A. 不需要任何辅助空间

B. 所需辅助空间大小与问题规模  $n$  无关

C. 不需要任何空间

D. 所需空间大小与问题规模  $n$  无关

05. 下列关于时间复杂度的函数中，时间复杂度最小的是（）。

A.  $T_{1}(n) = n\log_{2}n + 5000n$

B.  $T_{2}(n) = n^{2} - 8000n$

C.  $T_{3}(n) = n \log_{2} n - 6000 n$

D.  $T_{4}(n) = 20000 \log_{2} n$

06. 下列算法的时间复杂度为（）。

```txt
void fun(int n){ int  $\mathrm{i} = 1$  while(i<=n) i=i\*2;
```

A.  $O(n)$

B.  $O(n^{2})$

C.  $O(n \log_2 n)$

D.  $O\left(\log_2 n\right)$

07. 下列算法的时间复杂度为（）。

```txt
void fun(int n){
```

```txt
int  $\mathrm{i} = 0$  while  $(\mathrm{i}^{\star}\mathrm{i}^{\star}\mathrm{i} <   = \mathrm{n})$  i++;
```

A.  $O(n)$

B.  $O\left(n \log_2 n\right)$

C.  $O\left(\sqrt[3]{n}\right)$

D.  $O\left(\sqrt{n}\right)$

08. 某个程序段如下：

```txt
for  $(i = n - 1; i > 1; i - - )$  for  $(j = 1; j < i; j++)$  if  $(A[j] > A[j + 1])$  A[j]与A[j+1]对换；
```

其中  $n$  为正整数，则最后一行语句的频度在最坏情况下是（）。

A.  $O(n)$

B.  $O\left(n \log_2 n\right)$

C.  $O\left(n^{3}\right)$

D.  $O(n^{2})$

09. 下列程序段的时间复杂度为（）。

```awk
if  $(n >= 0)$  {for(int  $i = 0;i <   n;i + + )$  for(int  $j = 0;j <   n;j + + )$  printf("输入数据大于或等于零\n")}else{for(int  $j = 0;j <   n;j + + )$  printf("输入数据小于零\n")}
```

A.  $O(n^{2})$

B.  $O(n)$

C.  $O(1)$

D.  $O\left(n \log_{2} n\right)$

10. 下列算法中加下画线的语句的执行次数为（）。

```txt
int  $m = 0,i,j$    
for  $(\mathrm{i} = 1;\mathrm{i} <   = \mathrm{n};\mathrm{i} + + )$  for  $(j = 1;j <   = 2^{*}i;j + + )$  m++;
```

A.  $n(n + 1)$

B.  $n$

C.  $n + 1$

D.  $n^{2}$

11. 下列函数代码的时间复杂度是（）。

```c
int Func(int n){ if  $(\mathrm{n} = = 1)$  return 1; else return  $2^{*}\mathrm{Func}(\mathrm{n} / 2) + \mathrm{n};$
```

A.  $O(n)$

B.  $O\left(n \log_2 n\right)$

C.  $O\left(\log_2 n\right)$

D.  $O(n^{2})$

12.【2011统考真题】设  $n$  是描述问题规模的非负整数，下列程序段的时间复杂度是（）。

```latex
$\mathrm{x} = 2$    
while  $(x <   n / 2)$ $x = 2^{*}x$
```

A.  $O\left(\log_2 n\right)$

B.  $O(n)$

C.  $O(n \log_2 n)$

D.  $O(n^{2})$

13.【2012统考真题】求整数  $n$  （  $n\geq 0$  ）的阶乘的算法如下，其时间复杂度是（）。

```c
int fact(int n){ if  $(n <   = 1)$  return 1; return  $\mathfrak{n}^{\star}$  fact(n-1);
```

A.  $O\left(\log_2 n\right)$

B.  $O(n)$

C.  $O\left(n \log_2 n\right)$

D.  $O(n^{2})$

14.【2014统考真题】下列程序段的时间复杂度是（）。

```javascript
count=0;  
for  $(k = 1;k <   = n;k^{*} = 2)$  for  $(j = 1;j <   = n;j + + )$
```

count++;

A.  $O(\log_2 n)$

B.  $O(n)$

C.  $O(n \log_2 n)$

D.  $O(n^{2})$

15.【2017统考真题】下列函数的时间复杂度是（）。

```c
int func(int n){ int  $\mathrm{i} = 0$  ，sum  $= 0$  while（sum<n）sum  $+ = + + i$  returni;   
1
```

A.  $O(\log_2 n)$

B.  $O\left(n^{1 / 2}\right)$

C.  $O(n)$

D.  $O\left(n \log_{2} n\right)$

16.【2019统考真题】设  $n$  是描述问题规模的非负整数，下列程序段的时间复杂度是（）。

```txt
$\mathrm{x = 0}$    
while  $(n > = (x + 1)^{\star}(x + 1))$ $x = x + 1$
```

A.  $O(\log_2 n)$

B.  $O\left(n^{1 / 2}\right)$

C.  $O(n)$

D.  $O(n^{2})$

17.【2022统考真题】下列程序段的时间复杂度是（）。

```txt
int sum=0;  
for(int i=1;i<n;i\*=2)  
    for(int j=0;j<i;j++)  
        sum++;
```

A.  $O(\log_2 n)$

B.  $O(n)$

C.  $O(n \log_2 n)$

D.  $O(n^{2})$

# 二、综合应用题

01. 分析下列各程序段，求出算法的时间复杂度。

```txt
$①$ $\mathrm{i} = 1;\mathrm{k} = 0;$  while  $(\mathrm{i} <   \mathrm{n} - 1)$  {  $\mathrm{k} = \mathrm{k} + 10^{\star}\mathrm{i};$  i++; }
```

```latex
$②$ $\mathrm{y = 0}$  while  $(\mathrm{(y + 1)}^{\star}(\mathrm{y + 1}) <   = \mathrm{n})$ $\mathrm{y = y + 1}$
```

```javascript
③ for  $(i = 0; i < n; i++)$  for  $(j = 0; j < m; j++)$  a[i][j] = 0;
```

# 1.2.4 答案与解析

# 一、单项选择题

01. B

一个算法应具有五个重要特性：有穷性、确定性、可行性、输入和输出。选项A、C和D中提到的特性（如可维护性、可读性、可靠性、正确性等）是很重要的，但它们并不是算法定义的重要特性，更多的是关于软件开发中的附加要求。

02. C

算法的时间效率是指算法的时间复杂度，即执行算法所需的计算工作量，选项A错误。算法设计会综合考虑时间效率和空间效率两个方面，若某些应用场景对时间效率要求很高，而对空间效率要求不高，则可用牺牲空间效率的方式来换取好的时间效率，选项B错误。评价一个算法的“优劣”不仅要考虑算法的时空效率，还要从正确性、可读性、健壮性等方面来综合评价。

03.C

时间复杂度为  $O(n^{2})$  ，说明算法的时间复杂度  $T(n)$  满足  $T(n)\leqslant cn^2$  （其中  $c$  为比例常数），即

$T(n) = O(n^{2})$  ，时间复杂度  $T(n)$  是问题规模  $n$  的函数，其问题规模仍然是  $n$  而不是  $n^2$  。

# 04. B

算法的空间复杂度为  $O(1)$ ，表示执行该算法所需的辅助空间大小相比输入数据的规模来说是一个常量，而不表示该算法执行时不需要任何空间或辅助空间。

# 05. D

A 的最高阶是  $n\log_2n$ ，时间复杂度是  $O(n\log_2n)$  。B 的最高阶是  $n^2$ ，时间复杂度是  $O(n^{2})$  。C 的最高阶是  $n\log_2n$ ，时间复杂度是  $O(n\log_2n)$  。D 的最高阶是  $\log_2n$ ，时间复杂度是  $O(\log_2n)$  。

# 06. D

找出基本运算  $\mathrm{i} = \mathrm{i}^{\star}2$  ，设执行次数为  $t$  ，  $2^{t}\leqslant n$  ，即  $t\leqslant \log_2n$  ，故时间复杂度  $T(n) = O(\log_2n)$

更直观的方法：计算基本运算  $\mathrm{i} = \mathrm{i} \star 2$  的执行次数（每执行一次  $\mathrm{i}$  乘以 2），其中判断条件可理解为  $2^{t} = n$ ，即  $t = \log_2 n$ ，则  $T(n) = O(\log_2 n)$ 。

# 07. C

基本运算为  $\mathrm{i}++$ ，设执行次数为  $t$ ，有  $t \times t \times t \leqslant n$ ，即  $t^3 \leqslant n$  。因此有  $t \leqslant \sqrt[3]{n}$ ，则  $T(n) = O(\sqrt[3]{n})$ 。

# 08. D

这是冒泡排序的算法代码，考查最坏情况下的元素交换次数（若觉得理解起来有困难，则可在学完第8章后再回顾）。当所有相邻元素都为逆序时，则最后一行的语句每次都会执行。此时，

$$
T (n) = \sum_ {i = 2} ^ {n - 1} \sum_ {j = 1} ^ {i - 1} 1 = \sum_ {i = 2} ^ {n - 1} i - 1 = (n - 2) (n - 1) / 2 = O \left(n ^ {2}\right)
$$

所以在最坏情况下该语句的频度是  $O(n^{2})$

# 09. A

当程序段中有条件判断语句时，取分支路径上的最大时间复杂度。

# 10. A

$\mathrm{m}++$  语句的执行次数为

$$
\sum_ {i = 1} ^ {n} \sum_ {j = 1} ^ {2 i} 1 = \sum_ {i = 1} ^ {n} 2 i = 2 \sum_ {i = 1} ^ {n} i = n (n + 1)
$$

# 11. C

本题求的是递归调用的时间复杂度，递归调用可视为多重循环，每次递归执行的基本语句是if  $(n == 1)$  return 1；，因此可认为单层循环的执行次数为1，设递归次数为  $t,2^{t}\leqslant n$  ，即  $t\leqslant \log_2n$  共执行了  $\log_2n$  次递归调用，总执行次数  $T = \log_2n\times 1$  ，所以时间复杂度为  $O(\log_2n)$  。

<table><tr><td>循环变量i</td><td>单层循环语句</td><td>单层循环执行次数</td></tr><tr><td>n</td><td>if (n==1) return 1;</td><td>1</td></tr><tr><td>n/2</td><td>if (n==1) return 1;</td><td>1</td></tr><tr><td>n/4</td><td>if (n==1) return 1;</td><td>1</td></tr><tr><td>...</td><td>...</td><td>...</td></tr><tr><td>1</td><td>if (n==1) return 1;</td><td>1</td></tr></table>

# 12. A

基本运算（执行频率最高的语句）为  $x = 2 * x$ ，每执行一次， $x$  乘以 2，设执行次数为  $t$ ，则有  $2^{t + 1} < n / 2$ ，所以  $t < \log_2(n / 2) - 1 = \log_2 n - 2$ ，得  $T(n) = O(\log_2 n)$ 。

# 13. B

本题求的是递归调用的时间复杂度，递归调用可视为多重循环，每次递归执行的基本语句是if  $(n<=1)$  return 1；，因此可以认为单层循环的执行次数为1，共执行了  $n$  次递归调用，总

执行次数  $T = 1 + 1 + \dots + 1 = n$ ，所以时间复杂度为  $O(n)$ 。

<table><tr><td>循环变量i</td><td>单层循环语句</td><td>单层循环执行次数</td></tr><tr><td>n</td><td>if (n&lt;=1) return 1;</td><td>1</td></tr><tr><td>n-1</td><td>if (n&lt;=1) return 1;</td><td>1</td></tr><tr><td>n-2</td><td>if (n&lt;=1) return 1;</td><td>1</td></tr><tr><td>...</td><td>...</td><td>...</td></tr><tr><td>1</td><td>if (n&lt;=1) return 1;</td><td>1</td></tr></table>

# 14. C

对于单层循环如 for  $(j = 1; j <= n; j++)$  count++;，可以直接数出执行次数为  $n$  ，因此可将多层循环转换成多个并列的单层循环，且列出每个单层循环如下（假设  $t$  为循环变量的幂次）：

<table><tr><td>循环变量k</td><td>单层循环语句</td><td>单层循环执行次数</td></tr><tr><td>1</td><td>for(j=1;j&lt;=n;j++)</td><td>n</td></tr><tr><td>2¹</td><td>for(j=1;j&lt;=n;j++)</td><td>n</td></tr><tr><td>2²</td><td>for(j=1;j&lt;=n;j++)</td><td>n</td></tr><tr><td>...</td><td>...</td><td>...</td></tr><tr><td>2&#x27;</td><td>for(j=1;j&lt;=n;j++)</td><td>n</td></tr></table>

进入外层循环的条件是  $k \leqslant n$  ，当循环结束时，循环变量的幂次  $t$  满足  $2^{t} \leqslant n < 2^{t + 1}$  ，即  $t \leqslant \log_2 n$  。所以总执行次数  $T = n(t + 1) = n(\log_2 n + 1)$  ，时间复杂度为  $O(n \log_2 n)$  。

# 15. B

基本运算为  $\mathrm{sum} += + + \mathrm{i}$ ，等价于“++i；sum=sum+i”，每执行一次，i都自增1。当  $\mathrm{i}=1$  时， $\mathrm{sum}=0+1$ ；当  $\mathrm{i}=2$  时， $\mathrm{sum}=0+1+2$ ；当  $\mathrm{i}=3$  时， $\mathrm{sum}=0+1+2+3$ ，以此类推，得出  $\mathrm{sum}=0+1+2+3+\cdots+\mathrm{i}=(1+\mathrm{i})\times\mathrm{i}/2$ ，可知循环次数  $t$  满足  $(1+t)\times t/2 < n$ ，故时间复杂度为  $O(n^{1/2})$ 。

# 注意

统考真题中常将  $\log_2$  书写为  $\log$  ，此时默认底数为2。

# 16. B

假设第  $k$  次循环终止，则第  $k$  次执行时， $(x + 1)^2 > n$ ， $x$  的初始值为0，第  $k$  次判断时， $x = k - 1$ ，即  $k^2 > n$ ， $k > \sqrt{n}$ ，因此该程序段的时间复杂度为  $O(n^{1/2})$ 。

# 17. B

对于单层循环如 for  $(j = 0; j <= i; j++)$  sum++;，可以直接数出执行次数为  $i$ ，因此可将多层循环转换成多个并列的单层循环，且列出每个单层循环如下（假设  $t$  为循环变量的幂次）：

<table><tr><td>循环变量i</td><td>单层循环语句</td><td>单层循环执行次数</td></tr><tr><td>1</td><td>for(j=0;j&lt;1;j++)</td><td>1</td></tr><tr><td>2¹</td><td>for(j=0;j&lt;2;j++)</td><td>2</td></tr><tr><td>2²</td><td>for(j=0;j&lt;2²;j++)</td><td>4</td></tr><tr><td>...</td><td>...</td><td>...</td></tr><tr><td>2&#x27;</td><td>for(j=0;j&lt;2t;j++)</td><td>2&#x27;</td></tr></table>

进入外层循环的条件是  $i < n$  ，当循环结束时，循环变量的幂次  $t$  满足  $2^{t} < n \leqslant 2^{t + 1}$  。总执行次数  $T = 1 + 2^{1} + 2^{2} + \dots + 2^{t} = 2^{t + 1} - 1$  ，即  $n - 1 \leqslant T$  且  $T < 2n - 1$  ，所以时间复杂度为  $O(n)$  。

# 二、综合应用题

# 01.【解答】

① 基本语句  $\mathrm{k} = \mathrm{k} + {10} * \mathrm{i}$  共执行了  $n - 2$  次,所以  $T\left( n\right)  = O\left( n\right)$  。

② 设循环体共执行  $t$  次，每循环一次，循环变量  $y$  加1，最终  $t = y$  。故  $t^2 \leqslant n$  ，得  $T(n) = O(n^{1/2})$  。

③ 内循环执行  $m$  次，外循环执行  $n$  次，根据乘法原理，共执行了  $m \times n$  次，故  $T(m, n) = O(m \times n)$ 。

# 归纳总结

本章的重点是分析程序的时间复杂度。一定要掌握分析时间复杂度的方法和步骤，很多读者在做题时一眼就能看出程序的时间复杂度，但就是无法规范地表述其推导过程。为此，编者查阅众多资料，总结出了此类题型的两种形式，供大家参考。

# 1. 循环主体中的变量参与循环条件的判断

在用于递推实现的算法中，首先找出基本运算的执行次数  $x$  与问题规模  $n$  之间的关系式，解得  $x = f(n)$ ， $f(n)$  的最高次幂为  $k$ ，则算法的时间复杂度为  $O(n^{k})$ 。例如，

```javascript
1. int  $i = 1$  2. int  $\mathrm{y} = 5$  while  $(\mathrm{i} <   = \mathrm{n})$  while  $(\mathrm{(y + 1)}^{\star}\mathrm{(y + 1)} <   \mathrm{n})$  i=i\*2; y=y+1;
```

在例1中，设基本运算  $\mathrm{i} = \mathrm{i}\star 2$  的执行次数为  $t$  ，则  $2^{\prime}\leqslant n$  ，解得  $t\leqslant \log_2n$  ，故  $T(n) = O(\log_2n)$

在例2中，设基本运算  $\mathrm{Y = Y + 1}$  的执行次数为  $t$  ，则  $t = y - 5$  ，且  $(t + 5 + 1)(t + 5 + 1) < n$  ，解得  $t < \sqrt{n} -6$  ，即  $T(n) = O(\sqrt{n})$  。

# 2. 循环主体中的变量与循环条件无关

此类题可采用数学归纳法或直接累计循环次数。多层循环时从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。此类问题又可分为递归程序和非递归程序：

- 递归程序一般使用公式进行递推。时间复杂度的分析如下：

$$
T (n) = 1 + T (n - 1) = 1 + 1 + T (n - 2) = \dots = n - 1 + T (1)
$$

即  $T(n) = O(n)$

- 非递归程序的分析比较简单，可以直接累计次数。本节前面给出了相关的习题。

# 思维拓展

求解斐波那契数列

$$
F (n) = \left\{ \begin{array}{l l} 0, & n = 0 \\ 1, & n = 1 \\ F (n - 1) + F (n - 2), & n > 1 \end{array} \right.
$$

有两种常用的算法：递归算法和非递归算法。试分别分析两种算法的时间复杂度。

# 提示

请结合归纳总结中的两种方法进行解答。

# 第2章

# 线性表

# 【考纲内容】

（一）线性表的基本概念

（二）线性表的实现顺序存储；链式存储

（三）线性表的应用


#


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d1e9a7c3575ab11fe43987bcc353e0e19895bc91473f585f21a6d3e9dcf43900.jpg)



视频讲解


# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a63c86b2f918f5e353b3482fe8b646d488cd97dfeb4aa6c3b5f61f9c111d8378.jpg)


# 【复习提示】

线性表是算法题命题的重点。这类算法题的实现比较容易且代码量较少，但是要求具有最优的性能（时间/空间复杂度），才能获得满分。因此，应牢固掌握线性表的各种基本操作（基于两种存储结构），在平时的学习中多注重培养动手能力。另需提醒的是，算法最重要的是思想！考场上的时间紧迫，在试卷上不一定要求代码具有实际的可执行性，因此应尽力表达出算法的思想和步骤，而不必过于拘泥所有细节。此外，采用时间/空间复杂度较差的方法也能拿到大部分分数，因此在时间紧迫的情况下，建议直接采用暴力法。注意，算法题只能用C/C++语言实现。

# 2.1 线性表的定义和基本操作

# 2.1.1 线性表的定义

线性表是具有相同数据类型的  $n$  （  $n\geqslant 0$  ）个数据元素的有限序列，其中  $n$  为表长，当  $n = 0$  时线性表是一个空表。若用  $L$  命名线性表，则其一般表示为

$$
L = \left(a _ {1}, a _ {2}, \dots , a _ {i}, a _ {i + 1}, \dots , a _ {n}\right)
$$

式中， $a_1$  是唯一的“第一个”数据元素，也称表头元素； $a_n$  是唯一的“最后一个”数据元素，也称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。

由此，我们得出线性表的特点如下：

- 表中元素的个数有限。

- 表中元素具有逻辑上的顺序性，表中元素有其先后次序。

- 表中元素都是数据元素，每个元素都是单个元素。

- 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。

- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。

# 注意

线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。

# 2.1.2 线性表的基本操作

一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下。

- InitList(&L): 初始化表。构造一个空的线性表。

- Length(L)：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。

- LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。

- GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。

- ListInsert(&L,i,e): 插入操作。在表 L 中的第 i 个位置上插入指定元素 e。

- ListDelete(&L,i,&e): 删除操作。删除表 L 中第 i 个位置的元素, 并用 e 返回删除元素的值。

- PrintList(L): 输出操作。按前后顺序输出线性表 L 的所有元素值。

- Empty(L)：判空操作。若 L 为空表，则返回 true，否则返回 false。

- DestroyList(&L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间。

# 注意

① 基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也不同。② 符号“&”表示 C++ 语言中的引用调用，在 C 语言中采用指针也可达到同样的效果。

# 2.1.3 本节试题精选

# 单项选择题

01. 线性表是具有  $n$  个（）的有限序列。

A. 数据表

B. 字符

C. 数据元素

D. 数据项

02. 下列几种描述中，（）是一个线性表。

A. 由  $n$  个实数组成的集合

B. 由 100 个字符组成的序列

C. 所有整数组成的序列

D. 邻接表

03. 在线性表中，除开始元素外，每个元素（）。

A. 只有唯一的前驱元素

B. 只有唯一的后继元素

C. 有多个前驱元素

D. 有多个后继元素

04. 若非空线性表中的元素既没有直接前驱，又没有直接后继，则该表中有（）个元素。

A. 1

B. 2

C. 3

D.  $n$

# 2.1.4 答案与解析

# 单项选择题

01. C

线性表是由具有相同数据类型的有限数据元素组成的，数据元素是由数据项组成的。

02. B

线性表定义的要求为：相同数据类型、有限序列。选项C的元素个数是无穷个，错误；选项A集合中的元素没有前后驱关系，错误；选项D属于一种存储结构，本题要求选出的是一个具体的线性表，不要将二者混为一谈。只有选项B符合线性表定义的要求。

03. A

线性表中，除最后一个（或第一个）元素外，每个元素都只有一个后继（或前驱）元素。

04. A

线性表中的第一个元素没有直接前驱，最后一个元素没有直接后继；当线性表中仅有一个元素时，该元素既没有直接前驱，又没有直接后继。

# 2.2 线性表的顺序表示

# 2.2.1 顺序表的定义

命题追踪 （算法题）顺序表的应用（2010、2011、2018、2020）

线性表的顺序存储也称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在顺序表的起始位置，第  $i$  个元素的存储位置后面紧接着存储的是第  $i + 1$  个元素，称  $i$  为元素  $a_{i}$  在顺序表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其存储的物理顺序相同。

假设顺序表 L 存储的起始位置为 LOC(A)，sizeof(ElementType) 是每个数据元素所占用存储空间的大小，则表 L 所对应的顺序存储结构如图 2.1 所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b6701e4be1c27ff04618a47a9a7b136d3c6962a7aabbd04e41b173a371900794.jpg)



图2.1 线性表的顺序存储结构


每个数据元素的存储位置都和顺序表的起始位置相差一个和该数据元素的位序成正比的常数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。

# 注意

线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。

假定线性表的元素类型为ElemType，则静态分配的顺序表存储结构描述为

```txt
define MaxSize 50 //定义线性表的最大  
typedef struct{ ElemType data[MaxSize]; //顺序表的元素 int length; //顺序表的当前长度 }SqList; //顺序表的类型定义
```

一维数组可以是静态分配的，也可以是动态分配的。对数组进行静态分配时，因为数组的大小和空间事先已经固定，所以一旦空间占满，再加入新数据就会产生溢出，进而导致程序崩溃。

而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到扩充数组存储空间的目的，而不需要为线性表一次性地划分所有空间。

动态分配的顺序表存储结构描述为

```txt
define InitSize 100 //表长度的初始定义  
typedef struct{ElemType *data; //指示动态分配数组的指针int MaxSize,length; //数组的最大容量和当前个数}SeqList; //动态分配数组顺序表的类型定义
```

C 的初始动态分配语句为

```txt
L.data  $=$  (ElemType\*)malloc(sizeof(ElemType)\*InitSize);
```

$\mathrm{C}++$  的初始动态分配语句为

```javascript
L.data = new ElemType[InitSize];
```

# 注意

动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。

顺序表的主要优点：①可进行随机访问，即可通过首地址和元素序号可以在  $O(1)$  时间内找到指定的元素；②存储密度高，每个结点只存储数据元素。顺序表的缺点也很明显：①元素的插入和删除需要移动大量的元素，插入操作平均需要移动  $n / 2$  个元素，删除操作平均需要移动  $(n - 1) / 2$  个元素；②顺序存储分配需要一段连续的存储空间，不够灵活。

# 2.2.2 顺序表上基本操作的实现

# 命题追踪

# 顺序表上操作的时间复杂度分析（2023）

这里仅讨论顺序表的初始化、插入、删除和按值查找，其他基本操作的算法都很简单。

# 注意

在各种操作的实现中（包括严蔚敏老师撰写的教材），往往可以忽略边界条件判断、变量定义、内存分配不足等细节，即不要求代码具有可执行性，而重点在于算法的思想。

# 1. 顺序表的初始化

静态分配和动态分配的顺序表的初始化操作是不同的。静态分配在声明一个顺序表时，就已为其分配了数组空间，因此初始化时只需将顺序表的当前长度设为0。

```javascript
//SqList L; //声明一个顺序表  
void InitList(SqList &L) {  
    L.length = 0; //顺序表初始长度为 0  
}
```

动态分配的初始化为顺序表分配一个预定义大小的数组空间，并将顺序表的当前长度设为0。MaxSize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足，就进行再分配。

```txt
void InitList(SeqList &L){ L.data=(ElemType *)malloc(InitSize* sizeof(ElemType)); //分配存储空间 L.length=0; //顺序表初始长度为0 L.MaxSize=InitSize; //初始存储容量 }
```

# 2. 插入操作

在顺序表 L 的第 i（ $1 <= \mathrm{i} <= \mathrm{L.length} + 1$ ）个位置插入新元素 e。若 i 的输入不合法，则返回 false，表示插入失败；否则，将第 i 个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素 e，顺序表长度增加 1，插入成功，返回 true。

```txt
bool ListInsert(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1)
        return false;
    if (L.length >= MaxSize)
        return false;
    for (int j = L.length; j >= i; j--) 
        L.data[j] = L.data[j-1];
    L.data[i-1] = e;
    L.length++;
    return true;
}
```

# 注意

区别顺序表的位序和数组下标。为何判断插入位置是否合法时 if 语句中用 length+1，而移动元素的 for 语句中只用 length?

最好情况：在表尾插入  $(i = n + 1)$  ，元素后移语句将不执行，时间复杂度为  $O(1)$

最坏情况：在表头插入  $(i = 1)$  ，元素后移语句将执行  $n$  次，时间复杂度为  $O(n)$  。

平均情况：假设  $p_i$  （  $p_i = 1 / (n + 1)$  ）是在第  $i$  个位置上插入一个结点的概率，则在长度为  $n$  的线性表中插入一个结点时，所需移动结点的平均次数为

$$
\sum_ {i = 1} ^ {n + 1} p _ {i} (n - i + 1) = \sum_ {i = 1} ^ {n + 1} \frac {1}{n + 1} (n - i + 1) = \frac {1}{n + 1} \sum_ {i = 1} ^ {n + 1} (n - i + 1) = \frac {1}{n + 1} \frac {n (n + 1)}{2} = \frac {n}{2}
$$

因此，顺序表插入算法的平均时间复杂度为  $O(n)$

# 3. 删除操作

删除顺序表 L 中第 i（ $1 <= \mathrm{i} <= \mathrm{L}$ ）、长度（ $\mathrm{length}$ ）个位置的元素，用引用变量 e 返回。若 i 的输入不合法，则返回 false；否则，将被删元素赋给引用变量 e，并将第 i+1 个元素及其后的所有元素依次往前移动一个位置，返回 true。

```javascript
bool ListDelete(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) //判断 i 的范围是否有效
        return false;
    e = L.data[i-1];
    for (int j = i; j < L.length; j++) //将被删除的元素赋值给 e
        L.data[j-1] = L.data[j];
    L.length--;
    return true;
}
```

最好情况：删除表尾元素  $(i = n)$  ，无须移动元素，时间复杂度为  $O(1)$

最坏情况：删除表头元素（ $i = 1$ ），需移动除表头元素外的所有元素，时间复杂度为  $O(n)$ 。

平均情况：假设  $p_i$  （  $p_i = 1 / n$  ）是删除第  $i$  个位置上结点的概率，则在长度为  $n$  的线性表中删除一个结点时，所需移动结点的平均次数为

$$
\sum_ {i = 1} ^ {n} p _ {i} (n - i) = \sum_ {i = 1} ^ {n} \frac {1}{n} (n - i) = \frac {1}{n} \sum_ {i = 1} ^ {n} (n - i) = \frac {1}{n} \frac {n (n - 1)}{2} = \frac {n - 1}{2}
$$

因此，顺序表删除算法的平均时间复杂度为  $O(n)$

可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插入和删除元素的位置。图2.2所示为一个顺序表在进行插入和删除操作前、后的状态，以及其数据元素在存储空间中的位置变化和表长变化。在图2.2(a)中，将第4个至第7个元素从后往前依次后移一个位置，在图2.2(b)中，将第5个至第7个元素从前往后依次前移一个位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/98aa472fc3feeccf53ea6ef399ffcbbe3addb777d861cccc537579d3d22c93d0.jpg)



(a) 插入新元素示例


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/761d74250bdb62fd187651426133a2d696e82452711b93a53d2204a7f3c9798a.jpg)



(b) 删除表中元素示例



图2.2 顺序表的插入和删除


# 4. 按值查找（顺序查找）

在顺序表 L 中查找第一个元素值等于 e 的元素，并返回其位序。

```javascript
int LocateElem(SqList L, ElemType e) { int i; for(i=0;i<L.length;i++) if(L.data[i] == e) return i+1; //下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败 }
```

最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为  $O(1)$ 。

最坏情况：查找的元素在表尾（或不存在）时，需要比较  $n$  次，时间复杂度为  $O(n)$ 。

平均情况：假设  $p_i$  （  $p_i = 1 / n$  ）是查找的元素在第i（  $1 <= \mathrm{i} <= \mathrm{L}$  .length）个位置上的概率，则在长度为  $n$  的线性表中查找值为e的元素所需比较的平均次数为

$$
\sum_ {i = 1} ^ {n} p _ {i} \cdot i = \sum_ {i = 1} ^ {n} \frac {1}{n} \cdot i = \frac {1}{n} \frac {n (n + 1)}{2} = \frac {n + 1}{2}
$$

因此，顺序表按值查找算法的平均时间复杂度为  $O(n)$

顺序表的按序号查找非常简单，即直接根据数组下标访问数组元素，其时间复杂度为  $O(1)$ 。

# 2.2.3 本节试题精选

# 一、单项选择题

01. 下列叙述中，（）是顺序存储结构的优点。

A. 存储密度大

B. 插入运算方便

C. 删除运算方便

D. 方便地运用于各种逻辑结构的存储表示

02. 下列关于顺序表的叙述中，正确的是（）。

A. 顺序表可以利用一维数组表示, 因此顺序表与一维数组在逻辑结构上是相同的

B. 在顺序表中, 逻辑上相邻的元素物理位置上不一定相邻

C. 顺序表和一维数组一样，都可以进行随机存取

D. 在顺序表中, 每个元素的类型不必相同

03. 线性表的顺序存储结构是一种（）。

A. 随机存取的存储结构

B. 顺序存取的存储结构

C. 索引存取的存储结构

D. 散列存取的存储结构

04. 通常说顺序表具有随机存取的特性，指的是（）。

A. 查找值为  $x$  的元素的时间与顺序表中元素个数  $n$  无关

B. 查找值为  $x$  的元素的时间与顺序表中元素个数  $n$  有关

C. 查找序号为  $i$  的元素的时间与顺序表中元素个数  $n$  无关

D. 查找序号为  $i$  的元素的时间与顺序表中元素个数  $n$  有关

05. 一个顺序表所占用的存储空间大小与（）无关。

A. 表的长度

B. 元素的存放顺序

C. 元素的类型

D. 元素中各字段的类型

06. 若线性表最常用的操作是存取第  $i$  个元素及其前驱和后继元素的值，为了提高效率，应采用（）的存储方式。

A. 单链表

B. 双链表

C. 循环单链表

D. 顺序表

07. 一个线性表最常用的操作是存取任意一个指定序号的元素并在最后进行插入、删除操作，则利用（）存储方式可以节省时间。

A. 顺序表

B. 双链表

C. 带头结点的循环双链表

D. 循环单链表

08. 在  $n$  个元素的线性表的数组表示中，时间复杂度为  $O(1)$  的操作是（）。

I. 访问第  $i$  （  $1\leqslant i\leqslant n$  ）个结点和求第  $i$  （  $2\leqslant i\leqslant n$  ）个结点的直接前驱

II. 在最后一个结点后插入一个新的结点

III. 删除第1个结点

IV. 在第  $i$  （  $1\leqslant i\leqslant n$  ）个结点后插入一个结点

A. I

B. II、III

C. I、II

D. I、II、III

09. 设线性表有  $n$  个元素，严格说来，以下操作中，（）在顺序表上实现要比在链表上实现的效率高。

I. 输出第  $i$  （  $1\leqslant i\leqslant n$  ）个元素值

II. 交换第3个元素与第4个元素的值

III. 顺序输出这  $n$  个元素的值

A. I

B. I、III

C. I、II

D. II、III

10. 在一个长度为  $n$  的顺序表中删除第  $i$  （  $1 \leqslant i \leqslant n$  ）个元素时，需向前移动（）个元素。

A.  $n$

B.  $i - 1$

C.  $n - i$

D.  $n - i + 1$

11. 对于顺序表，访问第  $i$  个位置的元素和在第  $i$  个位置插入一个元素的时间复杂度为（）。

A.  $O(n), O(n)$

B.  $O(n), O(1)$

C.  $O(1), O(n)$

D.  $O(1), O(1)$

12. 对于顺序存储的线性表，其算法时间复杂度为  $O(1)$  的运算应该是（）。

A. 将  $n$  个元素从小到大排序

B. 删除第  $i$  （  $1\leqslant i\leqslant n$  ）个元素

C. 改变第  $i(1 \leqslant i \leqslant n)$  个元素的值

D. 在第  $i(1 \leqslant i \leqslant n)$  个元素后插入一个新元素

13. 若长度为  $n$  的非空线性表采用顺序存储结构，在表的第  $i$  个位置插入一个数据元素，则  $i$  的合法值应该是（）。

A.  $1 \leqslant i \leqslant n$

B.  $1 \leqslant i \leqslant n + 1$

C.  $0 \leqslant i \leqslant n - 1$

D.  $0 \leqslant i \leqslant n$

14. 顺序表的插入算法中，当  $n$  个空间已满时，可再申请增加分配  $m$  个空间，若申请失败，则说明系统没有（）可分配的存储空间。

A.  $m$  个

B.  $m$  个连续

C.  $n + m$  个

D.  $n + m$  个连续

15.【2023统考真题】在下列对顺序存储的有序表（长度为  $n$  ）实现给定操作的算法中，平均时间复杂度为  $O(1)$  的是（）。

A. 查找包含指定值元素的算法

B. 插入包含指定值元素的算法

C. 删除第  $i(1 \leqslant i \leqslant n)$  个元素的算法

D. 获取第  $i$  （  $1 \leqslant i \leqslant n$  ）个元素的算法

# 二、综合应用题

01. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。

02. 设计一个高效算法，将顺序表  $L$  的所有元素逆置，要求算法的空间复杂度为  $O(1)$ 。

03. 对长度为  $n$  的顺序表  $L$ ，编写一个时间复杂度为  $O(n)$  、空间复杂度为  $O(1)$  的算法，该算法删除顺序表中所有值为  $x$  的数据元素。

04. 从顺序表中删除其值在给定值  $s$  和  $t$  之间（包含  $s$  和  $t$ ，要求  $s < t$ ）的所有元素，若  $s$  或  $t$  不合理或顺序表为空，则显示出错信息并退出运行。

05. 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

06. 将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。

07. 已知在一维数组  $A[m + n]$  中依次存放两个线性表  $(a_{1}, a_{2}, a_{3}, \dots, a_{m})$  和  $(b_{1}, b_{2}, b_{3}, \dots, b_{n})$ 。编写一个函数，将数组中两个顺序表的位置互换，即将  $(b_{1}, b_{2}, b_{3}, \dots, b_{n})$  放在  $(a_{1}, a_{2}, a_{3}, \dots, a_{m})$  的前面。

08. 线性表  $(a_{1}, a_{2}, a_{3}, \dots, a_{n})$  中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为  $x$  的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。

09. 给定三个序列  $A$  、  $B$  、  $C$  ，长度均为  $n$  ，且均为无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。例如，数组  $A$  为  $\{1,2,3\}$  ，数组  $B$  为  $\{2,3,4\}$  ，数组  $C$  为  $\{-1,0,2\}$  ，则输出2。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你的算法的时间复杂度和空间复杂度。

10.【2010统考真题】设将  $n(n > 1)$  个整数存放到一维数组  $R$  中。设计一个在时间和空间两方面都尽可能高效的算法。将  $R$  中保存的序列循环左移  $p(0 < p < n)$  个位置，即将  $R$  中的数据由  $(X_0, X_1, \dots, X_{n-1})$  变换为  $(X_p, X_{p+1}, \dots, X_{n-1}, X_0, X_1, \dots, X_{p-1})$ 。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  或Java语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

11.【2011统考真题】一个长度为  $L(L\geqslant 1)$  的升序序列  $S$  ，处在第  $\lceil L / 2\rceil$  个位置的数称为  $S$

的中位数。例如，若序列  $S_{1} = (11, 13, 15, 17, 19)$ ，则  $S_{1}$  的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若  $S_{2} = (2, 4, 6, 8, 20)$ ，则  $S_{1}$  和  $S_{2}$  的中位数是 11。现在有两个等长升序序列  $A$  和  $B$ ，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列  $A$  和  $B$  的中位数。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  或Java语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

12.【2013统考真题】已知一个整数序列  $A = (a_{0}, a_{1}, \dots, a_{n-1})$ ，其中  $0 \leqslant a_{i} < n$ （ $0 \leqslant i < n$ ）。若存在  $a_{p1} = a_{p2} = \dots = a_{pm} = x$  且  $m > n / 2$ （ $0 \leqslant p_{k} < n, 1 \leqslant k \leqslant m$ ），则称  $x$  为  $A$  的主元素。例如  $A = (0, 5, 5, 3, 5, 7, 5, 5)$ ，则5为主元素；又如  $A = (0, 5, 5, 3, 5, 1, 5, 7)$ ，则  $A$  中没有主元素。假设  $A$  中的  $n$  个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出  $A$  的主元素。若存在主元素，则输出该元素；否则输出-1。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  或Java语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

13.【2018统考真题】给定一个含  $n(n\geqslant 1)$  个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组  $\{-5,3,2,3\}$  中未出现的最小正整数是1；数组  $\{1,2,3\}$  中未出现的最小正整数是4。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

14.【2020统考真题】定义三元组  $(a, b, c)$  ( $a, b, c$  均为整数)的距离  $D = |a - b| + |b - c| + |c - a|$ 。给定3个非空整数集合  $S_{1}$ 、 $S_{2}$  和  $S_{3}$ ，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组  $(a, b, c)$ （ $a \in S_{1}$ ， $b \in S_{2}$ ， $c \in S_{3}$ ）中的最小距离。例如  $S_{1} = \{-1, 0, 9\}$ ， $S_{2} = \{-25, -10, 10, 11\}$ ， $S_{3} = \{2, 9, 17, 30, 41\}$ ，则最小距离为2，相应的三元组为(9, 10, 9)。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C语言或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

# 2.2.4 答案与解析

# 一、单项选择题

# 01. A

顺序表不像链表那样要在结点中存放指针域，因此存储密度大，选项A正确。选项B和C是链表的优点。选项D是错误的，比如对于树形结构，顺序表显然不如链表表示起来方便。

# 02. C

顺序表是顺序存储的线性表，表中所有元素的类型必须相同，且必须连续存放。一维数组中的元素可以不连续存放；此外，栈、队列和树等逻辑结构也可利用一维数组表示，但它与顺序表不属于相同的逻辑结构。在顺序表中，逻辑上相邻的元素物理位置上也相邻。

# 03. A

本题易误选选项B。注意，存取方式是指读/写方式。顺序表是一种支持随机存取的存储结

构，根据起始地址加上元素的序号，可以很方便地访问任意一个元素，这就是随机存取的概念。

04. C

随机存取是指在  $O(1)$  的时间访问下标为  $i$  的元素，所需时间与顺序表中的元素个数  $n$  无关。

05. B

顺序表所占的存储空间  $=$  表长  $\times$  sizeof（元素的类型），表长和元素的类型显然会影响存储空间的大小。若元素为结构体类型，则元素中各字段的类型也会影响存储空间的大小。

06. D

题干实际要求能最快存取第  $i - 1$  、  $i$  和  $i + 1$  个元素值。选项A、B、C都只能从头结点依次顺序查找，时间复杂度为  $O(n)$  ；只有顺序表可以按序号随机存取，时间复杂度为  $O(1)$  。

07. A

只有顺序表可以按序号随机存取，且在最后进行插入和删除操作时不需要移动任何元素。

08.C

对于I，解析略；对于II，在最后位置插入新结点不需要移动元素，时间复杂度为  $O(1)$  ；对于III，被删结点后的结点需要依次前移，时间复杂度为  $O(n)$  ；对于IV，需要后移  $n - i$  个结点，时间复杂度为  $O(n)$  。

09. C

对于II，顺序表只需要3次交换操作；链表则需要分别找到两个结点前驱，第4个结点断链后再插入到第2个结点后，效率较低。对于III，需依次顺序访问每个元素，时间复杂度相同。

10. C

需要将元素  $a_{i + 1}\sim a_n$  依次前移一位，共移动  $n - (i + 1) + 1 = n - i$  个元素。

11. C

在第  $i$  个位置插入一个元素，需要移动  $n - i + 1$  个元素，时间复杂度为  $O(n)$ 。

12. C

对  $n$  个元素进行排序的时间复杂度最小也要  $O(n)$  （初始有序时），通常为  $O(n\log_2n)$  或  $O(n^2)$  通过第8章学习后会更理解。选项B和D显然错误。顺序表支持按序号的随机存取方式。

13. B

线性表元素的序号是从1开始，而在第  $n + 1$  个位置插入相当于在表尾追加。

14. D

顺序存储需要连续的存储空间，在申请时需申请  $n + m$  个连续的存储空间，然后将线性表原来的  $n$  个元素复制到新申请的  $n + m$  个连续的存储空间的前  $n$  个单元。

15. D

对于顺序存储的有序表，查找指定值元素可以采用顺序查找法或折半查找法，平均时间复杂度最少为  $O(\log_2n)$  。插入指定值元素需要先找到插入位置，然后将该位置及之后的元素依次后移一个位置，最后将指定值元素插入到该位置，平均时间复杂度为  $O(n)$  。删除第  $i$  个元素需要将该元素之后的全部元素依次前移一个位置，平均时间复杂度为  $O(n)$  。获取第  $i$  个元素只需直接根据下标读取对应的数组元素即可，时间复杂度为  $O(1)$  。

# 二、综合应用题

# 01.【解答】

算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。

本题代码如下：

```javascript
bool Del_Min(SqList &L,ElemType &value){ //删除顺序表L中最小值元素结点，并通过引用型参数value返回其值 //若删除成功，则返回true；否则返回false if(L.length  $= = 0$  ） return false; //表空，中止操作返回 value  $\equiv$  L.data[0]; int pos  $= 0$  ： //假定0号元素的值最小 for(int i=1;i<L.length;i++) //循环，寻找具有最小值的元素 if(L.data[i]<value){ //让value记忆当前具有最小值的元素 value  $\equiv$  L.data[i]； pos=i; } L.data[pos]  $\equiv$  L.data[L.length-1]; //空出的位置由最后一个元素填补 L.length--; return true; //此时，value为最小值 }
```

# 注意

本题也可用函数返回值返回，两者的区别是：函数返回值只能返回一个值，而参数返回（引用传参）可以返回多个值。

# 02.【解答】

算法思想：扫描顺序表  $L$  的前半部分元素，对于元素L.data[i]（ $0 <= i < L.length / 2$ ），将其与后半部分的对应元素L.data[L.length-i-1]进行交换。

本题代码如下：

```javascript
void Reverse(SqList &L){ElemType temp; //辅助变量for(int  $\mathrm{i} = 0;\mathrm{i} <   \mathrm{L}$  .length/2;i++){temp  $=$  L.data[i]; //交换L.data[i]与L.data[L.length-i-1]L.data[i]=L.data[L.length-i-1];L.data[L.length-i-1]=temp;1
```

# 03.【解答】

解法1：用  $k$  记录顺序表  $L$  中不等于  $x$  的元素个数（需要保存的元素个数），扫描时将不等于  $x$  的元素移动到下标  $k$  的位置，并更新  $k$  值。扫描结束后修改  $L$  的长度。

本题代码如下：

```lisp
void del_x_1(SqList &L, ElemType x) {
//本算法实现删除顺序表 L 中所有值为 x 的数据元素
int k = 0, i; //记录值不等于 x 的元素个数
for (i = 0; i < L.length; i++) 
    if (L.data[i] != x) {
        L.data[k] = L.data[i];
        k++; //不等于 x 的元素增 1
    }
}
```

解法2：用  $k$  记录顺序表  $L$  中等于  $x$  的元素个数，一边扫描  $L$  ，一边统计  $k$  ，并将不等于  $x$  的元素前移  $k$  个位置。扫描结束后修改  $L$  的长度。

本题代码如下：

```txt
void del_x_2(SqList &L, ElemType x) {
    int k=0, i=0; //k记录值等于x的元素个数
    while (i<L.length) {
        if (L.data[i] == x)
            k++;
        else
            L.data[i-k] = L.data[i]; //当前元素前移k个位置
            i++;
        }
    L.length = L.length - k; //顺序表L的长度递减
}
```

此外，本题还可以考虑设头、尾两个指针（ $i = 1, j = n$ ），从两端向中间移动，在遇到最左端值  $x$  的元素时，直接将最右端值非  $x$  的元素左移至值为  $x$  的数据元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。

# 04.【解答】

算法思想：从前向后扫描顺序表  $L$  ，用  $k$  记录值在  $s$  和  $t$  之间的元素个数（初始时  $k = 0$  )。对于当前扫描的元素，若其值不在  $s$  和  $t$  之间，则前移  $k$  个位置；否则执行  $\mathrm{k} + +$  。每个不在  $s$  和  $t$  之间的元素仅移动一次，因此算法效率高。

本题代码如下：

```javascript
bool Del_s_t(SqList &L, ElemType s, ElemType t) { //删除顺序表L中值在给定值s和t（要求  $s < t$  ）之间的所有元素 int i, k = 0; if(L.length == 0 || s >= t) return false; //线性表为空或s、t不合法，返回 for(i = 0; i < L.length; i++) { if(L.data[i] >= s && L.data[i] <= t) k++; else L.data[i-k] = L.data[i]; //当前元素前移k个位置 } //for L.length -= k; //长度减小 return true; }
```

# 注意

本题也可从后向前扫描顺序表，每遇到一个值在  $s$  和  $t$  之间的元素，就删除该元素，其后的所有元素全部前移。但移动次数远大于前者，效率不够高。

# 05.【解答】

算法思想：注意是有序顺序表，值相同的元素一定在连续的位置上，用类似于直接插入排序的思想，初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾为止。

本题代码如下：

```javascript
bool Delete_Same(SeqList& L){ if(L.length  $= = 0$  ） return false; int i,j; //i存储第一个不相同的元素，j为工作指针 for  $(\mathrm{i} = 0,\mathrm{j} = 1;\mathrm{j} <   \mathrm{L}$  .length;j++) if(L.data[i]！  $= \mathbb{L}$  .data[j]) //查找下一个与上一个元素值不同的元素 L.data[++i]=L.data[j]; //找到后，将元素前移
```

```javascript
L.length=i+1; return true;
```

对于本题的算法，请读者用序列1,2,2,2,2,3,3,3,4,4,5来手动模拟算法的执行过程，在模拟过程中要标注  $i$  和  $j$  所指示的元素。

思考：若将本题中的有序表改为无序表，你能想到时间复杂度为  $O(n)$  的方法吗？

（提示：使用散列表。）

# 06.【解答】

算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。

本题代码如下：

```txt
bool Merge(SeqList A, SeqList B, SeqList &C) {
//将有序顺序表A与B合并为一个新的有序顺序表C
if(A.length + B.length > C.maxSize) //大于顺序表的最大长度
    return false;
int i = 0, j = 0, k = 0;
while (i < A.length && j < B.length) {
    if(A.data[i] <= B.data[j])
        C.data[k++] = A.data[i++;
    else
        C.data[k++] = B.data[j];
}
while (i < A.length)
    C.data[k++] = A.data[i];
while (j < B.length)
    C.data[k++] = B.data[j];
C.length = k;
return true;
}
```

# 注意

本算法的方法非常典型，需牢固掌握。

# 07.【解答】

算法思想：首先将数组  $A[m + n]$  中的全部元素  $(a_{1}, a_{2}, a_{3}, \dots, a_{m}, b_{1}, b_{2}, b_{3}, \dots, b_{n})$  原地逆置为  $(b_{n}, b_{n - 1}, b_{n - 2}, \dots, b_{1}, a_{m}, a_{m - 1}, a_{m - 2}, \dots, a_{1})$ ，然后对前  $n$  个元素和后  $m$  个元素分别使用逆置算法，即可得到  $(b_{1}, b_{2}, b_{3}, \dots, b_{n}, a_{1}, a_{2}, a_{3}, \dots, a_{m})$ ，从而实现顺序表的位置互换。

本题代码如下：

```c
typedef int DataType;  
void Reverse(DataType A[],int left,int right,int arraySize){  
//逆转(aleft,aleft+1,aleft+2,…,aright)为(aright,aright-1,…,aleft)  
if(left>=right||right>=arraySize)  
return;  
int mid=(left+right)/2;  
for(int i=0;i<=mid-left;i++){  
DataType temp=A(left+i);  
A(left+i)=A(right-i);  
A(right-i)=temp;  
}  
}  
void Exchange(DataType A[],int m,int n,int arraySize){  
/*数组A[m+n]中，从0到m-1存放顺序表(a1,a2,a3,…,am)，从m到m+n-1存放顺序表
```

```javascript
(b1,b2,b3，…,bn)，算法将这两个表的位置互换\*/Reverse(A,0,m+n-1,arraySize);Reverse(A,0,n-1,arraySize);Reverse(A,n,m+n-1,arraySize);
```

# 08.【解答】

算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最少的时间在表中查找数值为  $x$  的元素”，这里应使用折半查找法。

本题代码如下：

```lisp
void SearchExchangeInsert(ElemType A[],ElemType x) {
    int low = 0, high = n - 1, mid; //low 和 high 指向顺序表下界和上界的下标
    while (low <= high) {
        mid = (low + high) / 2; //找中间位置
        if (A[mid] == x) break; //找到 x，退出 while 循环
        else if (A[mid] < x) low = mid + 1; //到中点 mid 的右半部去查
        else high = mid - 1; //到中点 mid 的左半部去查
    }
    //下面两个 if 语句只会执行一个
    if (A[mid] == x && mid != n - 1) {
        //若最后一个元素与 x 相等，则不存在与其后
        //继交换的操作
        t = A[mid]; A[mid] = A[mid + 1]; A[mid + 1] = t;
    }
    if (low > high) {
        for (i = n - 1; i > high; i--) A[i + 1] = A[i]; //后移元素
        A[i + 1] = x; //插入 x
    }
}
```

本题的算法也可写成三个函数：查找函数、交换后继函数与插入函数。写成三个函数的优点是逻辑清晰、易读。

# 09.【解析】

1）算法的基本设计思想。

使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围，即可停止。

2）算法的实现。

```awk
void samekey(int A[],int B[],int C[],int n){ int  $i = 0,j = 0,k = 0$  //定义三个工作指针 while(i<n&&j<n&&k<n> if(A[i] == B[j] &&B[j] == C[k]) { printf("%d\n",A[i]); i++; j++; k++; }else{ int maxNum=max(A[i],max(B[j],C[k])); if(A[i]<maxNum)i++; if(B[j]<maxNum)j++; if(C[k]<maxNum)k++; } }
```

3）每个指针移动的次数不超过  $n$  次，且每次循环至少有一个指针后移，所以时间复杂度为  $O(n)$ ，算法只用到了常数个变量，空间复杂度为  $O(1)$ 。

# 10.【解答】

1）算法的基本设计思想：

可将问题视为把数组  $ab$  转换成数组  $ba$  （ $a$  代表数组的前  $p$  个元素， $b$  代表数组中余下的  $n - p$  个元素），先将  $a$  逆置得到  $a^{-1}b$ ，再将  $b$  逆置得到  $a^{-1}b^{-1}$ ，最后将整个  $a^{-1}b^{-1}$  逆置得到  $(a^{-1}b^{-1})^{-1} = ba$ 。设 Reverse 函数执行将数组逆置的操作，对 abcdefgh 向左循环移动  $3(p = 3)$  个位置的过程如下：

Reverse(0,p-1)得到cbadefgh;

Reverse(p,n-1)得到cbahgfed;

Reverse(0,n-1)得到defghabc。

注：在 Reverse 中，两个参数分别表示数组中待转换元素的始末位置。

2）使用C语言描述算法如下：

```c
void Reverse(int R[],int from,int to){ int i, temp; for  $(\mathrm{i} = 0;\mathrm{i} <   (\mathrm{to - from + 1}) / 2;\mathrm{i}++)$  {temp  $=$  R[from+i];R[from+i]  $=$  R[to-i];R[to-i]=temp;}   
}   
void Converse(int R[],int n,int p){ Reverse(R,0,p-1); Reverse(R,p,n-1); Reverse(R,0,n-1);
```

3）上述算法中三个Reverse函数的时间复杂度分别为  $O(p / 2)$  、  $O((n - p) / 2)$  和  $O(n / 2)$  ，故所设计的算法的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$  。

【另解】借助辅助数组来实现。算法思想：创建大小为  $p$  的辅助数组  $S$  ，将  $R$  中前  $p$  个整数依次暂存在  $S$  中，同时将  $R$  中后  $n - p$  个整数左移，然后将  $S$  中暂存的  $p$  个数依次放回到  $R$  中的后续单元。时间复杂度为  $O(n)$  ，空间复杂度为  $O(p)$  。

# 11.【解答】

1）算法的基本设计思想如下。

分别求两个升序序列  $A$  、  $B$  的中位数，设为  $a$  和  $b$  ，求序列  $A$  、  $B$  的中位数过程如下：

① 若  $a = b$  ，则  $a$  或  $b$  为所求中位数，算法结束。

② 若  $a < b$  ，则舍弃序列  $A$  中较小的一半，同时舍弃序列  $B$  中较大的一半，要求两次舍弃的长度相等。

③ 若  $a > b$  ，则舍弃序列  $A$  中较大的一半，同时舍弃序列  $B$  中较小的一半，要求两次舍弃的长度相等。

在保留的两个升序序列中，重复过程①、②、③，直到两个序列中均只含一个元素时为止，较小者为所求的中位数。

2）本题代码如下：

```txt
int M_Search(int A[], int B[], int n) {
    int s1, d1, m1, s2, d2, m2;
    s1 = 0; d1 = n - 1;
    s2 = 0; d2 = n - 1;
    while (s1 != d1 || s2 != d2) {
        m1 = (s1 + d1) / 2;
        m2 = (s2 + d2) / 2;
        if (A[m1] == B[m2])
            return A[m1]; //满足条件①
        if (A[m1] < B[m2]) { //满足条件②
            if ((s1 + d1) % 2 == 0) { //若元素个数为奇数
                s1 = m1; //舍弃A中间点以前的部分，且保留中间点
                d2 = m2; //舍弃B中间点以后的部分，且保留中间点
            }
        }
}
```

```javascript
else{ //元素个数为偶数s1=m1+1; //舍弃A的前半部分d2=m2; //舍弃B的后半部分}  
}  
else{ //满足条件③if((s1+d1)%2==0){ //若元素个数为奇数d1=m1; //舍弃A中间点以后的部分，且保留中间点s2=m2; //舍弃B中间点以前的部分，且保留中间点}  
else{ //元素个数为偶数d1=m1; //舍弃A的后半部分s2=m2+1; //舍弃B的前半部分}  
}  
}  
return A[s1]<B[s2]? A[s1]:B[s2];
```

3）算法的时间复杂度为  $O(\log_2n)$ ，空间复杂度为  $O(1)$ 。

【另解】对两个长度为  $n$  的升序序列  $A$  和  $B$  中的元素按从小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为  $O(1)$  。按照上述规则访问第  $n$  个元素时，这个元素为两个序列  $A$  和  $B$  的中位数。

# 12.【解答】

1）算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确认Num是否是主元素。

算法可分为以下两步：

① 选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。

② 判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大于  $n / 2$ ，则为主元素；否则，序列中不存在主元素。

2）算法实现如下：

```c
int Majority(int A[], int n) {
    int i, c, count = 1; //c用来保存候选主元素，count用来计数
    c = A[0]; //设置A[0]为候选主元素
    for (i = 1; i < n; i++) //查找候选主元素
        if (A[i] == c)
            count++;
        else
            if (count > 0)
                count--;
        else {
            c = A[i];
            count = 1;
        }
    }
    if (count > 0)
        for (i = count + 0; i < n; i++) //统计候选主元素的实际出现次数
            if (A[i] == c)
                count++;
        if (count > n/2) return c; //确认候选主元素
```

```javascript
else return -1; //不存在主元素
```

3）实现的程序的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$  。

# 说明

本题若采用先排好序再统计的方法[时间复杂度为  $O(n\log_2n)$  ]，则只要解答正确，最高可拿11分。即便是写出  $O(n^{2})$  的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得不偿失的。本算法的方法非常典型，需牢固掌握。

# 13.【解答】

# 1）算法的基本设计思想：

要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用来记录A中是否出现了  $1\sim n$  中的正整数，B[0]对应正整数1，B[n-1]对应正整数n，初始化B中全部为0。A中含有n个整数，因此可能返回的值是  $1\sim n + 1$  ，当A中n个数恰好为  $1\sim n$  时返回 $n + 1$  。当数组A中出现了小于或等于0或大于  $\mathbf{n}$  的值时，会导致  $1\sim n$  中出现空余位置，返回结果必然在  $1\sim n$  中，因此对于A中出现了小于或等于0或大于  $\mathbf{n}$  的值，可以不采取任何操作。

经过以上分析可以得出算法流程：从A[0]开始遍历A，若  $0 < A[i] < = n$ ，则令B[A[i]-1]=1；否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i] == 0的下标i，返回i+1即为结果，此时说明A中未出现的最小正整数在1和n之间。若B[i]全部不为0，返回i+1（跳出循环时  $i = n$ ， $i + 1$  等于  $n + 1$ ），此时说明A中未出现的最小正整数是  $n + 1$ 。

# 2）算法实现：

```c
int findMissMin(int A[], int n)  
{  
    int i, *B; //标记数组  
    B = (int *)malloc(sizeof(int) *n); //分配空间  
    memset(B, 0, sizeof(int) *n); //赋初值为 0  
    for (i = 0; i < n; i++)  
        if (A[i] > 0 && A[i] <= n) //若 A[i] 的值介于 1~n，则标记数组 B  
            B[A[i] - 1] = 1;  
    for (i = 0; i < n; i++) //扫描数组 B，找到目标值  
        if (B[i] == 0) break;  
    return i + 1; //返回结果  
}
```

3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为  $O(1)$  量级，因此时间复杂度为  $O(n)$  。空间复杂度：额外分配了B[n]，空间复杂度为  $O(n)$  。

# 14.【解答】

分析。由  $D = |a - b| + |b - c| + |c - a|\geqslant 0$  有如下结论。

① 当  $a = b = c$  时，距离最小。

② 其余情况。不失一般性，假设  $a \leqslant b \leqslant c$  ，观察下面的数轴：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7dec69671da46282f4c9356f31b415c05ee4dd2dd1379eeadcc33f35dcff975f.jpg)


$$
L _ {1} = | a - b |, \quad L _ {2} = | b - c |, \quad L _ {3} = | c - a |
$$

$$
D = | a - b | + | b - c | + | c - a | \geqslant 0 = L _ {1} + L _ {2} + L _ {3} = 2 L _ {3}
$$

由  $D$  的表达式可知，事实上决定  $D$  大小的关键是  $a$  和  $c$  之间的距离，于是问题就可以简化

为每次固定  $c$  找一个  $a$  ，使得  $L_{3} = |c - a|$  最小。

1）算法的基本设计思想：

① 使用  $D_{\mathrm{min}}$  记录所有已处理的三元组的最小距离，初值为一个足够大的整数。

② 集合  $S_{1}$  、  $S_{2}$  和  $S_{3}$  分别保存在数组  $A$  、  $B$  、  $C$  中。数组的下标变量  $i = j = k = 0$  ，当  $i < |S_{1}|$  、  $j < |S_{2}|$  且  $k < |S_{3}|$  时（|S|表示集合  $S$  中的元素个数），循环执行下面的a）～c）。

a）计算  $(A[i],B[j],C[k])$  的距离  $D$  ；（计算  $D$  ）

b）若  $D <   D_{\mathrm{min}}$  ，则  $D_{\mathrm{min}} = D$  ；（更新  $D$  产

c）将  $A[i]$  、  $B[j]$  、  $C[k]$  中的最小值的下标+1；（对照分析：最小值为  $a$  ，最大值为  $c$  ，这里  $c$  不变而更新  $a$  ，试图寻找更小的距离  $D$  ）

③ 输出  $D_{\mathrm{min}}$  ，结束。

2）算法实现：

```c
define INT_MAX 0x7FFFFFF  
int abs_(int a){//计算绝对值  
if(a<0) return -a;  
else return a;  
}  
bool xls_min(int a,int b,int c){//a是否是三个数中的最小值  
if(a<=b&&a<=c) return true;  
return false;  
}  
int findMinofTrip(int A[],int n,int B[],int m,int C[],int p){//D_min用于记录三元组的最小距离，初值赋为INT_MAX  
int i=0,j=0,k=0,D_min=INT_MAX,D;  
while(i<n&&j<m&&k<p&&D_min>0){D=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[i]); //计算Dif(D<D_min) D_min=D; //更新Dif(xls_min(A[i],B[j],C[k])) i++; //更新aelse if(xls_min(B[j],C[k],A[i])) j++; else k++;  
}  
return D_min;
```

3）设  $n = (|S_1| + |S_2| + |S_3|)$  ，时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$  。

# 2.3 线性表的链式表示

顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任一元素，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“链”建立元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。

# 2.3.1 单链表的定义

命题追踪 单链表的应用（2009、2012、2013、2015、2016、2019）

线性表的链式存储也称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。单链表结点结构如图2.3所示，其中data为数据域，存放数据元素；

next 为指针域，存放其后继结点的地址。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f965252c5d5c53b305e0982f0e26db7feda33819ab5f87318ef5cd4733528354.jpg)



图2.3 单链表结点结构


单链表中结点类型的描述如下：

```txt
typedef struct LNode{ //定义单链表结点类型ElemType data; //数据域structLNode \*next; //指针域}LNode，\*LinkList;
```

利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存储空间的缺点。单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。

通常用头指针L（或head等）来标识一个单链表，指出链表的起始地址，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，头指针L指向头结点，如图2.4(a)所示。单链表不带头结点时，头指针L指向第一个数据结点，如图2.4(b)所示。表尾结点的指针域为NULL（用“^”表示）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/625160b0e4099cba959fa26fe5e32c4dfe6ba90a7629a3ed3cc4e800c2ac061f.jpg)



(a) 带表头结点的单链表


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/873de688e38dc4c4bac4b237431e6f58a5ecde4ee07a36db584e112079ebe658.jpg)



(b) 不带表头结点的单链表



图2.4 带头结点和不带头结点的单链表


头结点和头指针的关系：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。

引入头结点后，可以带来两个优点：

① 第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。

② 无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。

# 2.3.2 单链表上基本操作的实现

带头结点单链表的操作代码书写较为方便，如无特殊说明，本节均默认链表带头结点。

# 1. 单链表的初始化

带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要创建一个头结点，并让头指针指向头结点，头结点的 next 域初始化为 NULL。

```txt
bool InitList(LinkList &L){ //带头结点的单链表的初始化 $\mathrm{L} = (\mathrm{LNode}^{\star})$  malloc(sizeof(LNode)); //创建头结点① $\mathrm{L - > next = NULL}$  //头结点之后暂时还没有元素结点return true;1
```

不带头结点的单链表初始化时，只需将头指针L初始化为NULL。

```txt
bool InitList(LinkList &L) { //不带头结点的单链表的初始化
```

```javascript
L=NULL; return true;
```

# 注意

设p为指向链表结点的结构体指针，则\*p表示结点本身，因此可用  $\mathsf{p - > }$  data或  $(^{*}\mathsf{p})$  .data访问\*p这个结点的数据域，二者完全等价。成员运算符（.）左边是一个普通的结构体变量，而指向运算符（->）左边是一个结构体指针。通过  $(^{*}\mathsf{p})$  .next可以得到指向下一个结点的指针，因此  $(^{*}(*\mathsf{p}).\mathrm{next})$  .data就是下一个结点中存放的数据，或者直接用  $\mathsf{p - > }$  next->data。

# 2. 求表长操作

求表长操作是计算单链表中数据结点的个数，需要从第一个结点开始依次访问表中每个结点，为此需设置一个计数变量，每访问一个结点，其值加1，直到访问到空结点为止。

```c
intLength(LinkListL){ intlen=0; //计数变量，初始为0 LNode \*p=L; while(p->next!=NULL）{ p=p->next; len++; //每访问一个结点，计数加1 } returnlen;
```

求表长操作的时间复杂度为  $O(n)$  。另需注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。

# 3. 按序号查找结点

从单链表的第一个结点开始，沿着next域从前往后依次搜索，直到找到第i个结点为止，则返回该结点的指针；若i大于单链表的表长，则返回NULL。

```javascript
LNode \*GetElem(LinkList L,int i){ LNode  $^{\star}\mathbb{p} = \mathbb{L};$  //指针p指向当前扫描到的结点 int  $j = 0$  //记录当前结点的位序，头结点是第0个结点 while(p!=NULL&&j<i）{//循环找到第i个结点 p=p->next; j++; } return p; //返回第i个结点的指针或NULL
```

按序号查找操作的时间复杂度为  $O(n)$

# 4. 按值查找表结点

从单链表的第一个结点开始，从前往后依次比较表中各结点的数据域，若某结点的 data 域等于给定值 e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回 NULL。

```txt
LNode \*LocateElem(LinkList L,ElemType e){ LNode  $^{\star}\mathsf{p} = \mathsf{L} - >$  next; while  $(\mathsf{p}! = \mathsf{NULL}\& \& \mathsf{p} - >$  data！  $= \mathrm{e})$  //从第一个结点开始查找数据域为e的结点 p=p->next; return p; //找到后返回该结点指针，否则返回NULL }
```

按值查找操作的时间复杂度为  $O(n)$

# 5. 插入结点操作

插入结点操作将值为  $\mathbf{x}$  的新结点插入到单链表的第i个位置。先检查插入位置的合法性，然

后找到待插入位置的前驱，即第i-1个结点，再在其后插入。其操作过程如图2.5所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1f150332d0c856d400f9ebab3c1c7bf5bf458d75976b1eaf4c0205e4f6cb14e9.jpg)



图2.5 单链表的插入操作


# 命题追踪 单链表插入操作的过程（2016、2024）

首先查找第i-1个结点，假设第i-1个结点为\*p，然后令新结点\*s的指针域指向\*p的后继，再令结点\*p的指针域指向新插入的结点\*s。

```c
bool Insert(LinkList &L, int i, ElemType e) {
    LNode *p = L; //指针 p 指向当前扫描到的结点
    int j = 0; //记录当前结点的位序，头结点是第 0 个结点
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL) //i 值不合法
        return false;
    LNode *s = (LNode*) malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next; //图 2.5 中操作步骤①
    p->next = s; //图 2.5 中操作步骤②
    return true;
}
```

插入时，①和②的顺序不能颠倒，否则，先执行  $p->next = s$  后，指向其原后继的指针就不存在了，再执行  $s->next = p->next$  时，相当于执行了  $s->next = s$ ，显然有误。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为  $O(n)$  。若在指定结点后插入新结点，则时间复杂度仅为  $O(1)$  。需注意的是，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做特殊处理，将头指针L指向新的首结点。当链表带头结点时，插入位置i为1时不用做特殊处理。

扩展：对某一结点进行前插操作。

前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插入算法中，通常都采用后插操作。以上面的算法为例，先找到第i-1个结点，即插入结点的前驱，再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为  $O(n)$  。

此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为\*s，将\*s插入到\*p的前面。我们仍然将\*s插入到\*p的后面，然后将p->data与s->data交换，这样做既满足逻辑关系，又能使得时间复杂度为  $O(1)$  。该方法的主要代码片段如下：

```txt
s->next=p->next; //修改指针域，不能颠倒  
p->next=s;  
temp=p->data; //交换数据域部分  
p->data=s->data;  
s->data=temp;
```

# 6. 删除结点操作

删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱，再删除第i个结点。其操作过程如图2.6所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4d837fd628cbac4c35b51f2a65215b201315f06d548690d3166b5ef3abd32134.jpg)



图2.6 单链表结点的删除


假设结点\*p为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改\*p的指针域，将\*p的指针域next指向\*q的下一结点，然后释放\*q的存储空间。

```c
bool ListDelete(LinkList &L, int i, ElemType &e) {
    LNode *p = L; //指针 p 指向当前扫描到的结点
    int j = 0; //记录当前结点的位序，头结点是第 0 个结点
    while (p->next != NULL && j < i - 1) {
        //循环找到第 i - 1 个结点
        p = p->next;
        j++;
    }
    if (p->next == NULL || j > i - 1) //i 值不合法
        return false;
    LNode *q = p->next; //令 q 指向被删除结点
    e = q->data; //用 e 返回元素的值
    p->next = q->next; //将 *q 结点从链中“断开”
    free(q); //释放结点的存储空间①
    return true;
}
```

同插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为  $O(n)$  。当链表不带头结点时，需要判断被删结点是否为首结点，若是，则要做特殊处理，将头指针L指向新的首结点。当链表带头结点时，删除首结点和删除其他结点的操作是相同的。

扩展：删除结点\*p。

要删除某个给定结点\*p，通常的做法是先从链表的头结点开始顺序找到其前驱，然后执行删除操作。其实，删除结点\*p的操作可用删除\*p的后继来实现，实质就是将其后继的值赋予其自身，然后再删除后继，也能使得时间复杂度为  $O(1)$  。该方法的主要代码片段如下：

```html
q=p->next; //令q指向\*p的后继结点  
p->data=p->next->data; //用后继结点的数据域覆盖  
p->next=q->next; //将\*q结点从链中“断开”  
free(q); //释放后继结点的存储空间
```

# 7. 采用头插法建立单链表

该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如图2.7所示。算法实现如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6a2844df4bf1a9715a4283f70d50c7021af43b6541aadb024c64e99daffb0c3a.jpg)



图2.7 采用头插法建立单链表


```c
LinkList List_HeadInsert(LinkList &L) { //逆向建立单链表
LNode *s; int x; //设元素类型为整型
L = (LNode*) malloc(sizeof(LNode)); //创建头结点
L->next=NULL; //初始为空链表
scanf("%d", &x); //输入结点的值
while (x != 9999) { //输入 9999 表示结束
    s = (LNode*) malloc(sizeof(LNode)); //创建新结点
    s->data = x;
    s->next = L->next;
    L->next = s; //将新结点插入表中，L 为头指针
    scanf("%d", &x);
}
return L;
```

采用头插法建立单链表时，读入数据的顺序与生成的链表中元素的顺序是相反的，可用来实现链表的逆置。每个结点插入的时间为  $O(1)$ ，设单链表长为  $n$ ，则总时间复杂度为  $O(n)$ 。

# 思考

若单链表不带头结点，则上述代码中哪些地方需要修改？①

# 8. 采用尾插法建立单链表

头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针  $\mathbf{r}$ ，使其始终指向当前链表的尾结点，如图2.8所示。算法实现如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f0522e261cd21502b8164b1821d5f36746faed10816fea3bbc7d1e0bbd43dedd.jpg)



图2.8 采用尾插法建立单链表


```c
LinkList List_TailInsert(LinkList &L) { //正向建立单链表
int x; //设元素类型为整型
L = (LNode*) malloc(sizeof(LNode)); //创建头结点
LNode *s, *r = L; //r 为表尾指针
scanf("%d", &x); //输入结点的值
while (x != 9999) { //输入 9999 表示结束
    s = (LNode *) malloc(sizeof(LNode));
    s->data = x;
    r->next = s;
    r = s; //r 指向新的表尾结点
    scanf("%d", &x);
}
r->next = NULL; //尾结点指针置空
return L;
```

因为附设了一个指向表尾结点的指针，所以时间复杂度和头插法的相同。

# 注意

单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通过画图的方法理清算法的思路，然后进行算法的编写。

# 2.3.3 双链表

单链表结点中只有一个指向其后继的指针，使得单链表只能从前往后依次遍历。要访问某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为  $O(n)$  。为了克服单链表的这个缺点，引入了双链表，双链表结点中有两个指针 prior 和 next，分别指向其直接前驱和直接后继，如图 2.9 所示。表头结点的 prior 域和尾结点的 next 域都是 NULL。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/abf1fcb6cbe8bff6a15c575f0373d008b8a031b6a23253e75bca620300dfbebe.jpg)



图2.9 双链表示意图


双链表中结点类型的描述如下：

```c
typedef struct DNode{ //定义双链表结点类型ElemType data; //数据域structDNode \*prior,\*next; //前驱和后继指针}DNode，\*DLinklist;
```

双链表在单链表结点中增加了一个指向其前驱的指针 prior，因此双链表的按值查找和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对指针 prior 做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到当前结点的前驱，因此，插入、删除操作的时间复杂度仅为  $O(1)$ 。

# 1. 双链表的插入操作

在双链表中p所指的结点之后插入结点\*s，其指针的变化过程如图2.10所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/63414bb49ea2ccc0a497be5f70124cfcf9a71f707336b3bfa18da1ab41cccf87.jpg)



图2.10 双链表插入结点过程


# 命题追踪 双链表中插入操作的实现（2023）

插入操作的代码片段如下：

```txt
① s->next=p->next; //将结点\*s插入到结点\*p之后  
② p->next->prior=s;  
③ s->prior=p;  
④ p->next=s;
```

上述代码的语句顺序不是唯一的，但也不是任意的，①步必须在④步之前，否则\*p的后继结点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求在结点\*p之前插入结点\*s，请读者思考具体的操作步骤。

# 2. 双链表的删除操作

删除双链表中结点\*p的后继结点\*q，其指针的变化过程如图2.11所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/535741a426c9490d7321d1c787e9e8522f4529fc7aab7f3d3d2e63bfcaf03609.jpg)



图2.11 双链表删除结点过程


# 命题追踪 双链表中删除操作的实现（2016）

删除操作的代码片段如下：

```txt
p->next = q->next; //图2.11中步骤①  
q->next->prior = p; //图2.11中步骤②  
free(q); //释放结点空间
```

若问题改成要求删除结点  $\star q$  的前驱结点  $\star p$  ，请读者思考具体的操作步骤。

在建立双链表的操作中，也可采用如同单链表的头插法和尾插法，但在操作上需要注意指针的变化和单链表有所不同。

# 2.3.4 循环链表

# 1. 循环单链表

循环单链表和单链表的区别在于，表中最后一个结点的指针不是 NULL，而改为指向头结点，从而整个链表形成一个环，如图 2.12 所示。

在循环单链表中，表尾结点  $*r$  的 next 域指向 L，故表中没有指针域为 NULL 的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针 L。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5f3f7ddd294225f30a66daced1bdb776a8152e7c29205a5dd1d9c793557e4323.jpg)



图2.12 循环单链表


# 命题追踪 循环单链表中删除首元素的操作（2021）

循环单链表的插入、删除算法与单链表的几乎一样，所不同的是，若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，所以在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。

在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。其原因是，若设的是头指针，对在表尾插入元素需要  $O(n)$  的时间复杂度，而若设的是尾指针r，r->next即头指针，对在表头或表尾插入元素都只需要  $O(1)$  的时间复杂度。

# 2. 循环双链表

由循环单链表的定义不难推出循环双链表。不同的是，在循环双链表中，头结点的prior指针还要指向表尾结点，如图2.13所示。当某结点\*p为尾结点时，  $\mathrm{p - > next = =L}$  ；当循环双链表为空表时，其头结点的prior域和next域都等于L。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3986bff897590f7b74bfd655b94425827fec27bb9283b844bed0e2048b39acbf.jpg)



图2.13 循环双链表


# 2.3.5 静态链表

静态链表是用数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next，与前面所讲的链表中的指针不同的是，这里的指针是结点在数组中的相对地址（数组下标），也称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。

静态链表和单链表的对应关系如图2.14所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b49c28d773257265e936d9f52ec0a7258b05c6f3196c63acc2cd36a61b06e319.jpg)



(a)静态链表示例


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c848d8c70bd95ce19a9fa09995791ff0c4dd98e31b3aae5d0dbdacb7c67cf6f0.jpg)



(b)静态链表对应的单链表



图2.14 静态链表存储示意图


静态链表结构类型的描述如下：

```txt
define MaxSize 50 //静态链表的最大长度  
typedef struct{ //静态链表结构类型的定义ElemType data; //存储数据元素int next; //下一个元素的数组下标} SLinkList[MaxSize];
```

静态链表以 next==-1 作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言（如 Basic）中，这是一种非常巧妙的设计方法。

# 2.3.6 顺序表和链表的比较

# 1.存取（读/写）方式

顺序表既可以顺序存取，也可以随机存取，链表只能从表头开始依次顺序存取。例如在第  $i$  个位置上执行存取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问  $i$  次。

# 2. 逻辑结构与物理结构

采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。

# 3. 查找、插入和删除操作

对于按值查找，顺序表无序时，两者的时间复杂度均为  $O(n)$ ；顺序表有序时，可采用折半查找，此时的时间复杂度为  $O(\log_2n)$ 。对于按序号查找，顺序表支持随机访问，时间复杂度仅为  $O(1)$ ，而链表的平均时间复杂度为  $O(n)$ 。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。

# 4. 空间分配

顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。此外，链表的每个结点都带有指针域，因此存储密度不够大。

在实际中应该怎样选取存储结构呢？

# 1. 基于存储的考虑

难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。

# 2. 基于运算的考虑

在顺序表中按序号访问  $a_{i}$  的时间复杂度为  $O(1)$ ，而链表中按序号访问的时间复杂度为  $O(n)$ ，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。

在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。

# 3. 基于环境的考虑

顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。

总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（动态性较强）宜选择链式存储。

# 注意

只有熟练掌握顺序存储和链式存储，才能深刻理解它们的优缺点。

# 2.3.7 本节试题精选

# 一、单项选择题

01. 下列关于线性表的存储结构的描述中，正确的是（）。

I. 线性表的顺序存储结构优于其链式存储结构

II. 链式存储结构比顺序存储结构能更方便地表示各种逻辑结构

III. 若频繁使用插入和删除结点操作，则顺序存储结构更优于链式存储结构

IV. 顺序存储结构和链式存储结构都可以进行顺序存取

A. I、II、III

B. II、IV

C. II、III

D. III、IV

02. 对于一个线性表，既要求能进行较快速地插入和删除，又要求存储结构能反映数据之间的逻辑关系，则应该用（）。

A. 顺序存储方式

B. 链式存储方式

C. 散列存储方式

D. 以上均可以

03. 链式存储设计时，结点内的存储单元地址（）。

A. 一定连续

B. 一定不连续

C. 不一定连续

D. 部分连续，部分不连续

04. 下列关于线性表的说法中，正确的是（）。

I. 顺序存储方式只能用于存储线性结构

II. 在一个设有头指针和尾指针的单链表中，删除表尾元素的时间复杂度与表长无关

III. 带头结点的循环单链表中不存在空指针

IV. 在一个长度为  $n$  的有序单链表中插入一个新结点并仍保持有序的时间复杂度为  $O(n)$

V. 若用单链表来表示队列，则应该选用带尾指针的循环链表

A. I、II

B. I、III、IV、V

C. IV、V

D. III、IV、V

05. 设线性表中有  $2n$  个元素，（）在单链表上实现要比在顺序表上实现效率更高。

A. 删除所有值为  $x$  的元素

B. 在最后一个元素的后面插入一个新元素

C. 顺序输出前  $k$  个元素

D. 交换第  $i$  个元素和第  $2n - i - 1$  个元素的值  $(i = 0, \dots, n - 1)$

06. 在一个单链表中，已知 q 所指结点是 p 所指结点的前驱结点，若在 q 和 p 之间插入结点 s，则执行（）。

A.  $s->next = p->next; p->next = s$

B.  $p->next = s->next; s->next = p;$

C. q->next=s; s->next=p;

D. p->next=s; s->next=q;

07. 给定有  $n$  个元素的一维数组,建立一个有序单链表的最低时间复杂度是 (   )。

A.  $O(1)$

B.  $O(n)$

C.  $O(n^{2})$

D.  $O(n \log_2 n)$

08. 将长度为  $n$  的单链表链接在长度为  $m$  的单链表后面，其算法的时间复杂度采用大  $O$  形式表示应该是（）。

A.  $O(1)$

B.  $O(n)$

C.  $O(m)$

D.  $O(n + m)$

09. 单链表中，增加一个头结点的目的是（）。

A. 使单链表至少有一个结点

B. 标识表结点中首结点的位置

C. 方便运算的实现

D. 说明单链表是线性表的链式存储

10. 在一个长度为  $n$  的带头结点的单链表  $h$  上，设有尾指针  $r$  ，则执行（）操作与链表的表长有关。

A. 删除单链表中的第一个元素

B. 删除单链表中的最后一个元素

C. 在单链表第一个元素前插入一个新元素

D. 在单链表最后一个元素后插入一个新元素

11. 对于一个头指针为 head 的带头结点的单链表，判定该表为空表的条件是（）；对于不带头结点的单链表，判定空表的条件为（）。

A. head==NULL

B. head->next == NULL

C.head->next  $\equiv$  =head

D. head != NULL

12. 在线性表  $a_{0}, a_{1}, \cdots, a_{100}$  中，删除元素  $a_{50}$  需要移动（）个元素。

A. 0

B. 50

C. 51

D. 0 或 50

13. 通过含有  $n (n > 1)$  个元素的数组  $a$ ，采用头插法建立单链表  $L$ ，则  $L$  中的元素次序（）。

A. 与数组  $a$  的元素次序相同

B. 与数组  $a$  的元素次序相反

C. 与数组  $a$  的元素次序无关

D. 以上都错误

14. 下面关于线性表的一些说法中，正确的是（）。

A. 对一个设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度无关

B. 线性表中每个元素都有一个直接前驱和一个直接后继

C. 为了方便插入和删除数据, 可以使用双链表存放数据

D. 取线性表第  $i$  个元素的时间与  $i$  的大小有关

15. 在双链表中向p所指的结点之前插入一个结点q的操作为（）。

A. p->prior = q; q->next = p; p->prior->next = q; q->prior = p->prior;

B. q->prior=p->prior; p->prior->next=q; q->next=p; p->prior=q->next;

C. q->next=p; p->next=q; q->prior->next=q; q->next=p;

D. p->prior->next = q; q->next = p; q->prior = p->prior; p->prior = q;

16. 在双链表存储结构中，删除p所指的结点时必须修改指针（）。

A. p->prior->next = p->next; p->next->prior = p->prior;

B. p->prior=p->prior->prior; p->prior->next=p;

C. p->next->prior=p; p->next=p->next->next;

D.  $p->next = p->prior->prior; p->prior = p->next->next$ ;

17. 在如下图所示的双链表中，已知指针  $\mathfrak{p}$  指向结点  $A$ ，若要在结点  $A$  和  $C$  之间插入指针  $q$ ，所指的结点  $B$ ，则依次执行的语句序列可以是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/53bba8e713417b9fecc38dc4996c7aeb9bca62bd5502b790ca67e2aa94300cd7.jpg)


①q->next=p->next; ②q->prior=p; ③p->next=q; ④p->next->prior=q;

A. ①②④③

B. ④③②①

C. ③④①②

D. ①③④②

18. 在双链表的两个结点之间插入一个新结点，需要修改（）个指针域。

A. 1

B. 3

C. 4

D. 2

19. 在长度为  $n$  的有序单链表中插入一个新结点，并仍然保持有序的时间复杂度是（）。

A.  $O(1)$

B.  $O(n)$

C.  $O(n^{2})$

D.  $O\left(n \log_2 n\right)$

20. 与单链表相比，双链表的优点之一是（）。

A. 插入、删除操作更方便

B. 可以进行随机访问

C. 可以省略表头指针或表尾指针

D. 访问前后相邻结点更灵活

21. 对于一个带头结点的循环单链表 L，判断该表为空表的条件是（）。

A. 头结点的指针域为空

B. L 的值为 NULL

C. 头结点的指针域与  $\mathbb{L}$  的值相等

D. 头结点的指针域与  $\mathbb{L}$  的地址相等

22. 对于一个带头结点的循环双链表 L，判断该表为空表的条件是（）。

A. L->prior==L&&L->next==NULL

B. L->prior==NULL&&L->next==NULL

C. L->prior==NULL&&L->next==L

D. L->prior==L&&L->next==L

23. 一个链表最常用的操作是在末尾插入结点和删除结点，则选用（）最节省时间。

A. 带头结点的循环双链表

B. 循环单链表

C. 带尾指针的循环单链表

D. 单链表

24. 设对  $n (n > 1)$  个元素的线性表的运算只有 4 种：删除第一个元素；删除最后一个元素；在第一个元素之前插入新元素；在最后一个元素之后插入新元素，则最好使用（）。

A. 只有尾结点指针没有头结点指针的循环单链表

B. 只有尾结点指针没有头结点指针的非循环双链表

C. 只有头结点指针没有尾结点指针的循环双链表

D. 既有头结点指针又有尾结点指针的循环单链表

25. 设有两个长度为  $n$  的循环单链表，若要求两个循环单链表的头尾相接的时间复杂度为  $O(1)$ ，则对应两个循环单链表各设置一个指针，分别指向（）。

A. 各自的头结点

B. 各自的尾结点

C. 各自的首结点

D. 一个表的头结点，另一个表的尾结点

26. 设有一个长度为  $n$  的循环单链表，若从表中删除首元结点的时间复杂度达到  $O(n)$ ，则此时采用的循环单链表的结构可能是（）。

A. 只有表头指针, 没有头结点

B. 只有表尾指针, 没有头结点

C. 只有表尾指针, 带头结点

D. 只有表头指针, 带头结点

27. 某线性表用带头结点的循环单链表存储，头指针为 head，当 head->next->next == head 成立时，线性表的长度可能是（）。

A. 0

B. 1

C. 2

D. 可能为 0 或 1

28. 有两个长度都为  $n$  的双链表，若以  $h_1$  为头指针的双链表是非循环的，以  $h_2$  为头指针的双链表是循环的，则下列叙述中正确的是（）。

A. 对于双链表  $h_1$  ，删除首结点的时间复杂度是  $O(n)$

B. 对于双链表  $h_2$  ，删除首结点的时间复杂度是  $O(n)$

C. 对于双链表  $h_1$ ，删除尾结点的时间复杂度是  $O(1)$

D. 对于双链表  $h_2$  ，删除尾结点的时间复杂度是  $O(1)$

29. 一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用（）最节省时间。

A. 不带头结点的循环单链表

B. 双链表

C. 单链表

D. 不带头结点且有尾指针的循环单链表

30. 需要分配较大空间，插入和删除不需要移动元素的线性表，其存储结构为（）。

A. 单链表

B. 静态链表

C. 顺序表

D. 双链表

31. 下列关于静态链表的说法中，正确的是（）。

I. 静态链表兼具顺序表和单链表的优点，因此存取表中第  $i$  个元素的时间与  $i$  无关

II. 静态链表能容纳的最大元素个数在表定义时就确定了，以后不能增加

III. 静态链表与动态链表在元素的插入、删除上类似，不需要移动元素

IV. 相比动态链表，静态链表可能浪费较多的存储空间

A. I、II、III

B. II、III、IV

C. I、III、IV

D. I、II、IV

32.【2016统考真题】已知一个带有表头结点的循环双链表L，结点结构为prev data next其中prev和next分别是指向其直接前驱和直接后继结点的指针。现要删除指针p所指的结点，正确的语句序列是（）。

A.  $p->next->prev = p->prev; p->prev->next = p->prev; free(p);$

B.  $p->next->prev = p->next; p->prev->next = p->next; free(p);$

C.  $p->next->prev = p->next$ ;  $p->prev->next = p->prev$ ; free(p);

D.  $p->next->prev = p->prev; p->prev->next = p->next; free(p);$

33.【2016统考真题】已知表头元素为c的单链表在内存中的存储状态如下表所示。

<table><tr><td>地址</td><td>元素</td><td>链接地址</td></tr><tr><td>1000H</td><td>a</td><td>1010H</td></tr><tr><td>1004H</td><td>b</td><td>100CH</td></tr><tr><td>1008H</td><td>c</td><td>1000H</td></tr><tr><td>100CH</td><td>d</td><td>NULL</td></tr><tr><td>1010H</td><td>e</td><td>1004H</td></tr><tr><td>1014H</td><td></td><td></td></tr></table>

现将f存放于1014H处并插入单链表，若f在逻辑上位于a和e之间，则a、e、f的“链接地址”依次是（）。

A.  $1010\mathrm{H}$  、  $1014\mathrm{H}$  、  $1004\mathrm{H}$

B.  $1010\mathrm{H}$  、  $1004\mathrm{H}$  、  $1014\mathrm{H}$

C.  $1014 \mathrm{H} 、 1010 \mathrm{H} 、 1004 \mathrm{H}$

D.  $1014 \mathrm{H} 、 1004 \mathrm{H} 、 1010 \mathrm{H}$

34.【2021统考真题】已知头指针h指向一个带头结点的非空循环单链表，结点结构为data next，其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是（）。

A.  $h->next=h->next->next;q=h->next;free(q)$

B.  $q = h->next; h->next = h->next->next; free(q)$ ;

C.  $q = h - > next; h - > next = q - > next$ ; if  $(p! = q)$ $p = h$ ; free(q);

D.  $q = h - > next;h - > next = q - > next$  ;if  $(p == q)$  p=h;free(q);

35.【2023统考真题】现有非空双链表L，其结点结构为prev data next，prev是指向直接前驱结点的指针，next是指向直接后继结点的指针。若要在L中指针p所指向的结点（非尾结点）之后插入指针s指向的新结点，则在执行语句序列“s->next = p->next; p->next = s”后，下列语句序列中还需要执行的是（）。

A. s->next->prev=p; s->prev=p;

B. p->next->prev=s; s->prev=p;

C. s->prev=s->next->prev; s->next->prev=s;

D.  $p->next->prev = s->prev$ ;  $s->next->prev = p$

36.【2024统考真题】已知带头结点的非空单链表L的头指针为h，结点结构为data next，其中next是指向直接后继结点的指针。现有指针p和q，若p指向L中非首且非尾的任意一个结点，则执行语句序列“q=p->next；p->next=q->next；q->next=h->next；h->next=q；”的结果是（）。

A. 在  $\mathrm{p}$  所指结点后插入  $\mathrm{q}$  所指结点

B. 在  $q$  所指结点后插入  $p$  所指结点

C. 将  $p$  所指结点移至  $L$  的头结点之后

D. 将  $q$  所指结点移动到  $L$  的头结点之后

# 二、综合应用题

01. 在带头结点的单链表 L 中，删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法以实现上述操作。

02. 试编写在带头结点的单链表 L 中删除一个最小值结点的高效算法（假设该结点唯一）。

03. 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为  $O(1)$ 。

04. 设在一个带表头结点的单链表中，所有结点的元素值无序，试编写一个函数，删除表中所有处于给定的两个值（作为函数参数给出）之间的元素（若存在）。

05. 给定两个单链表，试分析找出两个链表的公共结点的思想（不用写代码）。

06. 设  $C = \{a_{1}, b_{1}, a_{2}, b_{2}, \dots, a_{n}, b_{n}\}$  为线性表，采用带头结点的单链表存放，设计一个就地算法，将其拆分为两个线性表，使得  $A = \{a_{1}, a_{2}, \dots, a_{n}\}$ ， $B = \{b_{n}, \dots, b_{2}, b_{1}\}$ 。

07. 在一个递增有序的单链表中，存在重复的元素。设计算法删除重复的元素，例如 (7, 10, 10, 21, 30, 42, 42, 42, 51, 70) 将变为 (7, 10, 21, 30, 42, 51, 70)。

08. 设  $A$  和  $B$  是两个单链表（带头结点），其中元素递增有序。设计一个算法从  $A$  和  $B$  中的公共元素产生单链表  $C$ ，要求不破坏  $A$ 、 $B$  的结点。

09. 已知两个链表  $A$  和  $B$  分别表示两个集合，其元素递增排列。编制函数，求  $A$  与  $B$  的交集，并存放于  $A$  链表中。

10. 两个整数序列  $A = a_{1}, a_{2}, a_{3}, \dots, a_{m}$  和  $B = b_{1}, b_{2}, b_{3}, \dots, b_{n}$  已经存入两个单链表中，设计一个算法，判断序列  $B$  是否是序列  $A$  的连续子序列。

11. 设计一个算法用于判断带头结点的循环双链表是否对称。

12. 有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。

13. 设有一个带头结点的非循环双链表 L，其每个结点中除有 pre、data 和 next 域外，还有一个访问频度域 freq，其值均初始化为零。每当在链表中进行一次 Locate(L,x) 运算时，令值为 x 的结点中 freq 域的值增 1，并使此链表中的结点保持按访问频度递减的顺序排列，且最近访问的结点排在频度相同的结点之前，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的 Locate(L,x) 函数，返回找到结点的地址，类型为指针型。

14. 设将  $n (n > 1)$  个整数存放到不带头结点的单链表  $L$  中，设计算法将  $L$  中保存的序列循环右移  $k (0 < k < n)$  个位置。例如，若  $k = 1$ ，则将链表  $\{0, 1, 2, 3\}$  变为  $\{3, 0, 1, 2\}$  。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

15. 单链表有环，是指单链表的最后一个结点的指针指向了链表中的某个结点（通常单链表的最后一个结点的指针域是空的）。试编写算法判断单链表是否存在环。

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

16. 设有一个长度  $n$  （  $n$  为偶数）的不带头结点的单链表，且结点值都大于0，设计算法求这个单链表的最大孪生和。孪生和定义为一个结点值与其孪生结点值之和，对于第  $i$  个结点（从0开始），其孪生结点为第  $n - i - 1$  个结点。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你的算法的时间复杂度和空间复杂度。

17.【2009统考真题】已知一个带有表头结点的单链表，结点结构为

data

假设该链表只给出了头指针 list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第  $k$  个位置上的结点（ $k$  为正整数）。若查找成功，算法输出该结点的 data 域的值，并返回 1；否则，只返回 0。要求：

1）描述算法的基本设计思想。

2）描述算法的详细实现步骤。

3）根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言实现），关键之处请给出简要注释。

18.【2012统考真题】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如，loading和being的存储映像如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5a6fddeaf9236fc6fcf82048241cb1102893dd45c4a47964c22cfbab6c426f2c.jpg)


设 str1 和 str2 分别指向两个单词所在单链表的头结点，链表结点结构为 data next，请设计一个时间上尽可能高效的算法，找出由 str1 和 str2 所指向两个链表共同后缀的起始位置（如图中字符 i 所在结点的位置 p）。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  或Java语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度。

19.【2015统考真题】用单链表保存  $m$  个整数，结点的结构为[data][link]，且|data|  $\leqslant$ $n$  （ $n$  为正整数）。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/066c15cfde40a6e5eb8baa253eed47467936c65ff68b08d2c776d3525d315110.jpg)


则删除结点后的head为

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/daa7261310d9a1e4eec8d9c6c6de0801a60c2e8933727ca6d7a9dcfa3abcd926.jpg)


要求：

1）给出算法的基本设计思想。

2）使用C或  $\mathrm{C + + }$  语言，给出单链表结点的数据类型定义。

3）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

4）说明你所设计算法的时间复杂度和空间复杂度。

20.【2019统考真题】设线性表  $L = (a_{1},a_{2},a_{3},\dots ,a_{n - 2},a_{n - 1},a_{n})$  采用带头结点的单链表保存，链表中的结点定义如下：

```c
typedef struct node { int data; struct node\*next; }NODE;
```

请设计一个空间复杂度为  $O(1)$  且时间上尽可能高效的算法，重新排列  $L$  中的各结点，得到线性表  $L^{\prime} = (a_{1},a_{n},a_{2},a_{n - 1},a_{3},a_{n - 2},\dots)$  。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计的算法的时间复杂度。

# 2.3.8 答案与解析

# 一、单项选择题

01. B

两种存储结构适用于不同的场合，不能简单地说谁好谁坏，选项I错误。链式存储用指针表

示逻辑结构，而指针的设置是任意的，因此比顺序存储结构能更方便地表示各种逻辑结构，选项II正确。在顺序存储中，插入和删除结点需要移动大量元素，效率较低，选项III的描述刚好相反。顺序存储结构既能随机存取又能顺序存取，而链式结构只能顺序存取，选项IV正确。

# 02. B

首先直接排除选项A和D。散列存储通过散列函数映射到物理空间，不能反映数据之间的逻辑关系，排除选项C。链式存储能方便地表示各种逻辑关系，且插入和删除操作的时间复杂度为  $O(1)$

# 03. A

链式存储设计时，各个不同结点的存储空间可以不连续，但结点内的存储单元地址必须连续。

# 04. D

顺序存储方式同样适用于存储图和树，选项I错误。删除表尾结点时，必须从头开始找到表尾结点的前驱，其时间与表长有关，选项II错误。循环单链表中最后一个结点的指针不是NULL，而是指向头结点，整个链表形成一个环，因此不存在空指针，选项III正确。有序单链表只能依次查找插入位置，时间复杂度为  $O(n)$ ，选项IV正确。队列需要在表头删除元素，表尾插入元素，采用带尾指针的循环链表较为方便，插入和删除的时间复杂度都为  $O(1)$ ，选项V正确。

# 05. A

对于选项A，在单链表和顺序表上实现的时间复杂度都为  $O(n)$ ，但后者要移动很多元素，因此在单链表上实现效率更高。对于选项B和D，顺序表的效率更高。C无区别。

# 06.C

s插入后，q成为s的前驱，而p成为s的后继，选择选项C。

# 注意

可能有读者认为选项C中的两条语句交换后才正确。实际上，因为本题插入位置的前后结点都有指针指示（这与前面介绍的插入操作是不同的），所以选项C中的语句顺序并不会造成断链。在此提醒读者在学习过程中一定要多动脑思考，而不要生搬硬套。

# 07. D

若先建立链表，然后依次插入建立有序表，则每插入一个元素就需遍历链表寻找插入位置，即直接插入排序，时间复杂度为  $O(n^{2})$  。若先将数组排好序，然后建立链表，建立链表的时间复杂度为 $O(n)$  ，数组排序的最好时间复杂度为  $O(n\log_2n)$  ，总时间复杂度为  $O(n\log_2n)$  。故选择选项D。

# 08. C

先遍历长度为  $m$  的单链表，找到该单链表的尾结点，然后将其 next 域指向另一个单链表的首结点，其时间复杂度为  $O(m)$ 。

# 09. C

单链表设置头结点的目的是方便运算的实现，主要好处体现在：第一，有头结点后，插入和删除数据元素的算法就统一了，不再需要判断是否在第一个元素之前插入或删除第一个元素；第二，不论链表是否为空，其头指针是指向头结点的非空指针，链表的头指针不变，因此空表和非空表的处理也就统一了。

# 10. B

删除单链表的最后一个结点需置其前驱结点的指针域为NULL，需要从头开始依次遍历找到该前驱结点，需要  $O(n)$  的时间，与表长有关。其他操作均与表长无关，读者可自行模拟。

# 11. B, A

在带头结点的单链表中，头指针head指向头结点，头结点的next域指向第一个元素结点，head->next  $= =$  NULL表示该单链表为空。在不带头结点的单链表中，head直接指向第一个元

素结点，head  $= =$  NULL表示该单链表为空。

# 12. D

线性表有顺序存储和链式存储两种存储结构。若采用链式存储结构，则删除元素  $a_{50}$  不需要移动元素；若采用顺序存储结构，则需要依次移动50个元素。

# 13. B

当采用头插法建立单链表时，数组后面的元素插入到单链表  $L$  的最前端，所以  $L$  中的元素次序与数组  $a$  的元素次序相反。

# 14.C

选项A显然错误。选项B中第一个元素和最后一个元素不满足题设要求。双链表能很方便地访问前驱和后继，故删除和插入数据较为方便，选项C正确。选项D未考虑顺序存储的情况。

# 15. D

为了在  $p$  之前插入结点  $q$ ，可以将  $p$  的前一个结点的 next 域指向  $q$ ，将  $q$  的 next 域指向  $p$ ，将  $q$  的 prior 域指向  $p$  的前一个结点，将  $p$  的 prior 域指向  $q$ 。仅 D 满足条件。

# 16. A

与上一题的分析基本类似，只不过这里是删除一个结点，注意将  $\mathfrak{p}$  的前、后两结点链接起来。关键是要保证在结点指针的修改过程中不断链！

注意，请读者仔细对比上述两题，弄清双链表的插入和删除方法。

# 17. A

结点  $A$  和  $B$  分别由指针  $\mathfrak{p}$  和  $\mathbf{q}$  指示，但结点  $C$  仅能由  $\mathrm{p - > next}$  间接指示，因此在改变  $\mathrm{p - > next}$  之前，必须先将  $\mathrm{q - > next}$  指向结点  $C$  ，即①要在③前面，且④要在③前面（因为若先执行③，则④相当于  $\mathrm{q - > prior}$  指向其自身，显然矛盾）。故只能选择选项A。

# 18. C

当在双链表的两个结点（分别用第一个、第二个结点表示）之间插入一个新结点时，需要修改四个指针域，分别是：新结点的前驱指针域，指向第一个结点；新结点的后继指针域，指向第二个结点；第一个结点的后继指针域，指向新结点；第二个结点的前驱指针域，指向新结点。

# 19. B

设单链表递增有序，首先要在单链表中找到第一个大于  $x$  的结点的直接前驱  $p$ ，在  $p$  之后插入该结点。查找的时间复杂度为  $O(n)$ ，插入的时间复杂度为  $O(1)$ ，总时间复杂度为  $O(n)$ 。

# 20. D

在插入和删除操作上，单链表和双链表都不用移动元素，都很方便，但双链表修改指针的操作更为复杂，选项A错误。双链表中可以快速访问任何一个结点的前驱和后继结点，选项D正确。

# 21. C

带头结点的循环单链表 L 为空表时，满足  $\mathrm{L}->\mathrm{next} == \mathrm{L}$ ，即头结点的指针域与 L 的值相等，而不是头结点的指针域与 L 的地址相等。注意，带头结点的循环单链表中不存在空指针。

# 22. D

循环双链表L判空的条件是头结点（头指针）的prior和next域都指向它自身。

# 23. A

在链表的末尾插入和删除一个结点时，需要修改其相邻结点的指针域。而寻找尾结点及尾结点的前驱结点时，只有带头结点的循环双链表所需要的时间最少。

# 24. C

对于选项A，删除尾结点\*p时，需要找到\*p的前一个结点，时间复杂度为  $O(n)$  。对于选项B，删除首结点\*p时，需要找到\*p结点，这里没有直接给出头结点指针，而通过尾结点的prior

指针找到\*p结点的时间复杂度为  $O(n)$  。对于选项D，删除尾结点\*p时，需要找到\*p的前一个结点，时间复杂度为  $O(n)$  。对于C，执行这四种算法的时间复杂度均为  $O(1)$  。

# 25. B

要求用  $O(1)$  的时间将两个循环单链表头尾相接，并未指明哪个链表接在另一个链表之后，所以对两个链表都要在  $O(1)$  的时间找到头结点和尾结点。因此，两个指针应都指向尾结点。

# 26. A

在循环单链表中，删除首元结点后，要保持链表的循环性，因此需要找到首元结点的前驱。当链表带头结点时，其前驱就是头结点，因此不论是表头指针还是表尾指针，删除首元结点的时间都为  $O(1)$  。当链表不带头结点时，其前驱是尾结点，因此，若有表尾指针，就可在  $O(1)$  的时间找到尾结点；若只有表头指针，则需要遍历整个链表找到尾结点，时间为  $O(n)$  。

# 27. D

对一个空循环单链表，有head->next==head，推理head->next->next==head->next==head。对含有一个元素的循环单链表，头结点（头指针head指示）的next域指向这个唯一的元素结点，该元素结点的next域指向头结点，因此也有head->next->next=head。

# 28. D

对于两种双链表，删除首结点的时间复杂度都是  $O(1)$  。对于非循环双链表，删除尾结点的时间复杂度是  $O(n)$  ；对于循环双链表，删除尾结点的时间复杂度是  $O(1)$  。

# 29. D

对于选项A，在最后一个元素之后插入元素的情况与普通单链表相同，时间复杂度为  $O(n)$  ；而删除第一个元素时，为保持循环单链表的性质（尾结点指向第一个结点)，要先遍历整个链表找到尾结点，再做删除操作，时间复杂度为  $O(n)$  。对于选项B，双链表的情况与单链表的相同，一个是  $O(n)$  ，一个是  $O(1)$  。对于选项C，在最后一个元素之后插入一个元素，要遍历整个链表才能找到插入位置，时间复杂度为  $O(n)$  ；删除第一个元素的时间复杂度为  $O(1)$  。对于选项D，与选项A的分析对比，有尾结点的指针，省去了遍历链表的过程，因此时间复杂度均为  $O(1)$  。

# 30. B

静态链表采用数组表示，因此需要预先分配较大的连续空间，静态链表同时还具有一般链表的特点，即插入和删除不需要移动元素。

# 31. B

静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然需要按链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已确定。并非每个空间都存储了元素，因此会造成存储空间的浪费。

# 32. D

选项A的第二句代码，相当于将p前驱结点的后继指针指向其自身，错误；选项B和C的第一句代码，相当于将p后继结点的前驱指针指向其自身，错误。只有选项D正确。

# 33. D

根据存储状态，单链表的结构如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a1605be8e682bee5f759067ea3d484b361ed9d332a8c6ae7e2ac7ba192d18f92.jpg)


其中“链接地址”是指结点next所指的内存地址。当结点f插入后，a指向f，f指向e，e指向b。显然a、e和f的“链接地址”分别是f、b和e的内存地址，即1014H、1004H和  $1010\mathrm{H}_{\circ}$

# 34. D

如图1所示，要删除带头结点的非空循环单链表中的第一个元素，就要先用临时指针q指向待删结点，  $q = h->next$  ；然后将q从链表中断开，  $h->next = q->next$  （这一步也可写成  $h->next = h->next->next$  ）；此时要考虑一种特殊情况，若待删结点是链表的尾结点，即循环单链表中只有一个元素(p和q指向同一个结点)，如图2所示，则在删除后要将尾指针指向头结点，即if  $(p == q)$ $p = h$  ；最后释放q结点即可，答案选择选项D。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6f8ff5cd5f595e08f0963876c476967fa9b1a99aec2e1fb0d66d48deb89e39f7.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1b4e7a8ee03443f1567035fd4f3ba656fa91909c4308aa3c85e76ca50ec0ba30.jpg)



图2


# 35. C

链表的插入操作要保证不会造成断链，画图再依次判断选项。执行完语句“①s->next=p->next；②p->next=s；”后的结构如下图所示（虚线表示prev，实线表示next）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b586d202d8f8e0fc28d0b1c39d9ff2378aecf50b771bcc3c5c8e1fce0d54fdda.jpg)


对于选项A，s->next->prev=p，错误。对于选项B，p->next->prev=s，让s的prev指向s，错误。对于选项D，两句代码均错误。对于选项C，执行完语句“③s->prev=s->next->prev；④s->next->prev=s；”后的结构如下图所示，满足插入的要求。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9685948f6f24f0439556db8458da52b7b5de2842452d78e83f7375de9a310cf9.jpg)


# 36. D

假设单链表 L 的初始状态如图①所示。执行  $q = p->next$  后的状态如图②所示，q 指向 p 的后继结点。执行  $p->next = q->next$  后的状态如图③所示，结点 p 的 next 指向 q 的后继结点。执行  $q->next = h->next$  后的状态如图④所示，结点 q 的 next 指向 h 的后继结点。执行  $h->next = q$  后的状态如图⑤所示，q 所指结点移至 L 的头结点 h 之后，选项 D 正确。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/430a531a7e2b7d1223111d1387a347ff8f7a6a7dfa75e8ad60f0787391eb970b.jpg)



①初始状态


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/45cc166f5ae4e377ad3f9c0b0a13bb86efd22024c3b9342371f51dfd7114a68a.jpg)



③执行  $p->next = q->next$  后



④执行q->next=h->next后



⑤执行h->next=q后


# 二、综合应用题

# 01.【解答】

解法1：用p从头至尾扫描单链表，pre指向\*p结点的前驱。若p所指结点的值为x，则删除，并让p移向下一个结点，否则让pre、p指针同步后移一个结点。

本题代码如下：

```c
void Del_X_1(Linklist &L, ElemType x) {
    LNode *p = L->next, *pre = L, *q; //置 p 和 pre 的初始值
    while (p != NULL) {
        if (p->data == x) {
            q = p; //q 指向被删结点
            p = p->next;
            pre->next = p; //将 *q 结点从链表中断开
            free(q); //释放 *q 结点的空间
        }
    else {
        pre = p;
        p = p->next;
    } //else
} //while
```

本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为  $x$  。实际上，这个条件是可以任意指定的，只要修改 if 条件即可。比如，我们要求删除值介于 mink 和 maxk 之间的所有结点，则只需将 if 语句修改为 if(p->data > mink && p->data < maxk)。

解法2：采用尾插法建立单链表。用p指针扫描L的所有结点，当其值不为x时，将其链接到L之后，否则将其释放。

本题代码如下：

```txt
void Del_X_2(Linklist &L,ElemType x){ LNode \*p=L->next,\*r=L,\*q; //r指向尾结点，其初值为头结点 while(p!=NULL){ if(p->data!=x){ //\*p结点值不为x时将其链接到L尾部 r->next=p; r=p; p=p->next; //继续扫描 } else{ //\*p结点值为  $\mathbf{x}$  时将其释放 q=p; p=p->next; //继续扫描 free(q); //释放空间 } }//while r->next=NULL; //插入结束后置尾结点指针为NULL
```

上述两个算法扫描一遍链表，时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$  。

# 02.【解答】

算法思想：用  $p$  从头至尾扫描单链表，pre 指向  $*p$  结点的前驱，用 minp 保存值最小的结点指针（初值为  $p$ ），minpre 指向  $*minp$  结点的前驱（初值为 pre）。一边扫描，一边比较，若  $p->data$  小于  $minp->data$ ，则将  $p$ 、pre 分别赋值给 minp、minpre，如下图所示。当  $p$  扫描完毕时，minp 指向最小值结点，minpre 指向最小值结点的前驱结点，再将 minp 所指结点删除即可。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fc672068ec6a72ba79b61c9c2ef6316971f3a3c0171d7aa867b16a8301364b2e.jpg)


本题代码如下：

```c
LinkList Delete_Min(LinkList &L) { LNode \*pre  $=$  L,\*p=pre->next; //p为工作指针，pre指向其前驱 LNode \*minpre=pre,\*minp=p; //保存最小值结点及其前驱 while(p!=NULL){ if(p->data<data->data){ minp=p; //找到比之前找到的最小值结点更小的结点 minpre=pre; } pre=p; //继续扫描下一个结点 p=p->next; 1 minpre->next=minp->next; //删除最小值结点 free(minp); return L;
```

算法需要从头至尾扫描链表，时间复杂度为  $O(n)$ ，空间复杂度为  $O(1)$ 。

若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。

# 03.【解答】

解法1：将头结点摘下，然后从第一结点开始，依次插入到头结点的后面（头插法建立单链表），直到最后一个结点为止，这样就实现了链表的逆置，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/32189e91c8abfb61e8cc6e5ef383ba5fe6bfbdaf9958d01fd8187d46981115e8.jpg)


本题代码如下：

```javascript
LinkList Reverse_1(LinkList L){LNode \*p，\*r; //p为工作指针，r为p的后继，以防断链p=L->next; //从第一个元素结点开始L->next=NULL; //先将头结点L的next域置为NULLwhile(p!=NULL）{ //依次将元素结点摘下r=p->next; //暂存p的后继p->next  $=$  L->next; //将p结点插入到头结点之后L->next=p; p=r; }return L;
```

解法2：大部分辅导书都只介绍解法1，这对读者的理解和思维是不利的。为了将调整指针这个复杂的过程分析清楚，我们借助图形来进行直观的分析。

假设pre、p和r指向三个相邻的结点，如下图所示。假设经过若干操作后，*pre之前的结点的指针都已调整完毕，它们的next都指向其原前驱结点。现在令\*p结点的next域指向\*pre结点，注意到一旦调整指针的指向，\*p的后继结点的链就会断开，为此需要用r来指向原\*p的后继结点。处理时需要注意两点：一是在处理第一个结点时，应将其next域置为NULL，而不是指向头结点（因为它将作为新表的尾结点）；二是在处理完最后一个结点后，需要将头结点的指针指向它。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d59841d2cb4b9fdf842c7139a56fd770bac14f36ea9bbb7cf97d3f03d7730528.jpg)


本题代码如下：

```javascript
LinkList Reverse_2(LinkList L){LNode \*pre,\*p=L->next,\*r=p->next;p->next=NULL; //处理第一个结点while(r!=NULL){//r为空，则说明p为最后一个结点pre=p; //依次继续遍历p=r;r=r->next;p->next=pre; //指针反转}L->next=p; //处理最后一个结点return L;
```

上述两个算法的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$

# 04.【解答】

因为链表是无序的，所以只能逐个结点进行检查，执行删除。

本题代码如下：

```txt
void RangeDelete(LinkList &L, int min, int max) {
    LNode *pr = L, *p = L->link; //p是检测指针，pr是其前驱
    while (p != NULL)
        if (p->data > min && p->data < max) { //寻找到被删结点，删除
            pr->link = p->link;
            free(p);
            p = pr->link;
        }
    else {
        pr = p;
        p = p->link;
    }
}
```

# 05.【解答】

两个单链表有公共结点，即两个链表从某一结点开始，它们的 next 都指向同一结点。每个单链表结点只有一个 next 域，因此从第一个公共结点开始，之后的所有结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像 Y，而不可能像 X。

本题极容易联想到“蛮”方法：在第一个链表上顺序遍历每个结点，每遍历一个结点，在第二个链表上顺序遍历所有结点，若找到两个相同的结点，则找到了它们的公共结点。显然，该算法的时间复杂度为  $O(\mathrm{len}1 \times \mathrm{len}2)$ 。

接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化：如何判断两个单链表有没有公共结点？应注意到这样一个事实：若两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分时，只需要分别遍历两个链表到最后一个结点。若两个尾结点是一样的，则说明它们有公共结点，否则两个链表没有公共结点。

然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个长  $k$  个结点，我们先在长的链表上遍历  $k$  个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。两个链表

从第一个公共结点开始到链表的尾结点，这一部分是重合的，因此它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。

根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为  $O(\mathrm{len}1 + \mathrm{len}2)$

# 06.【解答】

算法思想：循环遍历链表C，采用尾插法将一个结点插入表A，这个结点为奇数号结点，这样建立的表A与原来的结点顺序相同；采用头插法将下一结点插入表B，这个结点为偶数号结点，这样建立的表B与原来的结点顺序正好相反。

本题代码如下：

```javascript
LinkList DisCreat_2(LinkList &A) { LinkList B=(LinkList)malloc(sizeof(LNode));//创建B表表头 B->next=NULL; //B表的初始化 LNode \*p=A->next,\*q; //p为工作指针 LNode \*ra=A; //ra始终指向A的尾结点 while(p!=NULL){ ra->next=p; ra=p; //将\*p链到A的表尾 p=p->next; if(p!=NULL){ q=p->next; //头插后，\*p将断链，因此用q记忆\*p的后继 p->next=B->next; //将\*p插入到B的前端 B->next=p; p=q; } } ra->next=NULL; //A尾结点的 next 域置空 return B;
```

该算法特别需要注意的是，采用头插法插入结点后，\*p的指针域已改变，若不设变量保存其后继结点，则会引起断链，从而导致算法出错。

# 07.【解答】

算法思想：题中链表是有序表，因此所有相同值域的结点都是相邻的。用  $p$  扫描递增单链表  $L$ ，若  $*p$  结点的值域等于其后继结点的值域，则删除后者，否则  $p$  移向下一个结点。

本题代码如下：

```c
void Del_Same(LinkList &L){ LNode \*p=L->next,\*q; //p为扫描工作指针 if(p==NULL) return; while (p->next!=NULL){ q=p->next; //q指向\*p的后继结点 if(p->data==q->data){ //找到重复值的结点 p->next=q->next; //释放\*q结点 free(q); //释放相同元素值的结点 } else p=p->next; 1
```

本算法的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$

本题也可采用尾插法，将头结点摘下，然后从第一结点开始，依次与已经插入结点的链表的

最后一个结点比较，若不等则直接插入，否则将当前遍历的结点删除并处理下一个结点，直到最后一个结点为止。

# 08.【解答】

算法思想：表A、B都有序，可从第一个元素起依次比较A、B两表的元素，若元素值不等，则值小的指针往后移，若元素值相等，则创建一个值等于两结点的元素值的新结点，使用尾插法插入到新的链表中，并将两个原表指针后移一位，直到其中一个链表遍历到表尾。

本题代码如下：

```txt
voidGet_Common(LinkListA,LinkListB){LNode \*p=A->next,\*q=B->next,\*r,\*s;LinkListC=(LinkList)malloc(sizeof(LNode));//建立表Cr=C; //r始终指向C的尾结点while(p!=NULL&&q!=NULL){//循环跳出条件if(p->data  $<  q - >$  data)p=p->next; //若A的当前元素较小，后移指针else if(p->data>q->data)q=q->next; //若B的当前元素较小，后移指针else{ //找到公共元素结点s=(LNode\*)malloc(sizeof(LNode));s->data=p->data; //复制产生结点\*sr->next=s; //将\*s链接到C上（尾插法）r=s;r=p->next; //表A和B继续向后扫描q=q->next;1}1r->next=NULL; //置C尾结点指针为空
```

# 09.【解答】

算法思想：采用归并的思想，设置两个工作指针pa和pb，对两个链表进行归并扫描，只有同时出现在两集合中的元素才链接到结果表中且仅保留一个，其他的结点全部释放。当一个链表遍历完毕后，释放另一个表中剩下的全部结点。

本题代码如下：

```txt
LinkList Union(LinkList &la, LinkList &lb) {
    LNode *pa = la->next; //设工作指针分别为 pa 和 pb
    LNode *pb = lb->next;
    LNode *u, *pc = la; //结果表中当前合并结点的前驱指针 pc
    while (pa && pb) {
        if (pa->data == pb->data) { //交集并入结果表中
            pc->next = pa; //A 中结点链接到结果表
            pc = pa;
            pa = pa->next;
            u = pb; //B 中结点释放
            pb = pb->next;
            free(u);
        }
    else if (pa->data < pb->data) { //若 A 中当前结点值小于 B 中当前结点值
            u = pa;
            pa = pa->next; //后移指针
            free(u); //释放 A 中当前结点
        }
    else {
        u = pb;
    }
}
```

```c
pb=pb->next; //后移指针  
free(u); //释放B中当前结点  
}  
} //while 结束  
while (pa) { //B已遍历完，A未完  
u=pa;  
pa=pa->next;  
free(u); //释放A中剩余结点  
}  
while (pb) { //A已遍历完，B未完  
u=pb;  
pb=pb->next;  
free(u); //释放B中剩余结点  
}  
pc->next=NULL; //置结果链表尾指针为NULL  
free(lb); //释放B表的头结点  
return la;
```

链表归并类型的试题在各学校历年真题中出现的频率很高，故应扎实掌握解决此类问题的思想。该算法的时间复杂度为  $O(\mathrm{len}1 + \mathrm{len}2)$ ，空间复杂度为  $O(1)$ 。

# 10.【解答】

算法思想：因为两个整数序列已存入两个链表中，操作从两个链表的第一个结点开始，若对应数据相等，则后移指针；若对应数据不等，则A链表从上次开始比较结点的后继开始，B链表仍从第一个结点开始比较，直到B链表到尾表示匹配成功。A链表到尾而B链表未到尾表示失败。操作中应记住A链表每次的开始结点，以便下次匹配时好从其后继开始。

本题代码如下：

```txt
int Pattern(LinkList A,LinkList B){LNode \*p=A; //p为A链表的工作指针，本题假定A和B均无头结点LNode \*pre=p; //pre记住每趟比较中A链表的开始结点LNode \*q=B; //q是B链表的工作指针while(p&&q)if(p->data==q->data）{//结点值相同p=p->next;q=q->next;}else{pre=pre->next;p=pre; //A链表新的开始比较结点q=B; //q从B链表第一个结点开始}if(q==NULL) //B已经比较结束return 1; //说明B是A的子序列elsereturn 0; //B不是A的子序列}
```

# 注意

该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优化该算法。

# 11.【解答】

算法思想：让  $p$  从左向右扫描，  $q$  从右向左扫描，直到它们指向同一结点（  $p == q$ ，当循环双链

表中结点个数为奇数时）或相邻（p->next = q 或 q->prior = p，当循环双链表中结点个数为偶数时）为止，若它们所指结点值相同，则继续进行下去，否则返回 0。若比较全部相等，则返回 1。

本题代码如下：

```c
int Symmetry(DLinkList L){DNode \*p=L->next,\*q=L->prior; //两头工作指针while(p!=q&&p->next!=q) //循环跳出条件if(p->data==q->data){//所指结点值相同则继续比较 $\begin{array}{l}\mathrm{p = p - > n e x t;}\\ \mathrm{q = q - > p r i o r;} \end{array}$  1else //否则，返回0return 0;return 1; //比较结束后返回1
```

# 注意

while 循环第二个判断条件易误写成  $q->next != p$ ，分析这样会产生什么问题。

# 12.【解答】

算法思想：先找到两个链表的尾指针，将第一个链表的尾指针与第二个链表的头结点链接起来，再使之成为循环的。

本题代码如下：

```c
LinkList Link(LinkList &h1, LinkList &h2) { //将循环链表 h2 链接到循环链表 h1 之后，使之仍保持循环链表的形式
    LNode *p, *q; //分别指向两个链表的尾结点
    p=h1;
    while (p->next != h1)
        p=p->next;
    q=h2;
    while (q->next != h2)
        q=q->next;
    p->next=h2; //将 h2 链接到 h1 之后
    q->next=h1; //令 h2 的尾结点指向 h1
    return h1;
}
```

# 13.【解答】

算法思想：首先在双链表中查找数据值为  $x$  的结点，查到后，将结点从链表上摘下，然后顺着结点的前驱链查找该结点的插入位置（频度递减，且排在同频度的第一个，即向前找到第一个比它的频度大的结点，插入位置为该结点之后），并插入到该位置。

本题代码如下：

```txt
DLinkListLocate(DLinkList&L,ElemTypex){DNode \*p=L->next,\*q; //p为工作指针，q为p的前驱，用于查找插入位置while(p&&p->data!=x)p=p->next; //查找值为  $\mathbf{x}$  的结点if(!p)exit(0); //不存在值为  $\mathbf{x}$  的结点else{p->freq++; //令元素值为  $\mathbf{x}$  的结点的freq域加1if(p->pre==L||p->pre->freq>p->freq)return p; //p是链表首结点，或freq值小于前驱if(p->next!=NULL)p->next->pre=p->pre;
```

```txt
p->pre->next=p->next; //将p结点从链表上摘下  
q=p->pre; //以下查找p结点的插入位置  
while(q!=L&&q->freq<=p->freq)  
q=q->pre;  
p->next=q->next;  
if(q->next!=NULL) q->next->pre=p; //将p结点排在同频率的第一个  
p->pre=q;  
q->next=p;  
}  
return p; //返回值为x的结点的指针
```

# 14.【解答】

# 1）算法的基本设计思想：

首先，遍历链表计算表长  $n$ ，并找到链表的尾结点，将其与首结点相连，得到一个循环单链表。然后，找到新链表的尾结点，它为原链表的第  $n - k$  个结点，令 L 指向新链表尾结点的下一个结点，并将环断开，得到新链表。

# 2）本题代码如下：

```c
LNode \*Converse(LNode \*L,int k){ int  $n = 1$  //n用来保存链表的长度 LNode \*p=L; //p为工作指针 while(p->next!=NULL){ //计算链表的长度 p=p->next; n++; } //循环执行完后，p指向链表尾结点 p->next=L; //将链表连成一个环 for(int i=1;i<=n-k;i++) //寻找链表的第n-k个结点 p=p->next; L=p->next; //令L指向新链表尾结点的下一个结点 p->next=NULL; //将环断开 return L; }
```

# 3）本算法的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$

# 15.【解答】

# 1）算法的基本设计思想：

设置快慢两个指针分别为 fast 和 slow 最初都指向链表头 head。slow 每次走一步，即 slow = slow->next；fast 每次走两步，即 fast = fast->next->next。fast 比 slow 走得快，若有环，则 fast 一定先进入环，而 slow 后进入环。两个指针都进入环后，经过若干操作后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。

如下图所示，当slow刚进入环时，fast早已进入环。因为fast每次比slow多走一步且fast与slow的距离小于环的长度，所以fast与slow相遇时，slow所走的距离不超过环的长度。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1199cbafe21e5b81ad665ff45068050da4a50b35e0ed81d5696c77aa17cc3472.jpg)


如下图所示，设头结点到环的入口点的距离为  $a$  ，环的入口点沿着环的方向到相遇点的距离为  $x$  ，环长为  $r$  ，相遇时 fast 绕过了  $n$  圈。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9a7a6a8ca0d86b6bd233c4e92b5c691192d6d298e7fd8b777be64308e1d58044.jpg)


则有  $2(a + x) = a + n^{\star}r + x$  ，即  $a = nr - x$  。显然从头结点到环的入口点的距离等于  $\mathbf{n}$  倍的环长减去环的入口点到相遇点的距离。因此可设置两个指针，一个指向head，一个指向相遇点，两个指针同步移动（均为一次走一步)，相遇点即环的入口点。

# 2）本题代码如下：

```c
LNode* FindLoopStart(LNode *head) {  
LNode *fast = head, *slow = head; //设置快慢两个指针  
while (fast != NULL && fast->next != NULL) {  
    slow = slow->next; //每次走一步  
    fast = fast->next->next; //每次走两步  
    if (slow == fast) break; //相遇  
}  
if (fast == NULL || fast->next == NULL)  
return NULL; //没有环，返回 NULL  
LNode *p1 = head, *p2 = slow; //分别指向开始点、相遇点  
while (p1 != p2) {  
    p1 = p1->next;  
    p2 = p2->next;  
}  
return p1; //返回入口点
```

3）当 fast 与 slow 相遇时，slow 肯定没有遍历完链表，故算法的时间复杂度为  $O(n)$ ，空间复杂度为  $O(1)$ 。

# 16.【解答】

# 1）算法的基本设计思想：

设置快、慢两个指针分别为 fast 和 slow，初始时 slow 指向 L（第一个结点），fast 指向 L->next（第二个结点），之后 slow 每次走一步，fast 每次走两步。当 fast 指向表尾（第  $n$  个结点）时，slow 正好指向链表的中间点（第  $n/2$  个结点），即 slow 正好指向链表前半部分的最后一个结点。将链表的后半部分逆置，然后设置两个指针分别指向链表前半部分和后半部分的首结点，在遍历过程中计算两个指针所指结点的元素之和，并维护最大值。

# 2）本题代码如下：

```c
intPairSum(LinkListL){ LNode \*fast  $=$  L->next,\*slow  $= 1$  //利用快慢双指针找到链表的中间点 while(fast!  $\equiv$  NULL&&fast->next！  $\equiv$  NULL){ fast  $\equiv$  fast->next->next; //快指针每次走两步 slow  $=$  slow->next; //慢指针每次走一步 } LNode \*newHead  $\equiv$  NULL,\*p  $\equiv$  slow->next,\*tmp; while(p!  $\equiv$  NULL){ //反转链表后一半部分的元素，采用头插法 tmp  $\equiv$  p->next; //p指向当前待插入结点，令tmp指向其下一结点 p->next  $\equiv$  newHead; //将p所指结点插入到新链表的首结点之前 newHead  $\equiv$  p; //newHead指向刚才新插入的结点，作为新的首结点 p  $\equiv$  tmp; //当前待处理结点变为下一结点 } int mx  $= 0$  .  $\mathfrak{p} = \mathbb{L}$  LNode \*q=newHead;
```

```txt
while  $(q! = NULL)$  { //用p和q分别遍历两个链表 if((p->data+q->data)>mx）//用mx记录最大值 mx=p->data+q->data; p=p->next; q=q->next; } return mx;
```

3）本算法的时间复杂度为  $O(n)$  ，空间复杂度为  $O(1)$  。

# 17.【解答】

# 1）算法的基本设计思想：

问题的关键是设计一个尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。以上过程对链表仅进行一遍扫描。

2）算法的详细实现步骤如下：

① count=0，p和q指向链表表头结点的下一个结点。

$②$  若  $\mathfrak{p}$  为空，转  $⑤$

③ 若 count 等于 k，则 q 指向下一个结点；否则，count = count + 1。

④ p指向下一个结点，转②。

⑤ 若 count 等于 k，则查找成功，输出该结点的 data 域的值，返回 1；否则，说明 k 值超过了线性表的长度，查找失败，返回 0。

⑥ 算法结束。

3）算法实现如下：

```c
typedef int ElemType; //链表数据的类型定义  
typedef struct LNode{ //链表结点的结构定义ElemType data; //结点数据struct LNode \*link; //结点链接指针}LNode，\*LinkList;  
int Search_k(LinkList list,int k){LNode \*p=list->link,\*q=list->>link; //指针p、q指示第一个结点int count  $= 0$  ·while  $(\mathfrak{p}! = \mathbb{N}$  ULL){//遍历链表直到最后一个结点if(count<k）count++; //计数，若count<k只移动pelse q=q->>link;p=p->>link; //之后让p、q同步移动}//whileif(count<k)return 0; //查找失败返回0else{printf("%d",q->data);return 1;1}
```

# 评分说明

若所给算法采用一遍扫描方式就能得到正确结果，则可给满分15分；若采用两遍或多遍扫描才能得到正确结果，则最高分为10分。若采用递归算法得到正确结果，则最高给10分；若实现算法的空间复杂度过高（使用了大小与k有关的辅助数组），但结果正确，则最高给10分。

# 18.【解答】

顺序遍历两个链表到尾结点时，并不能保证两个链表同时到达尾结点。这是因为两个链表的长度不同。假设一个链表比另一个链表长  $k$  个结点，我们先在长链表上遍历  $k$  个结点，之后同步遍历两个链表，这样就能够保证它们同时到达最后一个结点。因为两个链表从第一个公共结点到链表的尾结点都是重合的，所以它们肯定同时到达第一个公共结点。

1）算法的基本设计思想：

① 分别求出 str1 和 str2 所指的两个链表的长度  $m$  和  $n$  。

② 将两个链表以表尾对齐：令指针 p、q 分别指向 str1 和 str2 的头结点，若  $m \geq n$ ，则指针 p 先走，使 p 指向链表中的第  $m - n + 1$  个结点；若  $m < n$ ，则使 q 指向链表中的第  $n - m + 1$  个结点，即使指针 p 和 q 所指的结点到表尾的长度相等。

③ 反复将指针  $\mathfrak{p}$  和  $\mathfrak{q}$  同步向后移动，并判断它们是否指向同一结点。当  $\mathfrak{p}$  、  $\mathfrak{q}$  指向同一结点，则该点即所求的共同后缀的起始位置。

2）本题代码如下：

```c
typedef struct Node{char data;struct Node \*next;   
}SNode;   
/*求链表长度的函数*/   
int listen(SNode \*head){ int len  $= 0$  · while(head->next!=NULL){ len++; head=head->next; } return len;   
}   
/*找出共同后缀的起始地址*/   
SNode\*find_list(SNode \*str1,SNode \*str2){ int m,n; SNode \*p,\*q; m=listlen(strl); //求str1的长度，  $O(m)$  n=listlen(str2); //求str2的长度，  $O(n)$  for(p=str1;m>n;m--） //若m>n，使p指向链表中的第m-n+1个结点 p=p->next; for(q=str2;m<n;n--） //若m<n，使q指向链表中的第n-m+1个结点 q=q->next; while(p->next!=NULL&&p->next!=q->next){ //查找共同后缀起始点 p=p->next; //两个指针同步向后移动 q=q->next; } return p->next; //返回共同后缀的起始地址
```

3）时间复杂度为  $O(\mathrm{len1} + \mathrm{len2})$  或  $O(\max (\mathrm{len1},\mathrm{len2}))$  ，其中len1、len2分别为两个链表的长度。

# 19.【解答】

1）算法的基本设计思想：

- 算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。

- 因为  $\left| \text{data} \right| \leqslant n$ ，故辅助数组  $q$  的大小为  $n + 1$ ，各元素的初值均为0。依次扫描链表中的各结点，同时检查  $q[\text{data}]$  的值，若为0则保留该结点，并令  $q[\text{data}] = 1$ ；否

则将该结点从链表中删除。

2）使用C语言描述的单链表结点的数据类型定义：

```txt
typedef struct node { int data; struct node \*link; }NODE; typedef NODE \*PNODE;
```

3）算法实现如下：

```c
void func (PNODE h,int n){  
PNODE p=h,r;  
int *q,m;  
q=(int *)malloc(sizeof(int)*(n+1)); //申请  $n + 1$  个位置的辅助空间  
for (int i=0;i<n+1;i++) //数组元素初值置0  
*(q+i)=0;  
while (p->link!=NULL) {  
m=p->link->data>0? p->link->data:-p->link->data;  
if (*(q+m) == 0) { //判断该结点的数据是否已出现过  
*(q+m)=1; //首次出现  
p=p->link; //保留  
}  
else { //重复出现  
r=p->link; //删除  
p->link=r->link;  
free(r);  
}  
}
```

4）参考答案所给算法的时间复杂度为  $O(m)$  ，空间复杂度为  $O(n)$  。

# 20.【解答】

1）算法的基本设计思想：

先观察  $L = (a_{1}, a_{2}, a_{3}, \dots, a_{n - 2}, a_{n - 1}, a_{n})$  和  $L' = (a_{1}, a_{n}, a_{2}, a_{n - 1}, a_{3}, a_{n - 2}, \dots)$ ，发现  $L'$  是由  $L$  摘取第一个元素，再摘取倒数第一个元素……依次合并而成的。为了方便链表后半段取元素，需要先将  $L$  后半段原地逆置[题目要求空间复杂度为  $O(1)$ ，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。①先找出链表  $L$  的中间结点，为此设置两个指针 p 和 q，指针 p 每次走一步，指针 q 每次走两步，当指针 q 到达链尾时，指针 p 正好在链表的中间结点；②然后将  $L$  的后半段结点原地逆置。③从单链表前后两段中依次各取一个结点，按要求重排。

2）算法实现如下：

```c
void change_list(NODE\*h){NODE \*p,\*q,\*r,\*s;  $p = q = h$  ·while(q->next!=NULL){ //寻找中间结点p=p->next; //p走一步q=q->next;if(q->next!=NULL)  $q = q - >$  next; //q走两步}q=p->next; //p所指结点为中间结点，q为后半段链表的首结点p->next=NULL;while(q!=NULL）{//将链表后半段逆置r=q->next;q->next=p->next;p->next=q;q=r;
```

```html
}s=h->next; //s指向前半段的第一个数据结点，即插入点q=p->next; //q指向后半段的第一个数据结点p->next=NULL;while(q!=NULL){ //将链表后半段的结点插入到指定位置r=q->next; //r指向后半段的下一个结点q->next=s->next; //将q所指结点插入到s所指结点之后s->next=q;s=q->next; //s指向前半段的下一个插入点q=r;}1
```

3）第一步找中间结点的时间复杂度为  $O(n)$ ，第二步逆置的时间复杂度为  $O(n)$ ，第三步合并链表的时间复杂度为  $O(n)$ ，所以该算法的时间复杂度为  $O(n)$ 。

# 归纳总结

本章是算法设计题的重点考查章节，因为线性表的算法题的代码量一般都比较少，又具有一定的算法设计技巧，因此适合笔试考查。考研题中常以三段式的结构命题。

在给出题目背景和要求的情况下：

① 给出算法的基本设计思想。

② 采用C或  $\mathrm{C + + }$  语言描述算法，并给出注释。

③ 分析所设计算法的时间复杂度和空间复杂度。

算法具体的设计思想千变万化，难以从一而定。因此读者一定要勤加练习，反复咀嚼本章的练习题，采用多种方法进行设计并比较它们的复杂度，逐渐熟悉各类题型的思考角度和最佳思路。这里，编者列出几种常用的算法设计技巧，仅供参考：对于链表，经常采用的方法有头插法、尾插法、逆置法、归并法、双指针法等，对具体问题需要灵活变通；对于顺序表，因为可以直接存取，所以经常结合排序和查找的几种算法设计思路进行设计，如归并排序、二分查找等。

# 注意

对于算法设计题，若能写出数据结构类型的定义、正确的算法思想，则至少会给一半的分数；若能用伪代码写出，则自然更好；比较复杂的地方可以直接用文字表达。

# 思维拓展

一个长度为  $n$  的整型数组 A[1..n]，给定整数  $x$ ，设计一个时间复杂度不超过  $O(n\log_2n)$  的算法，查找出这个数组中所有两两之和等于  $x$  的整数对（每个元素只输出一次）。

提示：本题若想到排序，则问题便迎刃而解。先用一种时间复杂度为  $O(n\log_2n)$  的排序算法将A[1...n]从小到大排序，然后分别从数组的小端  $(i = 1)$  和大端  $(j = n)$  开始查找：若A[i]  $+\mathrm{A}[j] < x$  ，i++;若A[i]  $+\mathrm{A}[j] > x$  ，j--；否则输出A[i]、A[j]，然后i++,j--；直到  $i >= j$  时停止。

请读者思考本题是否有其他求解算法。

# 第 3 章

# 栈、队列和数组

# 【考纲内容】

（一）栈和队列的基本概念

（二）栈和队列的顺序存储结构

（三）栈和队列的链式存储结构

（四）多维数组的存储

（五）特殊矩阵的压缩存储

（六）栈、队列和数组的应用

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1a3fd0d3676db447ad79c734bf7d1a7f6c23ce1592ba72c9941bfb683df090e6.jpg)



扫一扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/aaa2bf1033bb2267728d1cc5e1f5eddc604c891017884c04b81d0f7617d166d9.jpg)



视频讲解


# 【复习提示】

本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。因为它们均是线性表的应用和推广，所以也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点，双端队列的特点，栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是读者必须掌握的内容。

# 3.1 栈

# 3.1.1 栈的基本概念

# 1. 栈的定义

# 命题追踪 栈的特点（2017）

栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如图3.1所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9afa0b9f4eef491739fca867ea6ccd06a33a4442ed2239d7c2c3806d9881aeae.jpg)



图3.1 栈的示意图


栈顶（Top）：线性表允许进行插入和删除操作的那一端。

栈底（Bottom）：固定的，不允许进行插入和删除操作的另一端。

空栈：不含任何元素的空表。

命题追踪 入栈序列和出栈序列之间的关系（2022）

命题追踪 特定条件下的出栈序列分析（2010、2011、2013、2018、2020）

假设某个栈  $S = (a_{1}, a_{2}, a_{3}, a_{4}, a_{5})$ ，如图 3.1 所示，则  $a_{1}$  为栈底元素，  $a_{5}$  为栈顶元素。栈只能在栈顶进行插入和删除操作，入栈次序依次为  $a_{1}, a_{2}, a_{3}, a_{4}, a_{5}$ ，而出栈次序为  $a_{5}, a_{4}, a_{3}, a_{2}, a_{1}$  。由此可见，栈的操作特性可以明显地概括为后进先出（Last In First Out，LIFO）。

# 注意

每接触一种新的数据结构，都应从其逻辑结构、存储结构和运算三个方面着手。

# 2.栈的基本操作

各种辅导书中给出的基本操作的名称不尽相同，但所表达的意思大致是一样的。这里我们以严蔚敏编写的教材为准给出栈的基本操作，希望读者能熟记下面的基本操作。

- InitStack(&S): 初始化一个空栈 S。

- StackEmpty(S): 判断一个栈是否为空，若栈 S 为空则返回 true，否则返回 false。

- Push(&S,x)：入栈，若栈S未满，则将x加入使之成为新栈顶。

- Pop  $(\& S, \& x)$  ：出栈，若栈  $S$  非空，则弹出栈顶元素，并用  $x$  返回。

- GetTop(S, &x): 读栈顶元素，但不出栈，若栈 S 非空，则用 x 返回栈顶元素。

- DestroyStack(&S)：销毁栈，并释放栈 S 占用的存储空间（“&”表示引用调用）。

在解答算法题时，若题干未做出限制，则也可直接使用这些基本的操作函数。

栈的数学性质：当  $n$  个不同元素入栈时，出栈元素不同排列的个数为  $\frac{1}{n + 1} C_{2n}^{n}$  。这个公式称为卡特兰数（Catalan）公式，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。

# 3.1.2 栈的顺序存储结构

栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。

# 1. 顺序栈的实现

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。

栈的顺序存储类型可描述为

```txt
define MaxSize 50 typedef struct{
```

```txt
//定义栈中元素的最大个数
```

```javascript
Elemtype data[MaxSize]; //存放栈中元素 int top; //栈顶指针 }SqStack;
```

栈顶指针：S.top，初始时设置 S.top=-1；栈顶元素：S.data[S.top]。

入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶。

出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1。

栈空条件：S.top  $= = -1$  ；栈满条件：S.top  $= =$  MaxSize-1；栈长：S.top+1。

另一种常见的方式是：初始设置栈顶指针 S.top=0；入栈时先将值送到栈顶，栈顶指针再加 1；出栈时，栈顶指针先减 1，再取栈顶元素；栈空条件是 S.top==0；栈满条件是 S.top==MaxSize。

顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。

# 注意

栈和队列的判空、判满条件，会因实际给出的条件不同而变化，下面的代码实现是在栈顶指针初始化为-1的条件下的相应方法，而其他情况则需具体问题具体分析。

# 2. 顺序栈的基本操作

# 命题追踪 出/入栈操作的模拟（2009）

栈操作的示意图如图3.2所示，图3.2(a)是空栈，图3.2(c)是A、B、C、D、E共5个元素依次入栈后的结果，图3.2(d)是在图3.2(c)之后E、D、C的相继出栈，此时栈中还有2个元素，或许最近出栈的元素C、D、E仍在原先的单元存储着，但top指针已经指向了新的栈顶，元素C、D、E已不在栈中，读者应通过该示意图深刻理解栈顶指针的作用。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fe69ad59be5486f646c82315ac9cd2858d1f7c5bab75d471ed92edd4a5ef5a50.jpg)



(a) 空栈


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c5c41eae2d709dcb0d3ff56c8407165c99fceee514726f6948000a745a96c159.jpg)



(b) 1个元素


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5ca98e471d49a20fbc4364f387b79996f8eaffcf91ec1f30ad2e3366cb10f817.jpg)



(c)5个元素


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1f771e20e15e48c8d3d4d7fecabe89741c4a3d7f1b0dcb711a13c3eaa1948340.jpg)



(d)2个元素



图3.2 栈顶指针和栈中元素之间的关系


下面是顺序栈上常用的基本操作的实现。

（1）初始化

```txt
void InitStack(SqStack &S) {  
    S.top = -1; //初始化栈顶指针  
}
```

（2）判栈空

```txt
bool StackEmpty(SqStack S){ if(S.top  $= = -1$  //栈空 return true; else //不空 return false; }
```

（3）入栈

```txt
bool Push(SqStack &S, ElemType x) {
```

```javascript
if(S.top==MaxSize-1) //栈满，报错 return false; S.data[++S.top]=x; //指针先加1，再入栈 return true; }
```

当栈不满时，top先加1，再入栈。若初始时将top定义为0，函数3和4应如何改写？

（4）出栈

```txt
bool Pop(SqStack &S, ElemType &x) {
    if (S.top == -1) //栈空，报错
        return false;
    x = S.data[S.top --];
    return true;
}
```

（5）读栈顶元素

```txt
bool GetTop (SqStack S, ElemType &x) {
    if (S.top == -1)
        //栈空，报错
        return false;
    x = S.data[S.top];
    return true;
}
```

仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。

# 注意

这里的top指的是栈顶元素。于是，入栈操作为S.data[++S.top] = x，出栈操作为x=S.data[S.top--]。若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，则入栈操作变为S.data[S.top++] = x；出栈操作变为  $x = S$  data[--S.top]。相应的栈空、栈满条件也会发生变化。请读者仔细体会其中的不同之处，做题时要灵活应变。

# 3. 共享栈

利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图3.3所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8bab7f4cce39a842fe482e4ee8574531fcc79e6c64e3eedac18c568622101079.jpg)



图3.3 两个顺序栈共享存储空间


两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；仅当两个栈顶指针相邻（top1-top0=1）时，判断为栈满。当0号栈入栈时top0先加1再赋值，1号栈入栈时top1先减1再赋值；出栈时则刚好相反。

共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为  $O(1)$ ，所以对存取效率没有什么影响。

# 3.1.3 栈的链式存储结构

采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现链栈，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead指向栈顶元素，如图3.4所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/21db1e2d2741ea13e843d733719daf92727b271fb025b420fa70d28af2dc5127.jpg)



图3.4 栈的链式存储


栈的链式存储类型可描述为

```txt
typedef struct Linknode{ElemType data; //数据域struct Linknode \*next; //指针域}LiStack; //栈类型定义
```

采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。

# 3.1.4 本节试题精选

# 一、单项选择题

01.栈和队列具有相同的（）。

A. 抽象数据类型

B. 逻辑结构

C. 存储结构

D. 运算

02.栈是一种（）。

A. 顺序存储的线性结构

B. 链式存储的非线性结构

C. 限制存取点的线性结构

D. 限制存取点的非线性结构

03. 下列选项中，（）不是栈的基本操作。

A. 删除栈顶元素

B. 删除栈底元素

C. 判断栈是否为空

D. 将栈置为空栈

04. 假定用数组 a[n] 存储一个栈，初始栈顶指针 top  $= -1$  ，则元素 x 入栈的操作是（）。

A.  $a[--top] = x$

B.  $a[top--] = x$

C.  $a[++\text{top}] = x$

D. a  $[ \text{top} + + ] = x$

05. 假定用数组 a[1..n]存储一个栈，初始栈顶指针 top = 1，则元素 x 入栈的操作是（）。

A. data[top--] = x

B. data[top++] = x

C. data[--top]=x

D. data[++top] = x

06. 假定用数组 a[1..n]存储一个栈，初始栈顶指针 top=n+1，则元素 x 入栈的操作是（）。

A. data[--top] = x

B. data  $\left[\operatorname{top} + +\right] = x$

C. data[top--] = x

D. data[++top] = x

07. 设有一个空栈，栈顶指针为 1000H，栈向高地址方向增长，每个元素占一个存储单元，执行 push、push、pop、push、pop、push、pop、push 操作后，栈顶指针为（）。

A.  $1002\mathrm{H}$

B.  $1003 \mathrm{H}$

C.  $1004 \mathrm{H}$

D.  $1005 \mathrm{H}$

08. 和顺序栈相比，链栈有一个比较明显的优势，即（）。

A. 通常不会出现栈满的情况

B. 通常不会出现栈空的情况

C. 插入操作更容易实现

D. 删除操作更容易实现

09. 设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是（）。

A. 只有表头结点指针, 没有表尾指针的双向循环链表

B. 只有表尾结点指针, 没有表头指针的双向循环链表

C. 只有表头结点指针, 没有表尾指针的单向循环链表

D. 只有表尾结点指针, 没有表头指针的单向循环链表

10. 向一个栈顶指针为 top 的链栈（不带头结点）中插入一个 x 结点，则执行（）。

A. top->next=x

B.  $x->$  next  $\equiv$  top-  $\rightharpoondown$  next;top-  $\rightharpoonup$  next=x

C.  $x->\text{next} = \text{top}$ ;  $top = x$

D.  $x->$  next  $\equiv$  top;top  $\equiv$  top-  $\rightharpoondown$  next

11．链栈（不带头结点）执行pop操作，并将出栈的元素存在x中，应该执行（）。

A.  $x = \text{top}$ ; top = top->next

B.  $x = \text{top} - > \text{data}$

C. top  $\equiv$  top->next;  $x =$  top->data

D.  $x = \text{top} - > \text{data}$ ; top  $\equiv$  top->next

12. 经过以下栈的操作后，变量  $\mathbf{x}$  的值为（）。

InitStack(st);Push(st，a)；Push(st，b)；Pop(st，x）；GetTop(st，x)；

A. a

B. b

C. NULL

D. false

13. 3个不同元素依次入栈，能得到（）种不同的出栈序列。

A. 4

B. 5

C. 6

D. 7

14. 设  $a, b, c, d, e, f$  以所给的次序入栈，若在入栈操作时，允许出栈操作，则下面不会出现的出栈序列为（）。

A. fedcba

B. bcafed

C. dcefba

D. cabdef

15. 4个元素依次入栈的次序为  $a, b, c, d$ ，则以  $c, d$  开头的出栈序列的个数为（）。

A. 1

B. 2

C. 3

D. 4

16. 用 S 表示入栈操作，用 X 表示出栈操作，若元素的入栈顺序是 1234，为了得到 1342 的出栈顺序，相应的 S 和 X 的操作序列为（）。

A. SXSXSSXX

B. SSSXXSXX

C. SXSSXXSX

D. SXSSXSXX

17. 若栈的输入序列是  $1,2,3,\cdots,n$ ，输出序列的第一个元素是  $n$ ，则第  $i$  个输出元素是（）。

A. 不确定

B.  $n - i$

C.  $n - i - 1$

D.  $n - i + 1$

18. 若栈的输入序列是  $1,2,3,\cdots,n$ ，输出序列的第一个元素是  $i$ ，则第  $j$  个输出元素是（）。

A.  $i - j - 1$

B.  $i - j$

C.  $j - i + 1$

D. 不确定

19. 某栈的输入序列为  $a, b, c, d$ ，下面的4个序列中，不可能为其输出序列的是（）。

A.  $a, b, c, d$

B.  $c, b, d, a$

C.  $d, c, a, b$

D.  $a, c, b, d$

20. 若栈的输入序列是  $P_{1}, P_{2}, \dots, P_{n}$ ，输出序列是  $1, 2, 3, \dots, n$ ，若  $P_{3} = 1$ ，则  $P_{1}$  的值（）。

A. 可能是 2

B. 一定是2

C. 不可能是 2

D. 不可能是 3

21. 若栈的输入序列是  $P_{1}, P_{2}, \dots, P_{n}$ ，输出序列是  $1, 2, 3, \dots, n$ ，若  $P_{3} = 3$ ，则  $P_{1}$  的值（）。

A. 可能是 2

B. 不可能是 1

C. 一定是1

D. 一定是2

22. 已知栈的入栈序列是1,2,3,4，其出栈序列为  $P_{1}, P_{2}, P_{3}, P_{4}$ ，则  $P_{2}, P_{4}$  不可能是（）。

A. 2,4

B. 2, 1

C. 4, 3

D. 3,4

23. 设栈的初始状态为空，当字符序列“n1_”作为栈的输入时，输出长度为3，且可用作C语言标识符的序列有（）个。

A. 4

B. 5

C. 3

D. 6

24. 采用共享栈的好处是（）。

A. 减少存取时间，降低发生上溢的可能

B. 节省存储空间，降低发生上溢的可能

C. 减少存取时间，降低发生下溢的可能

D. 节省存储空间，降低发生下溢的可能

25. 设有一个顺序共享栈 Share[0:n-1]，其中第一个栈顶指针 top1 的初值为-1，第二个栈顶指针 top2 的初值为 n，则判断共享栈满的条件是（）。

A. top2-top1==1

B. top1-top2  $= = 1$

C. top1==top2

D. 都不对

26.【2009统考真题】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是（）。

A. 1

B. 2

C. 3

D. 4

27.【2010统考真题】若元素  $a, b, c, d, e, f$  依次入栈，允许入栈、出栈操作交替进行，但不允许连续3次进行出栈操作，不可能得到的出栈序列是（）。

A. dcebfa

B. cbdaef

C. bcaefd

D. afedcb

28.【2011统考真题】元素  $a, b, c, d, e$  依次进入初始为空的栈中，若元素入栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素  $d$  开头的序列个数是（）。

A. 3

B. 4

C. 5

D. 6

29.【2013统考真题】一个栈的入栈序列为  $1,2,3,\dots ,n$  ，出栈序列是  $P_{1},P_{2},P_{3},\dots ,P_{n}$  。若  $P_{2} = 3$  则  $P_{3}$  可能取值的个数是（）。

A.  $n - 3$

B.  $n - 2$

C.  $n - 1$

D. 无法确定

30.【2020统考真题】对空栈S进行Push和Pop操作，入栈序列为  $a, b, c, d, e$  ，经过Push、Push、Pop、Push、Pop、Push、Push、Pop操作后得到的出栈序列是（）。

A.  $b, a, c$

B.  $b, a, e$

C.  $b, c, a$

D.  $b, c, e$

31.【2022统考真题】给定有限符号集S，in和out均为S中所有元素的任意排列。对于初始为空的栈ST，下列叙述中，正确的是（）。

A. 若 in 是 ST 的入栈序列, 则不能判断 out 是否为其可能的出栈序列

B. 若 out 是 ST 的出栈序列, 则不能判断 in 是否为其可能的入栈序列

C. 若 in 是 ST 的入栈序列, out 是对应 in 的出栈序列, 则 in 与 out 一定不同

D. 若 in 是 ST 的入栈序列, out 是对应 in 的出栈序列, 则 in 与 out 可能互为倒序

# 二、综合应用题

01. 有5个元素，其入栈次序为  $A, B, C, D, E$  ，在各种可能的出栈次序中，第一个出栈元素为  $C$  且第二个出栈元素为  $D$  的出栈序列有哪几个？

02. 若元素的入栈序列为  $A, B, C, D, E$ ，运用栈操作，能否得到出栈序列  $B, C, A, E, D$  和  $D, B, A, C, E$ ？为什么？

03.栈的初态和终态均为空，以I和O分别表示入栈和出栈，则出入栈的操作序列可表示为由I和O组成的序列，可以操作的序列称为合法序列，否则称为非法序列。

1）下面所示的序列中哪些是合法的？

A. IOIOIOO

B. IOOIOIIO

C. IIIOIOIO

D. IIIOOIOO

2）通过对1）的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。

04. 设单链表的表头指针为  $L$ ，结点结构由 data 和 next 两个域构成，其中 data 域为字符型。试设计算法判断该链表的全部 n 个字符是否中心对称。例如 xyx、xyyx 都是中心对称。

05. 设有两个栈 S1、S2 都采用顺序栈方式，并共享一个存储区  $[0, \dots, \text{maxsize-1}]$ ，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计 S1、S2 有关入栈和出栈的操作算法。

# 3.1.5 答案与解析

# 一、单项选择题

01. B

栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同。

02. C

首先栈是一种线性表，所以选项B、D错。按存储结构的不同可分为顺序栈和链栈，但不可以把栈局限在某种存储结构上，所以选项A错。栈和队列都是限制存取点的线性结构。

03. B

基本操作是指该结构最核心、最基本的运算，其他较复杂的操作可通过基本操作实现。删除栈底元素不属于栈的基本运算，但它可以通过调用栈的基本运算求得。

04.C

数组下标范围为  $0 \sim n - 1$  ，初始时top为-1，第一个元素入栈后，top为0，即top指向栈顶元素。栈向高地址方向增长，所以入栈时应先将指针top加1，然后存入元素x，选项C正确。

05. B

数组下标范围为  $1\sim \mathrm{n}$  ，初始时top为1，表示top指向栈顶元素的下一个元素。栈向高地址方向增长，所以入栈时应先存入元素x，然后将指针top加1，选项B正确。

06. A

数组下标范围为  $1\sim \mathrm{n}$  ，初始时top为  $\mathrm{n + 1}$  ，表示top指向栈顶元素。栈向低地址方向增长，所以入栈时应先将指针top减1，然后存入元素x，A正确。

07. A

每个元素需要1个存储单元，所以每入栈一次top加1，出栈一次top减1。指针top的值依次为  $1001\mathrm{H},1002\mathrm{H},1001\mathrm{H},1002\mathrm{H},1001\mathrm{H},1002\mathrm{H},1001\mathrm{H},1002\mathrm{H}$

08. A

顺序栈采用数组存储，数组的大小是固定的，不能动态地分配大小。和顺序栈相比，链栈的最大优势在于它可以动态地分配存储空间。

09. C

对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而循环单链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点需要遍历一次链表。对于选项C，插入和删除结点后，找尾结点所需的时间为  $O(n)$

10. C

链栈采用不带头结点的单链表表示时，入栈操作在首部插入一个结点  $\mathbf{x}$ （ $\mathbf{x}->\mathrm{next} = \mathrm{top}$ ），插入完后需将 top 指向该插入的结点  $\mathbf{x}$ 。请思考当链栈存在头结点时的情况。

11. D

这里假设栈顶指针指向的是栈顶元素，所以选择选项D；而选项A中首先将top指针赋给了x，错误；选项B中没有修改top指针的值；选项C为top指针指向栈顶元素的上一个元素时的答案。

12. A

执行前3句后，栈st内的值为a,b，其中b为栈顶元素；执行第4句后，栈顶元素b出栈，x的值为b；执行最后一句，读取栈顶元素的值，x的值为a。

13. B

当  $n$  个不同元素入栈时，出栈序列的个数为

$$
\frac {1}{n + 1} C _ {2 n} ^ {n} = \frac {1}{n + 1} \frac {(2 n) !}{n ! \times n !} = \frac {6 \times 5 \times 4}{4 \times 3 \times 2 \times 1} = 5
$$

考题中给出的  $n$  值不会很大，可以根据栈的特点，若  $X_{i}$  已经出栈，则  $X_{i}$  前面的尚未出栈的元素一定逆置有序地出栈，因此可采用例举方法。如  $a, b, c$  依次入栈的出栈序列有 abc,acb,bac,bca,cba。另外，在一些考题中可能会问符合某个特定条件的出栈序列有多少种，比如此题中的问以  $b$  开头的出栈序列有几种，这种类型的题目一般都使用穷举法。

# 14. D

根据栈“先进后出”的特点，且在入栈操作的同时允许出栈操作，显然选项D中  $c$  最先出栈，则此时栈内必定为  $a$  和  $b$  ，但因为  $a$  先于  $b$  入栈，所以要晚出栈。对于某个出栈的元素，在它之前入栈却晚出栈的元素必定是按逆序出栈的，其余答案均是可能出现的情况。

此题也可采用将各序列逐个代入的方法来确定是否有对应的进出栈序列（类似下题）。

# 15. A

假设出栈序列为  $cd\ldots$  ，分析栈的操作序列：  $a$  入栈，  $b$  入栈，  $c$  入栈，  $c$  出栈，  $d$  入栈，  $d$  出栈，此后只能是  $b$  出栈和  $a$  出栈一种情况，因此出栈序列只有  $cdba$  。

# 16. D

采用排除法，选项A,B,C得到的出栈序列分别为1243,3241,1324。由1234得到1342的进出栈序列为：1进，1出，2进，3进，3出，4进，4出，2出，所以选择选项D。

# 17. D

第  $n$  个元素第一个出栈，说明前  $n - 1$  个元素都已经按顺序入栈，由“先进后出”的特点可知，此时的输出序列一定是输入序列的逆序，所以答案选择选项D。

# 18. D

当第  $i$  个元素第一个出栈时，则  $i$  之前的元素可以依次排在  $i$  之后出栈，但剩余的元素可以在此时入栈，并且排在  $i$  之前的元素出栈，所以第  $j$  个出栈的元素是不确定的。

# 19. C

对于A，可能的顺序是  $a$  入，  $a$  出，  $b$  入，  $b$  出，  $c$  入，  $c$  出，  $d$  入，  $d$  出。对于选项B，可能的顺序是  $a$  入，  $b$  入，  $c$  入，  $c$  出，  $b$  出，  $d$  入，  $d$  出，  $a$  出。对于选项D，可能的顺序是  $a$  入，  $a$  出，  $b$  入，  $c$  入，  $c$  出，  $b$  出，  $d$  入，  $d$  出。选项C没有对应的序列。

【另解】若出栈序列的第一个元素为  $d$  ，则出栈序列只能是  $dcba$  。该思想通常也适用于出栈序列的局部分析：如12345入栈，问出栈序列34152是否正确？如何分析？若第一个出栈元素是3，则此时12必停留在栈中，它们出栈的相对顺序只能是21，所以34152错误。

# 20. C

入栈序列是  $P_{1}, P_{2}, \dots, P_{n}$  。因为  $P_{3} = 1$  ，即  $P_{1}, P_{2}, P_{3}$  连续入栈后，第一个出栈元素是  $P_{3}$ ，说明  $P_{1}, P_{2}$  已经按序入栈，根据先进后出的特点可知， $P_{2}$  必定在  $P_{1}$  之前出栈，而第二个出栈元素是2，而此时  $P_{1}$  不是栈顶元素，所以  $P_{1}$  的值不可能是2。思考：哪些  $P_{i}$  可能是2？

# 21. A

假设  $P_{1}$  是1，入栈后立即出栈，  $P_{2}$  是2，入栈后立即出栈，  $P_{3}$  是3，入栈后立即出栈，得到的序列符合题意。假设  $P_{1}$  是2，  $P_{2}$  是1，  $P_{1}, P_{2}$  依次入栈后全部出栈，  $P_{3}$  是3，入栈后立即出栈，得到的序列符合题意。因此，  $P_{1}$  既可能是1，又可能是2。

# 22. C

逐个判断每个选项可能的入栈出栈顺序。对于选项A，可能的顺序是1入，1出，2入，2出，

3入，3出，4入，4出。对于选项B，可能的顺序是1入，2入，3入，3出，2出，4入，4出，1出。对于选项D，可能的顺序是1入，1出，2入，3入，3出，2出，4入，4出。选项C没有对应的序列，因为当4在栈中时，意味着前面的所有元素（1,2,3）都已在栈中或曾经入过栈，此时若4第二个出栈，即栈中还有两个元素，且这两个元素是有序的（对应入栈顺序)，只能为(1,2),(1,3),(2,3)，若是序列(1,2)，则3已在  $p_1$  位置出栈，不可能再在  $p_4$  位置出栈，若是(1,3)和(2,3)这种情况中的任意一种，则3一定是下一个出栈元素，即  $p_3$  一定是3，所以  $p_4$  不可能是3。

【另解】对于  $C$  ，  $p_2$  为最后一个入栈元素4，则只有  $p_1$  或  $p_3$  出栈的元素有可能为3（请读者分两种情况自行思考），而  $p_4$  绝不可能为3。读者在解答此类题时，一定要注意出栈序列中的“最后一个入栈元素”，这样可以节省答题的时间。

# 23. C

标识符只能以英文字母或下画线开头，而不能以数字开头。于上，由n、1、_三个字符组合成的标识符有n1、n1、_ln和_n1四种。第一种：n入栈再出栈，1入栈再出栈，_入栈再出栈。第二种：n入栈再出栈，1入栈，_入栈，_出栈，1出栈。第三种：n入栈，1入栈，_入栈，_出栈，1出栈，n出栈。而根据栈的操作特性，_n1这种情况不可能出现。

# 24. B

上溢是指存储器满，还往里写；下溢是指存储器空，还往外读。为了解决上溢，可给栈分配很大的存储空间，但这样又会造成存储空间的浪费。共享栈的提出就是为了在解决上溢的基础上节省存储空间，将两个栈放在同一段更大的存储空间内，这样，当一个栈的元素增加时，可使用另一个栈的空闲空间，从而降低发生上溢的可能性。

# 25. A

这种情况就是前面我们所描述的，详细内容请参见本节考点精析部分对共享栈的讲解。另外，读者可以思考当top1的初值为0，top2的初值为n-1时栈满的条件。

# 注意

栈顶、队头与队尾的指针的定义是不唯一的，做题时务必仔细审题和思考。

# 26. C

时刻注意栈的特点是先进后出，下表是出入栈的详细过程。

<table><tr><td>序号</td><td>说明</td><td>栈内</td><td>栈外</td><td>序号</td><td>说明</td><td>栈内</td><td>栈外</td></tr><tr><td>1</td><td>a入栈</td><td>a</td><td></td><td>8</td><td>e入栈</td><td>ae</td><td>bdc</td></tr><tr><td>2</td><td>b入栈</td><td>ab</td><td></td><td>9</td><td>f入栈</td><td>aef</td><td>bdc</td></tr><tr><td>3</td><td>b出栈</td><td>a</td><td>b</td><td>10</td><td>f出栈</td><td>ae</td><td>bdcf</td></tr><tr><td>4</td><td>c入栈</td><td>ac</td><td>b</td><td>11</td><td>e出栈</td><td>a</td><td>bdcfe</td></tr><tr><td>5</td><td>d入栈</td><td>acd</td><td>b</td><td>12</td><td>a出栈</td><td></td><td>bdcfea</td></tr><tr><td>6</td><td>d出栈</td><td>ac</td><td>bd</td><td>13</td><td>g入栈</td><td>g</td><td>bdcfea</td></tr><tr><td>7</td><td>c出栈</td><td>a</td><td>bdc</td><td>14</td><td>g出栈</td><td></td><td>bdcfeag</td></tr></table>

栈内的最大深度为3，所以栈S的容量至少是3。

【另解】因为元素的出队顺序和入队顺序相同，所以元素的出栈顺序就是  $b, d, c, f, e, a, g$ ，因此元素的出入栈次序为  $\mathrm{Push}(\mathrm{S}, a)$ ,  $\mathrm{Push}(\mathrm{S}, b)$ ,  $\mathrm{Pop}(\mathrm{S}, b)$ ,  $\mathrm{Push}(\mathrm{S}, c)$ ,  $\mathrm{Pop}(\mathrm{S}, d)$ ,  $\mathrm{Pop}(\mathrm{S}, c)$ ,  $\mathrm{Push}(\mathrm{S}, e)$ ,  $\mathrm{Push}(\mathrm{S}, f)$ ,  $\mathrm{Pop}(\mathrm{S}, f)$ ,  $\mathrm{Pop}(\mathrm{S}, e)$ ,  $\mathrm{Pop}(\mathrm{S}, a)$ ,  $\mathrm{Push}(\mathrm{S}, g)$ ,  $\mathrm{Pop}(\mathrm{S}, g)$ 。初始所需容量为0，每做一次Push操作，容量加1；每做一次Pop操作，容量减1，记录的容量最大值为3。

# 27. D

选项A由  $a$  入，  $b$  入，  $c$  入，  $d$  入，  $d$  出，  $c$  出，  $e$  入，  $e$  出，  $b$  出，  $f$  入，  $f$  出，  $a$  出得到；选项B由  $a$  入，  $b$  入，  $c$  入，  $c$  出，  $b$  出，  $d$  入，  $d$  出，  $a$  出，  $e$  入，  $e$  出，  $f$  入，  $f$  出得到；选项C由  $a$  入，  $b$  入，  $b$  出，  $c$  入，  $c$  出，  $a$  出，  $d$  入，  $e$  入，  $e$  出，  $f$  入，  $f$  出，  $d$  出得到；选项D由  $a$  入，  $a$  出，  $b$  入，  $c$  入，  $d$  入，  $e$  入，  $f$  入，  $f$  出，  $d$  出，  $c$  出，  $b$  出得到，但题意要求不允许连续3次出栈操作，选项D不符。

【另解】先入栈的元素后出栈，入栈顺序为  $a, b, c, d, e, f$  ，所以连续出栈时的子序列必然是按字母表逆序的，若出栈序列中出现了长度大于或等于3的连续逆序子序列，则为所选序列。

# 28. B

$d$  第一个出栈，则  $c, b, a$  出栈的相对顺序是确定的，出栈顺序必为  $d\_ c\_ b\_ a$ ,  $e$  的顺序不定，在任意一个“_”上都有可能。

【另解】  $d$  首先出栈，则  $abc$  停留在栈中，此时栈的状态如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f87d56466510c0b3ebce73dc648a7f8354d5c6ebfb008c67208c30b7a2eac400.jpg)


此时可以有如下4种操作：①  $e$  入栈后出栈，则出栈序列为decba；②  $c$  出栈，  $e$  入栈后出栈，出栈序列为dceba；③  $cb$  出栈，  $e$  入栈后出栈，出栈序列为dcbea；④  $cba$  出栈，  $e$  入栈后出栈，出栈序列为dcbae。思路和上面其实一样。

# 29. C

显然，3之后的  $4,5,\dots ,n$  都是  $P_{3}$  可取的数（一直入栈直到该数入栈后马上出栈）。接下来分析1和2是否可取：  $P_{1}$  可以是3之前入栈的数（可能是1或2)，也可以是4，当  $P_{1} = 1$  时，  $P_{3}$  可取2；当  $P_{1} = 2$  时，  $P_{3}$  可取1。因此，  $p_3$  可能取除3外的所有数，个数为  $n - 1$  。

# 30. D

按题意，出入栈操作的过程如下：

<table><tr><td>操作</td><td>栈内元素</td><td>出栈元素</td></tr><tr><td>Push</td><td>a</td><td></td></tr><tr><td>Push</td><td>a b</td><td></td></tr><tr><td>Pop</td><td>a</td><td>b</td></tr><tr><td>Push</td><td>a c</td><td></td></tr><tr><td>Pop</td><td>a</td><td>c</td></tr><tr><td>Push</td><td>a d</td><td></td></tr><tr><td>Push</td><td>a d e</td><td></td></tr><tr><td>Pop</td><td>a d</td><td>e</td></tr></table>

因此，出栈序列为  $b, c, e$ 。

# 31. D

通过模拟出入栈操作，可以判断入栈序列 in 和出栈序列 out 是否合法。因此，已知 in 序列可以判断 out 序列是否为可能的出栈序列；已知 out 序列也可以判断 in 序列是否为可能的入栈序列，选项 A 和 B 错误。若每个元素入栈后立即出栈，则 in 序列和 out 序列相同，选项 C 错误。若所有元素都入栈后才依次出栈，则 in 序列和 out 序列互为倒序，选项 D 正确。

# 二、综合应用题

# 01.【解答】

$CD$  出栈后的状态如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ce53c2eb12ded131f2f9adf90889ee2428293ecfc1da737aaa03c7c7dcb915cb.jpg)


此时有如下3种操作：①  $E$  入栈后出栈，出栈序列为CDEBA；②  $B$  出栈， $E$  入栈后出栈，出栈序列为CDBEA；③  $B$  出栈， $A$  出栈， $E$  入栈后出栈，出栈序列为CDBAE。

所以，以  $CD$  开头的出栈序列有CDEBA、CDBEA、CDBAE三种。

# 02.【解答】

能得到出栈序列  $BCAED$  。可由  $A$  入，  $B$  入，  $B$  出，  $C$  入，  $C$  出，  $A$  出，  $D$  入，  $E$  入，  $E$  出，  $D$  出得到。不能得到出栈序列DBACE。若出栈序列以  $D$  开头，说明在  $D$  之前的入栈元素是  $A$  、  $B$  和  $C$ ，三个元素中  $C$  是栈顶元素，  $B$  和  $A$  不可能早于  $C$  出栈，所以不可能得到出栈序列DBACE。

# 03.【解答】

1）选项A、D合法，而选项B、C不合法。在B中，先入栈1次，再连续出栈2次，错误。在选项C中，入栈和出栈次数不一致，会导致最终的栈不空。选项A、D均为合法序列，请自行模拟。注意，在操作过程中，入栈次数一定大于或等于出栈次数；结束时，栈一定为空。

2）设被判定的操作序列已存入一维数组  $A$  中。算法的基本设计思想：依次逐一扫描入栈出栈序列（由“I”和“O”组成的字符串），每扫描至任意一个位置均需检查出栈次数（“O”的个数）是否小于入栈次数（“I”的个数），若大于则为非法序列。扫描结束后，再判断入栈和出栈次数是否相等，若不相等则不合题意，为非法序列。

本题代码如下：

```c
bool Judge(char A[]) {  
    int i = 0;  
    int j = k = 0; //i为下标，j和k分别为字母I和O的个数  
    while (A[i] != '\0') { //未到字符数组尾  
        switch (A[i]) {  
            case 'I': j++; break; //入栈次数增1  
            case 'O': k++;  
            if (k > j) { printf("序列非法\n"); exit(0); }  
        }  
    i++; //不论A[i]是I还是O，指针i均后移  
}  
if (j != k) {  
    printf("序列非法\n");  
    return false;  
}  
else {  
    printf("序列合法\n");  
    return true;  
}
```

【另解】入栈后，栈内元素个数加1；出栈后，栈内元素个数减1，因此可将判定一组出入栈序列是否合法转化为一组由  $+1$  、-1组成的序列，它的任意前缀子序列的累加和不小于0（每次出栈或入栈操作后判断）则合法；否则非法。

# 04.【解答】

算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次入栈。在处

理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，对两个元素进行比较，若相等，则将链表中的下一个元素与栈中再弹出的元素进行比较，直至链表到尾。这时若栈是空栈，则得出链表中心对称的结论；否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束算法的执行。

本题代码如下：

```c
int dc(LinkList L,int n){ int i; char s[n/2]; //s字符栈 LNode \*p=L->next; //工作指针p，指向待处理的当前元素 for(i=0;i<n/2;i++){ s[i]=p->data; p=p->next; } i--; //恢复最后的i值 if(n%2==1) //若n是奇数，后移过中心结点 p=p->next; while(p!=NULL&&s[i] ==p->data){ //检测是否中心对称 i--; //i充当栈顶指针 p=p->next; } if(i=-1) //栈为空栈 return 1; //链表中心对称 else return 0; //链表中心不对称
```

算法先将“链表的前一半”元素（字符）入栈。当  $n$  为偶数时，前一半和后一半的个数相同；当  $n$  为奇数时，链表中心结点字符不必比较，移动链表指针到下一字符开始比较。比较过程中遇到不相等时，立即退出while循环，不再进行比较。

本题也可以先将单链表中的元素全部入栈，然后扫描单链表L并比较，直到比较到单链表L尾为止，但算法需要两次扫描单链表L，效率不及上述算法高。

# 05.【解答】

两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，S1栈顶指针为-1，S2栈顶指针为maxsize。两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。

本题代码如下：

```txt
define maximize 100 //两个栈共享顺序存储空间所能达到的最多元素数，//初始化为100  
#define elemtp int //假设元素类型为整型  
typedef struct{ elemtp stack[maxsize]; //栈空间 int top[2]; //top为两个栈顶指针}stk;  
stk s; //s是如上定义的结构类型变量，为全局变量
```

本题的关键在于，两个栈入栈和出栈时的栈顶指针的计算。S1栈是通常意义下的栈；而S2栈入栈操作时，其栈顶指针左移（减1)，出栈时，栈顶指针右移（加1)。

此外，对于所有栈的操作，都要注意“入栈判满、出栈判空”的检查。

（1）入栈操作

代码如下：

```txt
int push(int i, elemtp x) { //入栈操作。i为栈号，  $\mathrm{i} = 0$  表示左边的S1栈，  $\mathrm{i} = 1$  表示右边的S2栈，  $\mathbf{X}$  是入栈元素
```

//入栈成功返回1，否则返回0

```javascript
if(i<0||i>1){printf("栈号输入不对");exit(0);  
}if(s.top[1]-s.top[0] == 1) {printf("栈已满\n");return 0;  
}switch(i){case 0: s.stack[++s.top[0]] = x; return 1; break; case 1: s.stack[-s.top[1]] = x; return 1;  
}
```

（2）出栈操作

代码如下：

```javascript
elemtpop(inti){ //出栈算法。i代表栈号，  $\mathrm{i} = 0$  时为S1栈，  $\mathrm{i} = 1$  时为S2栈 //出栈成功返回出栈元素，否则返回-1 if(i<0||i>1）{ printf("栈号输入错误\n"); exit(0); } switch(i){ case0: if(s.top[0]  $= = -1$  ）{ printf("栈空\n"); return -1; } else return s.stack[s.top[0]--]; break; case1: if(s.top[1]  $= =$  maxsize){ printf("栈空\n"); return -1; } else return s.stack[s.top[1]++]; break; }//switch   
}
```

# 3.2 队列

# 3.2.1 队列的基本概念

# 1. 队列的定义

队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO），如图3.5所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5774a6fe96c5fddce4c1e08a47180e503038824e7fffa468d533192a7b0b794b.jpg)



图3.5 队列示意图


队头（Front）：允许删除的一端，也称队首。

队尾（Rear）：允许插入的一端。

空队列：不含任何元素的空表。

# 2. 队列常见的基本操作

InitQueue(&Q)：初始化队列，构造一个空队列  $Q$ 。

QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。

EnQueue(&Q,x)：入队，若队列  $\mathbb{Q}$  未满，将  $\mathbf{x}$  加入，使之成为新的队尾。

DeQueue(&Q, &x)：出队，若队列  $\mathsf{Q}$  非空，删除队首元素，并用  $\mathbf{x}$  返回。

GetHead(Q, &x): 读队首元素，若队列 Q 非空，则将队首元素赋值给 x。

需要注意的是，栈和队列是操作受限的线性表，因此不是任何对线性表的操作都可以作为栈和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。

# 3.2.2 队列的顺序存储结构

# 1. 队列的顺序存储

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队首指针front指向队首元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear的定义可能不同，例如，可以让rear指向队尾元素、front指向队首元素。对于不同的定义，出入队的操作是不同的，本节后面有一些相关的习题，读者可以结合习题思考）。

队列的顺序存储类型可描述为

```txt
define MaxSize 50 //定义队列中元素的最大个数 typedef struct{ ElemType data[MaxSize]; //用数组存放队列元素 int front,rear; //队首指针和队尾指针 }SqQueue;
```

初始时：Q.front  $=$  Q.rear  $= 0$

入队操作：队不满时，先送值到队尾元素，再将队尾指针加1。

出队操作：队不空时，先取队首元素值，再将队首指针加1。

图3.6(a)所示为队列的初始状态，有Q.front  $= =$  Q.rear  $= = 0$  成立，该条件可以作为队列判空的条件。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/777522cfe1b01189f7f5daf95f4b6a4c5e2b4ed63e07556ce9f26a77465cda46.jpg)



(a) 空队


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e1e305ed3a09de59693ea704077b937d8ad6fe0e4380fd144cc0bc4d1c406e7e.jpg)



(b) 5 个元素入队


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8d4f9342d673bb4841b1f606ff3a9d7820ad4e1632b00333d7bbe71724d1153d.jpg)



(c) 出队1次


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a16d9094a62c82197fe7105ef0c5b2fd0cba1d7d3539256aa986d1fa98f531d6.jpg)



(d) 出队3次



图3.6 队列的操作


但能否用Q.rear  $= =$  MaxSize作为队列满的条件呢？显然不能，图3.6(d)中，队列中仅有一

个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在 data 数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。

# 2. 循环队列

上面指出了顺序队列“假溢出”的问题，这里引出循环队列的概念。将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法取模运算（%）来实现。

# 命题追踪 特定条件下循环队列队头/队尾指针的初值（2011）

初始时：Q.front=Q.rear=0。

队首指针进1：Q.front=(Q.front+1)%MaxSize。

队尾指针进1：Q.rear=(Q.rear+1)%MaxSize。

队列长度：(Q.rear+MaxSize-Q.front) %MaxSize。

出入队时：指针都按顺时针方向进1（如图3.7所示）。

# 命题追踪 特定条件下循环队列队空/队满的判断条件（2014）

那么，循环队列队空和队满的判断条件是什么呢？显然，队空的条件是Q.front  $= =$  Q.rear。若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图3.7(d1)所示，此时可以看出队满时也有Q.front  $= =$  Q.rear。循环队列出入队示意图如图3.7所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/18fb682e3634f757e2d100b60e228c7820ae34216ed15c6ab68c8c43de3a25b3.jpg)



(a) 初始空队


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/46abb0d0238554d4a965e000be9190d0714b7542154d45b781c8ec393d142db6.jpg)



(c) all队


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6427b626eed62f0c695b72b2d88383b3bf30776ef4b21f4fc42569eb69a6831d.jpg)



(d) d、e、f、g入队



（无法判断队满还是队空）


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/efd73d946c2545cd06c0ffaafadcbb7e8f878879dcb1447c7909bee9f5ebe3e0.jpg)



(d2) d、e、f入队



（牺牲一个存储单元）



图3.7 循环队列出入队示意图


为了区分是队空还是队满的情况，有三种处理方式：

1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队首指针在队尾指针的下一位置作为队满的标志”，如图3.7(d2)所示。

队满条件：(Q.rear+1)%MaxSize==Q.front。

队空条件：Q.front  $= =$  Q.rear。

队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。

2）类型中增设 size 数据成员，表示元素个数。若删除成功，则 size 减 1，若插入成功，

则 size 加 1，队空时 Q.size==0；队满时 Q.size==MaxSize，两种情况都有 Q.front==Q.rear。

3）类型中增设tag数据成员，以区分是队满还是队空。删除成功置tag=0，若导致Q.front==Q.rear，则为队空；插入成功置tag=1，若导致Q.front==Q.rear，则为队满。

# 3. 循环队列的操作

（1）初始化

```txt
void InitQueue (SqQueue &Q) { Q rear = Q.front = 0; //初始化队首、队尾指针
```

（2）判队空

```txt
bool isEmpty (SqQueue Q) { if(Q rear == Q.front) return true; else return false; }
```

（3）入队

```javascript
boolEnQueue(SqQueue&Q,ElemTypex){ if((Q.rear  $+1$  )%MaxSize  $\equiv =$  Q.front) //队满则报错 return false; Q.data[Q.rear]  $\equiv x$  · Q.rear  $\equiv$  (Q.rear  $+1$  %MaxSize; //队尾指针加1取模 return true;   
}
```

（4）出队

```txt
bool DeQueue (SqQueue &Q, ElemType &x) {
    if (Q.rear == Q.front) //队空则报错
        return false;
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize; //队首指针加1取模
    return true;
}
```

# 3.2.3 队列的链式存储结构

# 1. 队列的链式存储

# 命题追踪

# 根据需求分析队列适合的存储结构（2019）

队列的链式表示称为链式队列，它实际上是一个同时有队首指针和队尾指针的单链表，如图3.8所示。队首指针指向队头结点，队尾指针指向队尾结点，即单链表的最后一个结点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6fc9f9aebb22243f2de6714c894893c747eff209ab5283f8291a98181ba9cbee.jpg)



图3.8 不带队头结点的链式队列


队列的链式存储类型可描述为

```txt
typedef struct LinkNode{ //链式队列结点ElemType data;struct LinkNode \*next;}LinkNode;
```

```javascript
typedef struct{ //链式队列LinkNode \*front,\*rear; //队列的队头和队尾指针}LinkQueue;
```

不带头结点时，当Q.front  $= =$  NULL且Q.rear  $= =$  NULL时，链式队列为空。

# 命题追踪 链式队列队空的判断（2019）

入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q rear指向这个新插入的结点（若原队列为空队，则令Q.front也指向该结点)。出队时，首先判断队是否为空，若不空，则取出队首元素，将其从链表中删除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL)。

不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入和删除操作就统一了，如图3.9所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/66311f4711588b6cb0b23e1801f0bf776fa67938df9628f4a71694a392231063.jpg)



图3.9 带队头结点的链式队列


用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。

# 2.链式队列的基本操作

# 命题追踪 链式队列出队/入队操作的基本过程（2019）

（1）初始化

```javascript
void InitQueue(LinkQueue&Q){ //初始化带头结点的链式队列 Q.front=Q.rear=(LinkNode\*)malloc(sizeof(LinkNode));//建立头结点 Q.front->next=NULL; //初始为空 }
```

（2）判队空

```txt
bool IsEmpty(LinkQueue Q){ if(Q.front  $= =$  Q rear) //判空条件 return true; else return false; }
```

（3）入队

```txt
void EnQueue(LinkQueue &Q, ElemType x) {
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); //创建新结点
    s->data = x;
    s->next = NULL;
    Q.rear->next = s; //插入链尾
    Q.rear = s; //修改尾指针
}
```

（4）出队

```txt
bool DeQueue(LinkQueue &Q, ElemType &x) {
    if (Q.front == Q.rear)
        return false; //空队
```

```txt
LinkNode \*p=Q.front->next;   
 $\mathrm{x = p - > data}$  ·   
Q.front->next=p->next;   
if(Q.rear==p) Q.rear  $=$  Q.front; //若原队列中只有一个结点，删除后变空 free(p); return true;
```

# 3.2.4 双端队列

双端队列是指允许两端都可以进行插入和删除操作的线性表，如图3.10所示。双端队列两端的地位是平等的，为了方便理解，将左端也视为前端，右端也视为后端。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0e5bff8fdb48302043ece95961a2869abc3fe23761f45e7b8fc84dcb43d5c01e.jpg)



图3.10 双端队列


在双端队列入队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。思考：如何由入队序列  $a, b, c, d$  得到出队序列  $d, c, a, b$ ?

# 命题追踪 双端队列出队/入队操作模拟（2010、2021）

输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如图3.11所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e51db739ef27fcfb0ee1621571c1e70f01d48e36fcb96123c39ae624a8101788.jpg)



图3.11 输出受限的双端队列


输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列，如图3.12所示。若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ed11f02779e731dfe309b35325ed010b206f18f9a04565aff02b2a259eab8fc0.jpg)



图3.12 输入受限的双端队列


例 设有一个双端队列，输入序列为1,2,3,4，试分别求出以下条件的输出序列。

（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。

（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。

（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。

解：先看输入受限的双端队列，如图3.13所示。假设end1端输入1,2,3,4，则end2端的输出相当于队列的输出，即1,2,3,4；而end1端的输出相当于栈的输出，  $n = 4$  时仅通过end1端有14种输出序列（由Catalan公式得出），仅通过end1端不能得到的输出序列有  $4! - 14 = 10$  种：

<table><tr><td>1, 4, 2, 3</td><td>2, 4, 1, 3</td><td>3, 4, 1, 2</td><td>3, 1, 4, 2</td><td>3, 1, 2, 4</td></tr><tr><td>4, 3, 1, 2</td><td>4, 1, 3, 2</td><td>4, 2, 3, 1</td><td>4, 2, 1, 3</td><td>4, 1, 2, 3</td></tr></table>

通过end1和end2端混合输出，可以输出这10种中的8种，参看下表。其中， $S_{\mathrm{L}}, X_{\mathrm{L}}$  分别代表end1端的入队和出队， $X_{\mathrm{R}}$  代表end2端的出队。

<table><tr><td>输出序列</td><td>入队出队顺序</td><td>输出序列</td><td>入队出队顺序</td></tr><tr><td>1,4,2,3</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td><td>3,1,2,4</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td></tr><tr><td>2,4,1,3</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td><td>4,1,2,3</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td></tr><tr><td>3,4,1,2</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td><td>4,1,3,2</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}} \)</td></tr><tr><td>3,1,4,2</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}} \)</td><td>4,3,1,2</td><td>\( {\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{S}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{L}}{\mathrm{X}}_{\mathrm{R}}{\mathrm{X}}_{\mathrm{R}} \)</td></tr></table>

剩下两种是不能通过输入受限的双端队列输出的，即4,2,3,1和4,2,1,3。

再看输出受限的双端队列，如图3.14所示。假设end1端和end2端都能输入，仅end2端可以输出。若都从end2端输入，就是一个栈了。当输入序列为1,2,3,4时，输出序列有14种。对于其他10种不能得到的输出序列，交替从end1和end2端输入，还可以输出其中8种。设  $S_{\mathrm{L}}$  代表end1端的输入，  $S_{\mathrm{R}}$  、  $X_{\mathrm{R}}$  分别代表end2端的输入和输出，则可能的输出序列见下表。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bc019acb203d58aec8de9ce80df43cc19e2d2eaa51a84defe093dbb2946931ae.jpg)



图3.13 例题中输入受限的双端队列


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0b4ae0aef54ade3ef358aff3b08836592bb9d65d94038f0fc262103c8cecd28a.jpg)



图3.14 例题中输出受限的双端队列


<table><tr><td>输出序列</td><td>入队出队顺序</td><td>输出序列</td><td>入队出队顺序</td></tr><tr><td>1,4,2,3</td><td>SLXRSLSRXRVR</td><td>3,1,2,4</td><td>SLSLSRXRVRSLXRVR</td></tr><tr><td>2,4,1,3</td><td>SLSRXRSLSRXRVRXR</td><td>4,1,2,3</td><td>SLSLSRSLRXRVRXR</td></tr><tr><td>3,4,1,2</td><td>SLSLSRXRVRSRXRVRXR</td><td>4,2,1,3</td><td>SLSRSLSRXRVRXRVR</td></tr><tr><td>3,1,4,2</td><td>SLSLSRXRVRSRXRVRXR</td><td>4,3,1,2</td><td>SLSLSRSRXRVRXRVR</td></tr></table>

通过输出受限的双端队列不能得到的两种输出序列是4,1,3,2和4,2,3,1。

综上所述：

1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的是4,1,3,2。

2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的是4,2,1,3。

3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的是4,2,3,1。

# 提示

实际双端队列的考题不会这么复杂，通常仅判断序列是否满足题设条件，代入验证即可。

# 3.2.5 本节试题精选

# 一、单项选择题

01.栈和队列的主要区别在于（）。

A. 它们的逻辑结构不一样

B. 它们的存储结构不一样

C. 所包含的元素不一样

D. 插入、删除操作的限定不一样

02. 队列的“先进先出”特性是指（）。

I. 最后插入队列中的元素总是最后被删除

II. 当同时进行插入、删除操作时，总是插入操作优先

III. 每当有删除操作时，总要先做一次插入操作

IV. 每次从队列中删除的总是最早插入的元素

A. I

B. I 和 IV

C. II 和 III

D. IV

03. 允许对队列进行的操作有（）。

A. 对队列中的元素排序

B. 取出最近入队的元素

C. 在队列元素之间插入元素

D. 删除队首元素

04. 一个队列的入队顺序是1,2,3,4，则出队的输出顺序是（）。

A. 4,3,2,1

B. 1,2,3,4

C.  $1,4,3,2$

D. 3,2,4,1

05. 循环队列存储在数组 A[0...n] 中，入队时的操作为（）。

A. rear=rear+1

B. rear=(rear+1) mod (n-1)

C. rear=(rear+1) mod n

D. rear=(rear+1) mod (n+1)

06. 已知循环队列的存储空间为数组 A[21]，front 指向队首元素的前一个位置，rear 指向队尾元素，假设当前 front 和 rear 的值分别为 8 和 3，则该队列的长度为（）。

A. 5

B. 6

C. 16

D. 17

07. 若用数组 A[0...5] 实现循环队列，且当前 rear 和 front 的值分别为 1 和 5，当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为（）。

A. 3和4

B. 3和0

C. 5和0

D. 5和1

08. 假设用数组 Q[MaxSize] 实现循环队列，队首指针 front 指向队首元素的前一位置，队尾指针 rear 指向队尾元素，则判断该队列为空的条件是（）。

A. Q.rear  $= =$  (Q.front+1)%MaxSize

B. (Q.rear+1) %MaxSize==Q.front+1

C. (Q.rear+1) %MaxSize==Q.front

D. Q.rear  $= =$  Q.front

09. 假设循环队列 Q[MaxSize] 的队首指针为 front，队尾指针为 rear，队列的最大容量为 MaxSize，此外，该队列再没有其他数据成员，则判断该队列已满足条件是（）。

A. Q.front  $= =$  Q.rear

B. Q.front+Q.rear>=MaxSize

C. Q.front  $= = (Q.$  rear+1)%MaxSize

D. Q.rear  $= = (Q.$  front+1  $\%$  MaxSize

10. 假设用 A[0..n] 实现循环队列，front、rear 分别指向队首元素的前一个位置和队尾元素。若用 (rear+1) % (n+1) == front 作为队满标志，则（）。

A. 可用 front  $= =$  rear 作为队空标志

B. 队列中最多可有  $n + 1$  个元素

C. 可用 front>rear 作为队空标志

D. 可用  $(\text{front} + 1) \% (\text{n} + 1) ==$  rear 作为队空标志

11. 与顺序队列相比，链式队列的（）。

A. 优点是队列的长度不受限制

B. 优点是入队和出队时间效率更高

C. 缺点是不能进行顺序访问

D. 缺点是不能根据队首指针和队尾指针计算队列的长度

12. 下列描述的几种链表中，最适合用作队列的是（）。

A. 带队首指针和队尾指针的循环单链表

B. 带队首指针和队尾指针的非循环单链表

C. 只带队首指针的非循环单链表

D. 只带队首指针的循环单链表

13. 下列描述的几种链表中，最不适合用作链式队列的是（）。

A. 只带队首指针的非循环双链表

B. 只带队首指针的循环双链表

C. 只带队尾指针的循环双链表

D. 只带队尾指针的循环单链表

14. 在用单链表实现队列时，队头设在链表的（）位置。

A. 链头

B. 链尾

C. 链中

D. 以上都可以

15. 用链式存储方式的队列进行删除操作时需要（）。

A. 仅修改头指针

B. 仅修改尾指针

C. 头尾指针都要修改

D. 头尾指针可能都要修改

16. 在一个链式队列中，假设队首指针为 front，队尾指针为 rear，x 所指向的元素需要入队，则需要执行的操作为（）。

A. front=x, front=front->next

B.  $x->$  next  $\equiv$  front->next,front=x

C. rear->next=x, rear=x

D. rear->next=x, x->next=NULL, rear=x

17. 假设循环单链表表示的队列长度为  $n$ ，队头固定在链表尾，若只设头指针，则入队操作的时间复杂度为（）。

A.  $O(n)$

B.  $O(1)$

C.  $O(n^{2})$

D.  $O(n \log_2 n)$

18. 假设输入序列为 1,2,3,4,5，利用两个队列进行出入队操作，不可能输出的序列是（）。

A.  $1,2,3,4,5$

B. 5, 2, 3, 4, 1

C.  $1,3,2,4,5$

D.  $4,1,5,2,3$

19. 若以 1,2,3,4 作为双端队列的输入序列，则既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列是（）。

A.  $1,2,3,4$

B. 4,1,3,2

C. 4,2,3,1

D.  $4,2,1,3$

20.【2010统考真题】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素  $a, b, c, d, e$  依次入此队列后再进行出队操作，则不可能得到的出队序列是（）。

A.  $b, a, c, d, e$

B.  $d, b, a, c, e$

C.  $d, b, c, a, e$

D.  $e, c, b, a, d$

21.【2011统考真题】已知循环队列存储在一维数组A[0..n-1]中，且队列非空时front和rear分别指向队首元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（）。

A. 0, 0

B.  $0, n - 1$

C.  $n - 1,0$

D.  $n - 1, n - 1$

22.【2014统考真题】循环队列放在一维数组A[0...M-1]中，end1指向队首元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是（）。

A. 队空: end1==end2;

队满：  $\mathrm{end1} == (\mathrm{end2} + 1) \mod \mathrm{M}$

B. 队空：end1==end2;

队满：  $\mathrm{end2} == (\mathrm{end1} + 1)\mod (M - 1)$

C. 队空: end2 == (end1 + 1) mod M;

队满：  $\mathrm{end1} == (\mathrm{end2} + 1) \mod \mathrm{M}$

D. 队空: end1 == (end2 + 1) mod M;

队满：  $\mathrm{end2} == (\mathrm{end1} + 1)\mod (\mathrm{M - 1})$

23.【2018统考真题】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6（1在队头），S为空。若仅允许下列3种操作：①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是（）。

A.  $1,2,5,6,4,3$

B. 2, 3, 4, 5, 6, 1

C.  $3, 4, 5, 6, 1, 2$

D. 6,5,4,3,2,1

24.【2021统考真题】初始为空的队列Q的一端仅能进行入队操作，另外一端既能进行入队操作又能进行出队操作。若Q的入队序列是1,2,3,4,5，则不能得到的出队序列是（）。

A. 5,4,3,1,2

B. 5,3,1,2,4

C.  $4,2,1,3,5$

D. 4,1,3,2,5

# 二、综合应用题

01. 若希望循环队列中的元素都能得到利用，则需设置一个标志域 tag，并以 tag 的值为 0 或 1 来区分队首指针 front 和队尾指针 rear 相同时的队列状态是“空”还是“满”。试编写与此结构相应的入队和出队算法。

02. Q 是一个队列，S 是一个空栈，实现将队列中的元素逆置的算法。

03. 利用两个栈 S1 和 S2 来模拟一个队列，已知栈的 4 个运算定义如下：

```txt
Push(S,x); //元素  $\mathbf{x}$  入栈S  
Pop(S,x); //s出栈并将出栈的值赋给x  
StackEmpty(S); //判断栈是否为空  
StackOverflow(S); //判断栈是否为满
```

如何利用栈的运算来实现该队列的3个运算（形参由读者根据要求自己设计）？

```txt
Enqueue; //将元素  $\mathbf{x}$  入队  
Dequeue; //出队，并将出队元素存储在  $\mathbf{x}$  中  
QueueEmpty; //判断队列是否为空
```

04.【2019统考真题】请设计一个队列，要求满足：①初始时队列为空；②入队时，允许增加队列占用空间；③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；④入队操作和出队操作的时间复杂度始终保持为  $O(1)$  。请回答：

1）该队列是应选择链式存储结构，还是应选择顺序存储结构？

2）画出队列的初始状态，并给出判断队空和队满的条件。

3）画出第一个元素入队后的队列状态。

4）给出入队操作和出队操作的基本过程。

# 3.2.6 答案与解析

# 一、单项选择题

# 01. D

栈和队列的逻辑结构都是线性结构，都可以采用顺序存储或链式存储，选项C显然也错误。只有选项D才是栈和队列的本质区别，限定表中插入和删除操作位置的不同。

# 02. B

队列“先进先出”的特性表现在：先入队列的元素先出队列，后入队列的元素后出队列，入队对应的是插入操作，出队对应的是删除操作。选项I和IV均正确。

# 03. D

删除队首元素即出队，是队列的基本操作之一，所以选择选项D。

# 04.B

队列的入队顺序和出队顺序是一致的，这是和栈不同的。

# 05. D

数组下标范围为  $0\sim n$  ，因此数组容量为  $\mathrm{n + 1}$  。循环队列中元素入队的操作是rear=(rear+1)modmaxsize，题中maxsize=n+1。因此入队操作应为rear=(rear+1）mod(n+1)。

# 06.C

队列的长度为(rear-front+maxsize)%maxsize=(rear-front+21)%21=16。这种情

况和 front 指向当前元素，rear 指向队尾元素的下一个元素的计算是相同的。

# 注意

数组A[n]的下标范围为  $0\sim n - 1$  。若写成A[0...n]，则说明下标范围为  $0\sim n$

# 07. B

循环队列中，每删除一个元素，队首指针 front = (front + 1) % 6，每插入一个元素，队尾指针 rear = (rear + 1) % 6。上述操作后，front = 0，rear = 3。

# 08. D

当队列中只有一个元素时，front指向该元素的前一个位置，rear指向该元素，因此当队列为空时，队首指针等于队尾指针，这样一个元素入队后，才能符合题目要求。

# 09.C

既然不能附加任何其他数据成员，只能采用牺牲一个存储单元的方法来区分是队空还是队满，约定以“队列头指针在队尾指针的下一位置作为队满的标志”，因此选择选项C。选项A是判断队列是否空的条件，选项B和D都是干扰项。

# 注意

对于这类具体问题，举一些特例判断往往比直接思考问题能更快得到答案。

# 10. A

若用  $(\text{rear} + 1)\% (\text{n} + 1) == \text{front}$  作为队满标志，则说明题目采用了牺牲一个存储单元的方法来区分队空和队满，因此可用 front == rear 作为队空标志。

# 11. D

虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队列和链式队列的入队和出队时间复杂度均为  $O(1)$  。顺序队列和链式队列都可以进行顺序访问。对于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。

# 12. B

因为队列需在双端进行操作，所以选项C和D的链表显然不太适合链队。对于选项A，链表在完成入队和出队后还要修改为循环的，对于队列来讲这是多余的（画蛇添足）。对于选项B，因为有首指针，所以适合删除首结点；因为有队尾指针，所以适合在其后插入结点。

# 13. A

因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要  $O(n)$  的时间。选项B、C和D均可在  $O(1)$  的时间内找到队首和队尾。

# 14. A

因为在队头做出队操作，为便于删除队首元素，所以总是选择链头作为队头。

# 15. D

队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素，则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，需修改队尾指针为rear=front。

# 16. D

插入操作时，先将结点  $\mathbf{x}$  插入到链表尾部，再让rear指向这个结点  $\mathbf{x}$  。选项C的做法不够严密，因为是队尾，所以队尾  $\mathrm{x - > next}$  必须置为空。

# 17. A

依题意，入队操作是在队尾进行，即链表表头。题中已明确说明链表只设头指针，即没有头结点和尾指针，入队后，循环单链表必须保持循环的性质，在只带头指针的循环单链表中寻找表尾结点的时间复杂度为  $O(n)$ ，所以入队的时间复杂度为  $O(n)$ 。

# 18. B

此类题可对各选项进行模拟，假设队列为  $Q_{1}$  和  $Q_{2}$  。对于选项A，元素依次入队  $Q_{1}$ ，然后依次出队。对于选项B，5最先出队，只可能是1,2,3,4入队  $Q_{1}$ ，5入队  $Q_{2}$ ，然后5出队，只能得到5,1,2,3,4。对于选项C，1,2,5入队  $Q_{1}$ ，3,4入队  $Q_{2}$ ，然后按要求出队。选项D的分析同选项C。

# 19. C

使用排除法。先看可由输入受限的双端队列产生的序列：设右端输入受限，1,2,3,4依次左入，则依次左出可得4,3,2,1，排除选项A；左出、右出、左出、左出可得到4,1,3,2，排除选项B；再看可由输出受限的双端队列产生的序列：设右端输出受限，1,2,3,4依次左入、左入、右入、左入，依次左出可得到4,2,1,3，排除选项D。

# 20. C

本题的队列实际上是一个输出受限的双端队列，如图3.11所示。A操作：  $a$  左入（或右入）、 $b$  左入、 $c$  右入、 $d$  右入、 $e$  右入。B操作：  $a$  左入（或右入）、 $b$  左入、 $c$  右入、 $d$  左入、 $e$  右入。D操作：  $a$  左入（或右入）、 $b$  左入、 $c$  左入、 $d$  右入、 $e$  左入。C操作：  $a$  左入（或右入）、 $b$  右入、 $d$  未出，此时只能入队， $c$  怎么进都不可能在  $b$  和  $a$  之间。

【另解】初始时队列为空，第1个元素  $a$  左入（或右入）后，第2个元素  $b$  无论是左入还是右入都必与  $a$  相邻，而选项C中  $a$  与  $b$  不相邻，不合题意。

# 21. B

根据题意，第一个元素进入队列后存储在A[0]处，此时front和rear值都为0。入队时因为要执行  $(\text{rear} + 1)\% n$  操作，所以若入队后指针指向0，则rear初值为n-1，而因为第一个元素在A[0]中，插入操作只改变rear指针，所以front为0不变。

# 注意

① 循环队列是指顺序存储的队列，而不是指逻辑上的循环，如循环单链表表示的队列不能称为循环队列。② front 和 rear 的初值并不是固定的。

# 22. A

end1指向队首元素，可知出队操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，可知入队操作是先存数到A[end2]，然后end2再加1。若用A[0]存储第一个元素，则队列初始时，入队操作先把数据放到A[0]中，然后end2自增，即可知end2初值为0；而end1指向的是队首元素，队首元素在数组A中的下标为0，所以得知end1的初值也为0，可知队空条件为  $\mathrm{end1} == \mathrm{end2}$  ；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队首元素，可知  $\mathrm{end1} = 0$  ，end2指向队尾元素的后一个位置，可知  $\mathrm{end2} = \mathrm{M - 2 + 1} = \mathrm{M - 1}$  ，所以队满条件为  $\mathrm{end1} == (\mathrm{end2} + 1)\mod \mathrm{M}_{\circ}$

# 23. C

选项A的操作顺序为  $①①②②①①③③$  。选项B的操作顺序为  $②①①①①③$  。选项D的操作顺序为  $②②②②②①③③③③$  。对于选项C：首先输出3，说明1和2必须先依次入栈，而此后2肯定比1先输出，因此无法得到1,2的输出顺序。

# 24. D

假设队列左端允许入队和出队，右端只能入队。对于选项A，依次从右端入队1,2，再从左端入队3,4,5。对于选项B，从右端入队1,2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于选项C，从左端入队1,2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证选项D的序列。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cde2ae4fb37394d69544c81002b7c90e601d46963cbb08369d25d93b9d0b19c2.jpg)


# 二、综合应用题

# 01.【解答】

在循环队列的类型结构中，增设一个整型变量tag，入队时置tag为1，出队时置tag为0（因为只有入队操作可能导致队满，也只有出队操作可能导致队空）。队列Q初始时，置tag=0、front=rear=0。这样队列的4要素如下：

队空条件：Q.front  $= =$  Q.rear且Q.tag  $= = 0$

队满条件：Q.front  $= =$  Q.rear且Q.tag  $= = 1$

入队操作：Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; Q.tag=1。

出队操作：x=Q.data[Q.front]；Q.front=(Q.front+1)%MaxSize；Q.tag=0。

1）设“tag”法的循环队列入队算法：

```javascript
intEnQueue1(SqQueue&Q,ElemTypex){ if(Q.front  $= =$  Q.rear&&Q.tag  $\equiv = 1$  ） return0; //两个条件都满足时则队满 Q.data[Q.rear]  $\equiv x$  · Q.rear  $=$  (Q.rear+1)%MaxSize; Q.tag  $\equiv 1$  //可能队满 return1;   
}
```

2）设“tag”法的循环队列出队算法：

```javascript
int DeQueue1(SqQueue &Q, ElemType &x) {
    if (Q.front == Q.rear && Q.tag == 0)
        return 0; //两个条件都满足时则队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    Q.tag = 0; //可能队空
    return 1;
}
```

# 02.【解答】

本题主要考查大家对队列和栈的特性与操作的理解。因为对队列的一系列操作不可能将其中的元素逆置，而栈可以将入栈的元素逆序提取出来，所以我们可以让队列中的元素逐个地出队，入栈；全部入栈后再逐个出栈，入队。

算法的实现如下：

```txt
void Inverter(Stack &S, Queue &Q) {
//本算法实现将队列中的元素逆置
while (!QueueEmpty(Q)) {
    x = DeQueue(Q); //队列中全部元素依次出队
    Push(S, x); //元素依次入栈
} while (!StackEmpty(S)) {
    Pop(S, x); //栈中全部元素依次出栈
```

```javascript
EnQueue(Q,x）; //再入队}
```

# 03.【解答】

利用两个栈 S1 和 S2 来模拟一个队列，当需要向队列中插入一个元素时，用 S1 来存放已输入的元素，即 S1 执行入栈操作。当需要出队时，则对 S2 执行出栈操作。因为从栈中取出元素的顺序是原顺序的逆序，所以必须先将 S1 中的所有元素全部出栈并入栈到 S2 中，再在 S2 中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断 S2 是否为空，否则会导致顺序混乱。当栈 S1 和 S2 都为空时队列为空。

# 总结如下：

1）对S2的出栈操作作用作出队，若S2为空，则先将S1中的所有元素送入S2。

2）对S1的入栈操作作用作入队，若S1满，必须先保证S2为空，才能将S1中的元素全部插入S2中。

# 入队算法：

```javascript
intEnQueue(Stack&S1,Stack&S2,ElemTypee){ if(!StackOverflow(S1)){ Push(S1,e); return 1; } if(StackOverflow(S1)&&!StackEmpty(S2)){ printf("队列为满"); return 0; } if(StackOverflow(S1)&&!StackEmpty(S2)){ while(!StackEmpty(S1)){ Pop(S1,x); Push(S2,x); } } Push(S1,e); return 1;
```

# 出队算法：

```txt
void DeQueue(Stack &S1,Stack &S2,ElemType &x){ if(!StackEmpty(S2)){ Pop(S2,x); } else if(StackEmpty(S1)){ printf("队列为空"); } else{ while(!StackEmpty(S1)){ Pop(S1,x); Push(S2,x); } Pop(S2,x); }
```

# 判断队列为空的算法：

```txt
int QueueEmpty(Stack S1,Stack S2){ if(StackEmpty(S1)&&&StackEmpty(S2)) return 1; else return 0; }
```

# 04.【解答】

1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不真正释放，用队首指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作和出队操作的时间复杂度均为  $O(1)$ ，要求④可以满足。因此，采用链式存储结构（两段式单向循环链表），队首指针为front，队尾指针为rear。

2）该循环链式队列的实现可以参考循环队列，不同之处在于循环链式队列可以方便地增加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空结点的循环单链表，头指针 front 和尾指针 rear 均指向空结点，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c8a77fcae493bb096aa85a036bdae5e3d958278eac4ef55f1f7a7fe56a4e34ad.jpg)


队空的判定条件：front==rear。

队满的判定条件：front==rear->next。

3）插入第一个元素后的状态如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ca18a3286546b5b6ce7eaa64b53be0ac976005fcc0c2e292dca79d7ebeed4b15.jpg)


4）操作的基本过程如下：

<table><tr><td>入队操作:</td></tr><tr><td>若 (front==rear-&gt;next) //队满则在rear后面插入一个新的空闲结点;入队元素保存到rear所指结点中; rear=rear-&gt;next; 返回。</td></tr><tr><td>出队操作:</td></tr><tr><td>若 (front==rear) //队空则出队失败,返回;取front所指结点中的元素e; front=front-&gt;next; 返回e。</td></tr></table>

# 3.3 栈和队列的应用

要熟练掌握栈和队列，必须学习栈和队列的应用，把握其中的规律，然后举一反三。接下来将简单介绍栈和队列的一些常见应用。

# 3.3.1 栈在括号匹配中的应用

假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序任意即（[]（）或[（[][]）]等均为正确的格式，[（）或（[]）或（（）]均为不正确的格式。

考虑下列括号序列：

<table><tr><td>[</td><td>(</td><td>[</td><td>]</td><td>[</td><td>]</td><td>)</td><td>]</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr></table>

分析如下：

1）计算机接收第1个括号“[”后，期待与之匹配的第8个括号“]”出现。

2）获得了第2个括号“（”，此时第1个括号“[”暂时放在一边，而急迫期待与之匹配的第7个括号“）”出现。

3）获得了第3个括号“[”，此时第2个括号“（”暂时放在一边，而急迫期待与之匹配的第4个括号“]”出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又成为当前最急迫的任务。

4）以此类推，可见该处理过程与栈的思想吻合。

算法的思想如下：

1）初始设置一个空栈，顺序读入括号。

2）若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的栈中所有未消解的期待的急迫性降了一级。

3）若是右括号，则或使置于栈顶的最急迫期待得以消解，或是不合法的情况（括号序列不匹配，退出程序）。算法结束时，栈为空，否则括号序列不匹配。

# 3.3.2 栈在表达式求值中的应用

表达式求值是程序设计语言编译中一个最基本的问题，它是栈应用的一个典型范例。

# 1.算术表达式

中缀表达式（如  $3 + 4$  ）是人们常用的算术表达式，操作符以中缀形式处于操作数的中间。与前缀表达式（如  $+34$  ）或后缀表达式（如  $34+$  ）相比，中缀表达式不容易被计算机解析，但仍被许多程序语言使用，因为它更符合人们的思维习惯。

与前缀表达式或后缀表达式不同的是，中缀表达式中的括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。后缀表达式的运算符在操作数后面，后缀表达式中考虑了运算符的优先级，没有括号，只有操作数和运算符。

中缀表达式  $\mathrm{A + B^{\star}(C - D) - E / F}$  对应的后缀表达式为ABCD-  $^ { \text{一} } { \text{十} } { \text{一} } { \text{十} }$  EF/，将后缀表达式与原表达式对应的表达式树（图3.15）的后序遍历序列进行比较，可发现它们有异曲同工之妙。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d2e8b2e6f485469d93a06f31aede22fe9f280ccd333165856670bc81291100aa.jpg)



图3.15  $\mathrm{A} + \mathrm{B}^{\star}$  (C-D)-E/F对应的表达式树


# 2. 中缀表达式转后缀表达式

# 命题追踪 中缀表达式转后缀表达式的方法（2024）

下面先给出一种由中缀表达式转后缀表达式①的手算方法。

1）按照运算符的运算顺序对所有运算单位加括号。

2）将运算符移至对应括号的后面，相当于按“左操作数 右操作数 运算符”重新组合。

3）去除所有括号。

例如，中缀表达式  $\mathrm{A} + \mathrm{B}^{\star}(\mathrm{C} - \mathrm{D}) - \mathrm{E} / \mathrm{F}$  转后缀表达的过程如下（下标表示运算符的运算顺序）：

1）加括号：  $(\mathrm{(A + }_{\text{③}}(\mathrm{B}^{\star}_{\text{②}}(\mathrm{C - }_{\text{①}}\mathrm{D})) - }_{\text{⑤}}(\mathrm{E / }_{\text{④}}\mathrm{F}))$  。

2）运算符后移：  $(\mathrm{A}(\mathrm{B}(\mathrm{CD}) - {}_{(1)})^{\star}_{(2)}) + {}_{(3)}(\mathrm{EF}) / {}_{(4)}) - {}_{(5)}$

3）去除括号后，得到后缀表达式：ABCD-①+③EF/④-⑤。

在计算机中，中缀表达式转后缀表达式时需要借助一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右依次扫描中缀表达式中的每一项，具体转化过程如下：

1）遇到操作数。直接加入后缀表达式。

2）遇到界限符。若为“（”，则直接入栈；若为“）”，则不入栈，且依次弹出栈中的运算符并加入后缀表达式，直到遇到“（”为止，并直接删除“（”。

3）遇到运算符。① 若其优先级高于栈顶运算符或遇到栈顶为“（”，则直接入栈；② 若其优先级低于或等于栈顶运算符，则依次弹出栈中的运算符并加入后缀表达式，直到遇到一个优先级低于它的运算符或遇到“（”或栈空为止，之后将当前运算符入栈。

按上述方法扫描所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

例如，中缀表达式  $\mathrm{A} + \mathrm{B}^{\star}(\mathrm{C} - \mathrm{D}) - \mathrm{E} / \mathrm{F}$  转后缀表达式的过程如表3.1所示。


表 3.1 中缀表达式  $\mathbf{A} + \mathbf{B} \star  \left( {\mathbf{C} - \mathbf{D}}\right)  - \mathbf{E}/\mathbf{F}$  转后缀表达式的过程


<table><tr><td>步</td><td>待处理序列</td><td>栈内</td><td>后缀表达式</td><td>扫描项</td><td>说 明</td></tr><tr><td>1</td><td>\( \mathrm{A} + \mathrm{B} * \left( {\mathrm{C} - \mathrm{D}}\right)  - \mathrm{E}/\mathrm{F} \)</td><td></td><td></td><td>A</td><td>A 加入后缀表达式</td></tr><tr><td>2</td><td>\( + \mathrm{B} * \left( {\mathrm{C} - \mathrm{D}}\right)  - \mathrm{E}/\mathrm{F} \)</td><td></td><td>A</td><td>+</td><td>+入栈</td></tr><tr><td>3</td><td>\( \mathrm{B} * \left( {\mathrm{C} - \mathrm{D}}\right)  - \mathrm{E}/\mathrm{F} \)</td><td>+</td><td>A</td><td>B</td><td>B 加入后缀表达式</td></tr><tr><td>4</td><td>* (C-D) \( - \mathrm{E}/\mathrm{F} \)</td><td>+</td><td>AB</td><td>✘</td><td>*优先级高于栈顶,*入栈</td></tr><tr><td>5</td><td>(C-D)-E/F</td><td>* *</td><td>AB</td><td>(</td><td>(直接入栈</td></tr><tr><td>6</td><td>C-D)-E/F</td><td>++ (</td><td>AB</td><td>C</td><td>C 加入后缀表达式</td></tr><tr><td>7</td><td>-D)-E/F</td><td>++ (</td><td>ABC</td><td>-</td><td>栈顶为 \( \left( {, - }\right. \) 直接入栈</td></tr><tr><td>8</td><td>D)-E/F</td><td>++ (-</td><td>ABC</td><td>D</td><td>D 加入后缀表达式</td></tr><tr><td>9</td><td>)-E/F</td><td>++ (-</td><td>ABCD</td><td>)</td><td>遇到),弹出-,删除(</td></tr><tr><td>10</td><td>-E/F</td><td>* *</td><td>ABCD-</td><td>-</td><td>-优先级低于栈顶,依次弹出*、+, -入栈</td></tr><tr><td>11</td><td>E/F</td><td>-</td><td>ABCD-*+</td><td>E</td><td>E 加入后缀表达式</td></tr><tr><td>12</td><td>/F</td><td>-</td><td>ABCD- *+E</td><td>/</td><td>/优先级高于栈顶,/入栈</td></tr><tr><td>13</td><td>F</td><td>- /</td><td>ABCD- *+E</td><td>F</td><td>F 加入后缀表达式</td></tr><tr><td>14</td><td></td><td>- /</td><td>ABCD- *+EF</td><td></td><td>字符扫描完毕, 弹出剩余运算符</td></tr><tr><td></td><td></td><td></td><td>ABCD- *+EF/-</td><td></td><td>结束</td></tr></table>

# 命题追踪 栈的深度分析（2009、2012）

所谓栈的深度，是指栈中的元素个数，通常是给出入栈和出栈序列，求最大深度（栈的容量应大于或等于最大深度）。有时会间接给出入栈和出栈序列，例如以中缀表达式和后缀表达式的形式给出入栈和出栈序列。掌握栈的先进后出的特点进行手工模拟是解决这类问题的有效方法。

# 3. 后缀表达式求值

# 命题追踪 用栈实现表达式求值的分析（2018）

通过后缀表示计算表达式值的过程：从左往右依次扫描表达式的每一项，若该项是操作数，

则将其压入栈中；若该项是操作符  $<\mathrm{op}>$ ，则从栈中退出两个操作数Y和X，形成运算指令  $\mathrm{X}<\mathrm{op}>\mathrm{Y}$  并将计算结果压入栈中。当所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。

例如，后缀表达式ABCD-  $\star +\mathrm{EF} / -$  求值的过程需要12步，见表3.2。


表 3.2 后缀表达式  $\mathrm{{ABCD}} -  *  + \mathrm{{EF}}/ -$  求值的过程


<table><tr><td>步</td><td>扫 描 项</td><td>项 类 型</td><td>动 作</td><td>栈中内容</td></tr><tr><td>1</td><td></td><td></td><td>置空栈</td><td>空</td></tr><tr><td>2</td><td>A</td><td>操作数</td><td>入栈</td><td>A</td></tr><tr><td>3</td><td>B</td><td>操作数</td><td>入栈</td><td>A B</td></tr><tr><td>4</td><td>C</td><td>操作数</td><td>入栈</td><td>A B C</td></tr><tr><td>5</td><td>D</td><td>操作数</td><td>入栈</td><td>A B C D</td></tr><tr><td>6</td><td>-</td><td>操作符</td><td>D、C 出栈, 计算 \( \mathrm{C} - \mathrm{D} \) ,结果 \( {\mathrm{R}}_{1} \) 入栈</td><td>\( \mathrm{A}\;\mathrm{B}\;\mathrm{R}1 \)</td></tr><tr><td>7</td><td>*</td><td>操作符</td><td>\( {\mathrm{R}}_{1} \) 、 \( \mathrm{B} \) 出栈,计算 \( \mathrm{B} \times  {\mathrm{R}}_{1} \) ,结果 \( {\mathrm{R}}_{2} \) 入栈</td><td>\( \mathrm{A}\;{\mathrm{R}}_{2} \)</td></tr><tr><td>8</td><td>+</td><td>操作符</td><td>\( {\mathrm{R}}_{2} \) 、 \( \mathrm{A} \) 出栈,计算 \( \mathrm{A} + {\mathrm{R}}_{2} \) ,结果 \( {\mathrm{R}}_{3} \) 入栈</td><td>\( {\mathrm{R}}_{3} \)</td></tr><tr><td>9</td><td>E</td><td>操作数</td><td>入栈</td><td>\( {\mathrm{R}}_{3}\;\mathrm{E} \)</td></tr><tr><td>10</td><td>F</td><td>操作数</td><td>入栈</td><td>\( {\mathrm{R}}_{3}\;\mathrm{E}\;\mathrm{F} \)</td></tr><tr><td>11</td><td>/</td><td>操作符</td><td>\( \mathrm{F} \) 、 \( \mathrm{E} \) 出栈,计算 \( \mathrm{E}/\mathrm{F} \) ,结果 \( {\mathrm{R}}_{4} \) 入栈</td><td>\( {\mathrm{R}}_{3}\;{\mathrm{R}}_{4} \)</td></tr><tr><td>12</td><td>-</td><td>操作符</td><td>\( {\mathrm{R}}_{4} \) 、 \( {\mathrm{R}}_{3} \) 出栈,计算 \( {\mathrm{R}}_{3} - {\mathrm{R}}_{4} \) ,结果 \( {\mathrm{R}}_{5} \) 入栈</td><td>\( {\mathrm{R}}_{5} \)</td></tr></table>

# 3.3.3 栈在递归中的应用

递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。

递归通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。但在通常情况下，它的效率并不是太高。

以斐波那契数列为例，其定义为

$$
F (n) = \left\{ \begin{array}{l l} F (n - 1) + F (n - 2), & n > 1 \\ 1, & n = 1 \\ 0, & n = 0 \end{array} \right.
$$

这就是递归的一个典型例子，用程序实现时如下：

```c
int F(int n){ //斐波那契数列的实现if  $(n = = 0)$  return 0; //边界条件else if  $(n = = 1)$  return 1; //边界条件elsereturn  $F(n - 1) + F(n - 2)$  //递归表达式}
```

必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：

- 递归表达式（递归体）。

- 边界条件（递归出口）。

递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。

# 命题追踪 栈在函数调用中的作用和工作原理（2015、2017）

在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很

多重复的计算。下面以  $n = 5$  为例，列出递归调用执行过程，如图3.16所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b346e75c18331721499b0f63fc754dfb86666bfadee601b5cc8d4a04963db7df.jpg)



图3.16 F(5)的递归执行过程


显然，在递归调用的过程中，F(3)被计算2次，F(2)被计算3次。F(1)被调用5次，F(0)被调用3次。所以，递归的效率低下，但优点是代码简单，容易理解。在第5章的树中利用了递归的思想，代码变得十分简单。通常情况下，初学者很难理解递归的调用过程，若读者想具体了解递归是如何实现的，可以参阅编译原理教材中的相关内容。

可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。

# 3.3.4 队列在层次遍历中的应用

在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树（见图3.17）层次遍历的例子，说明队列的应用。表3.3显示了层次遍历二叉树的过程。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ae49761d77565a64cfcd502e3ef1c6e65f71f1517ece5d1a5428601b0f0e6dd0.jpg)



图3.17 二叉树



表 3.3 层次遍历二叉树的过程


<table><tr><td>序</td><td>说 明</td><td>队内</td><td>队 外</td></tr><tr><td>1</td><td>\( A \) 入</td><td>\( A \)</td><td></td></tr><tr><td>2</td><td>\( A \) 出, \( {BC} \) 入</td><td>\( {BC} \)</td><td>\( A \)</td></tr><tr><td>3</td><td>\( B \) 出, \( D \) 入</td><td>\( {CD} \)</td><td>\( {AB} \)</td></tr><tr><td>4</td><td>\( C \) 出, \( {EF} \) 入</td><td>DEF</td><td>\( {ABC} \)</td></tr><tr><td>5</td><td>\( D \) 出, \( G \) 入</td><td>EFG</td><td>ABCD</td></tr><tr><td>6</td><td>\( E \) 出, \( {HI} \) 入</td><td>FGHI</td><td>ABCDE</td></tr><tr><td>7</td><td>\( F \) 出</td><td>GHI</td><td>ABCDEF</td></tr><tr><td>8</td><td>GHI 出</td><td></td><td>ABCDEFGHI</td></tr></table>

该过程的简单描述如下：

① 根结点入队。

② 若队空（所有结点都已处理完毕），则结束遍历；否则重复③操作。

③ 队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回②。

# 3.3.5 队列在计算机系统中的应用

队列在计算机系统中的应用非常广泛，以下仅从两个方面来阐述：第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。

# 命题追踪 缓冲区的逻辑结构（2009）

对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，因为速度不匹配，若直接把输出的数据送给打印机打印，则显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。

# 命题追踪 多队列出队/入队操作的应用（2016）

对于第二个方面，CPU（中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU能够正常运行。

# 3.3.6 本节试题精选

# 一、单项选择题

01.栈的应用不包括（）。

A. 递归

B. 表达式求值

C. 括号匹配

D. 缓冲区

02. 表达式  $a * (b + c) - d$  的后缀表达式是（）。

A. abcd\*+--

B. abc+*d-

C. abc\*+d-

D.  $- + * a b c d$

03. 下面（）用到了队列。

A. 括号匹配

B. 表达式求值

C. 递归

D. FIFO页面替换算法

04. 利用栈求表达式的值时，设立运算数栈 OPEN。假设 OPEN 只有两个存储单元，则在下列表达式中，不会发生溢出的是（）。

A.  $\mathrm{A - B}*(\mathrm{C - D})$

B. (A-B) *C-D

C. (A-B*C)-D

D. (A-B) * (C-D)

05. 执行完下列语句段后， $i$  的值为（）。

```txt
int f(int x){ return  $(\mathrm{x} > 0)?\mathrm{x}^{\star}\mathrm{f}(\mathrm{x} - 1):2)$  ·   
}   
int i;   
 $\mathrm{i = f(f(1))}$
```

A. 2

B. 4

C. 8

D. 无限递归

06. 设有如下递归函数，则计算 F(8) 需要调用该递归函数的次数为（）。

```c
int F(int n){ if  $(\mathrm{n} <   = 3)$  return 1; else return  $F(n - 2) + F(n - 4) + 1$
```

A. 7

B. 8

C. 9

D. 10

07. 设有如下递归函数，在 funcfunc(5)) 的执行过程中，第 4 个被执行的 func 函数是（）。

```txt
int func(int x){ if  $(\mathrm{x} <   = 3)$  return 2; else return func  $(\mathbf{x} - 2) +$  func  $(x - 4)$  .
```

A. func(2)

B. func(3)

C. func(4)

D. func(5)

08. 对于一个问题的递归算法求解和其相对应的非递归算法求解，（）。

A. 递归算法通常效率高一些

B. 非递归算法通常效率高一些

C. 两者相同

D. 无法比较

09. 执行函数时，其局部变量一般采用（）进行存储。

A. 树形结构

B. 静态链表

C. 栈结构

D. 队列结构

10. 执行（）操作时，需要使用队列作为辅助存储空间。

A. 查找散列（哈希）表

B. 广度优先搜索图

C. 前序（根）遍历二叉树

D. 深度优先搜索图

11. 下列说法中，正确的是（）。

A. 消除递归不一定需要使用栈

B. 对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同

C. 通常使用队列来处理函数或过程调用

D. 队列和栈都是运算受限的线性表, 只允许在表的两端进行运算

12.【2009统考真题】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（）。

A. 栈

B. 队列

C. 树

D. 图

13.【2012统考真题】已知操作符包括“+”“-”“*”“/”“（”和“）”。将中缀表达式 $a + b - a^{*}((c + d) / e - f) + g$ 转换为等价的后缀表达式  $ab + acd + e / f - * - g+$  时，用栈来存放暂时还不能确定运算次序的操作符。栈初始时为空时，转换过程中同时保存在栈中的操作符的最大个数是（）。

A. 5

B. 7

C. 8

D. 11

14.【2014统考真题】假设栈初始为空，将中缀表达式  $a / b + (c^* d - e^* f) / g$  转换为等价的后缀表达式的过程中，当扫描到f时，栈中的元素依次是（）。

A.  $+ \left( {{}^{ \star  } - }\right)$

B.  $+(-\star$

C.  $/ + \left( {\star  - \star }\right)$

D. /+-

15.【2015统考真题】已知程序如下：

```c
int S(int n)  
{ return  $(n<=0)?0:S(n-1)+n;$  }  
void main()  
{ cout<<S(1);}
```

程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是（）。

A. main()  $\rightarrow$  S(1)  $\rightarrow$  S(0)

B. S(0)  $\rightarrow$  S(1)  $\rightarrow$  main()

C. main()  $\rightarrow$  S(0)  $\rightarrow$  S(1)

D. S(1)  $\rightarrow$  S(0)  $\rightarrow$  main()

16.【2016统考真题】设有如下图所示的火车车轨，入口和出口之间有  $n$  条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为  $1\sim 9$  的9列列车，驶入的次序依次是8,4,2,5,3,9,1,6,7。若期望驶出的次序依次为  $1\sim 9$  ，则  $n$  至少是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/be813eb10b96da6cf2a31a2a06cf967d2fb875bc9a3c442b472a85303d7a7033.jpg)


A. 2

B. 3

C. 4

D. 5

17.【2017统考真题】下列关于栈的叙述中，错误的是（）。

I. 采用非递归方式重写递归程序时必须使用栈

II. 函数调用时，系统要用栈保存必要的信息

III. 只要确定了入栈次序，即可确定出栈次序

IV. 栈是一种受限的线性表，允许在其两端进行操作

A. 仅 I

B. 仅 I、II、III

C. 仅 I、III、IV

D. 仅 II、III、IV

18.【2018统考真题】若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作：

1）从S1中依次弹出两个操作数a和b。

2）从S2中弹出一个运算符op。

3）执行相应的运算b op a。

4）将运算结果压入S1中。

假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*、-、+（+在栈顶）。调用3次F()后，S1栈顶保存的值是（）。

A. -15

B. 15

C. -20

D. 20

19.【2024统考真题】与表达式  $x + y^{*}(z - u) / v$  等价的后缀表达式是（）。

A.  $xyzu^{-*}v / +$

B.  $xyzu - v^{* + }$

C.  $+x / * y - zuv$

D.  $+x^{*}y / -zuv$

# 二、综合应用题

01. 假设一个算术表达式中包含圆括号、方括号和花括号3种类型的括号，编写一个算法来判别表达式中的括号是否配对，以字符“\0”作为算术表达式的结束符。

# 3.3.7 答案与解析

# 一、单项选择题

01. D

缓冲区是用队列实现的，选项A、B、C都是栈的典型应用。

02. B

后缀表达式中，每个运算符均直接位于其两个操作数的后面，按照这样的方式逐步根据计算的优先级将每个计算式进行变换，即可得到后缀表达式。

【另解】将两个直接操作数用括号括起来，再将操作符提到括号后，最后去掉括号。例如，

对于  $(1)(2)a^{\star}(3b + c) - d)$ ，提出操作符并去掉括号后，可得后缀表达式为  $abc + \ast d -$ 。

学完第5章后，可将表达式画成二叉树的形式，再用后序遍历即可求得后缀表达式。

# 03. D

FIFO页面替换算法用到了队列。其余的都只用到了栈。

# 04.B

利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，B入栈，计算得R1，C入栈，计算得R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D依次计算得栈深为4、3、3。因此选择选项B。

# 技巧

根据运算符优先级，统计已依次入栈但还未参与计算的运算符的个数。以选项C为例，当“（”“A”“-”入栈时，“(”和“-”还未参与运算，此时运算符栈大小为2，“B”和“*”入栈时运算符大小为3，“C”入栈时“B*C”运算，运算符栈大小为2，以此类推。

# 05. B

栈与递归有着紧密的联系。递归模型包括递归出口和递归体两个方面。递归出口是递归算法的出口，即终止递归的条件。递归体是一个递推的关系式。根据题意有

$$
\begin{array}{l} f (0) = 2; \\ f (1) = 1 ^ {\star} f (0) = 2; \\ f (f (1)) = f (2) = 2 * f (1) = 4 。 \\ \end{array}
$$

# 06.C

计算  $F(8)$  的递归调用树如下图所示：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7dbf18acaee5a5953b06ba6c82bfb1f9d21e5d5018630ef624c444c4cf8ac419.jpg)


由图可知，递归函数  $F()$  调用的次数为9。

# 07. C

首先，执行内层参数 func(5) = func(3) + func(1) = 4，共执行 3 次 func 函数。然后，执行 func func(5)) = func(4) = func(2) + func(0) = 4，因此第 4 个被执行的 func 函数是 func(4)。也可以采用画出递归调用树的方式，即某个函数的执行次序等于其在递归调用树的先序遍历中的次序。

# 08. B

通常情况下，递归算法在计算机实际执行的过程中包含很多的重复计算，所以效率会低。

# 09.C

调用函数时，系统会为调用者构造一个由参数表和返回地址组成的活动记录，并将记录压入系统提供的栈中，若被调用函数有局部变量，也要压入栈中。

# 10. B

本题涉及第5章和第6章的内容，图的广度优先搜索类似于树的层序遍历，都要借助于队列。

# 11. A

使用栈可以模拟递归的过程，以此来消除递归，但对于单向递归和尾递归而言，可以用迭代的方式来消除递归，选项A正确。不同的入栈和出栈组合操作，会产生许多不同的输出序列，B

错误。通常使用栈来处理函数或过程调用，选项C错误。队列和栈都是操作受限的线性表，但只有队列允许在表的两端进行运算，而栈只允许在栈顶方向进行操作，选项D错误。

# 12. B

在提取数据时必须保持原来数据的顺序，所以缓冲区的特性是先进先出。

# 13. A

在中缀表达式转后缀表达式的过程中，扫描到操作数时直接输出，扫描到操作符时根据其优先级进行相应的出入栈操作。有几点需要注意：①若遇到界限符“（”，则直接入栈；②若遇到界限符“）”，则不入栈，且依次弹出栈顶运算符，直到遇到“（”为止，并删除“（”；③若当前运算符的优先级高于栈顶运算符或遇到栈顶为“（”，则直接入栈；④若当前运算符的优先级低于或等于栈顶运算符，则依次弹出栈中的运算符并加入后缀表达式，直到遇到一个优先级低于它的运算符或遇到“（”或栈空为止，之后将当前运算符入栈。

求栈中操作符的最大个数时，为简单起见，可省略对操作数的处理。

<table><tr><td>步</td><td>待处理运算符</td><td>栈</td><td>扫描运算符</td><td>动 作</td></tr><tr><td>1</td><td>+b-a* ((c+d) /e-f) +g</td><td></td><td>+</td><td>+入栈</td></tr><tr><td>2</td><td>\( - {\mathrm{a}}^{ * }\left( {\left( {\mathrm{c} + \mathrm{d}}\right) /\mathrm{e} - \mathrm{f}}\right)  + \mathrm{g} \)</td><td>+</td><td>-</td><td>-优先级等于栈顶+, 弹出+, -入栈</td></tr><tr><td>3</td><td>* ((c+d) /e-f) +g</td><td>-</td><td>★</td><td>*优先级高于栈顶-, *入栈</td></tr><tr><td>4</td><td>((c+d)/e-f)+g</td><td>- \( {}^{ \star  } \)</td><td>(</td><td>(直接入栈</td></tr><tr><td>5</td><td>(c+d)/e-f)+g</td><td>- \( {}^{ \star  } \) (</td><td>(</td><td>(直接入栈</td></tr><tr><td>6</td><td>+d)/e-f)+g</td><td>-*( (</td><td>+</td><td>栈顶为 \( \left( {, + \text{直接入栈}}\right) \)</td></tr><tr><td>7</td><td>)/e-f)+g</td><td>- \( {}^{ \star  }\left( (+\right. \)</td><td>)</td><td>遇到),弹出+,删除(</td></tr><tr><td>8</td><td>/e-f)+g</td><td>- \( {}^{ \star  } \) (</td><td>/</td><td>栈顶为 \( \left( {,/\text{直接入栈}}\right) \)</td></tr><tr><td>10</td><td>-f)+g</td><td>-*(/</td><td>-</td><td>-优先级低于栈顶/,弹出/, -入栈</td></tr><tr><td>11</td><td>) +g</td><td>- \( {}^{ \star  }\left( {-\text{ }}\right. \)</td><td>)</td><td>遇到),弹出-,删除(</td></tr><tr><td>12</td><td>+g</td><td>- \( {}^{ \star  } \)</td><td>+</td><td>+优先级低于栈顶*,等于-,依次弹出*和-；+入栈</td></tr><tr><td>13</td><td></td><td>+</td><td></td><td></td></tr></table>

由上述过程可知，栈中操作符的最大个数为5。

# 14. B

中缀表达式  $a / b + (c^{\star}d - e^{\star}f) / g$  转换为后缀表达式的过程如下：

<table><tr><td>步</td><td>待处理序列</td><td>栈</td><td>后缀表达式</td><td>扫描项</td><td>动 作</td></tr><tr><td>1</td><td>\( \mathrm{a}/\mathrm{b} + \left( {\mathrm{c} * \mathrm{d} - \mathrm{e} * \mathrm{f}}\right) /\mathrm{g} \)</td><td></td><td></td><td>a</td><td>a 加入后缀表达式</td></tr><tr><td>2</td><td>\( \mathrm{b} + \left( {\mathrm{c} * \mathrm{d} - \mathrm{e} * \mathrm{f}}\right) /\mathrm{g} \)</td><td></td><td>a</td><td>/</td><td>/入栈</td></tr><tr><td>3</td><td>\( \mathrm{b} + \left( {\mathrm{c} * \mathrm{d} - \mathrm{e} * \mathrm{f}}\right) /\mathrm{g} \)</td><td>/</td><td>a</td><td>b</td><td>b 加入后缀表达式</td></tr><tr><td>4</td><td>+(c*d-e*f)/g</td><td>/</td><td>ab</td><td>+</td><td>+优先级低于栈顶的/,弹出/,+入栈</td></tr><tr><td>5</td><td>(c*d-e*f)/g</td><td>+</td><td>ab/</td><td>(</td><td>(入栈</td></tr><tr><td>6</td><td>c*d-e*f)/g</td><td>+(</td><td>ab/</td><td>C</td><td>c 加入后缀表达式</td></tr><tr><td>7</td><td>* \( \mathrm{d} - \mathrm{e} * \mathrm{f} \) )/ \( \mathrm{g} \)</td><td>+(</td><td>ab/c</td><td>✘</td><td>栈顶为 \( \left( {, * \text{入栈}}\right) \)</td></tr><tr><td>8</td><td>d-e*f)/g</td><td>+(★</td><td>ab/c</td><td>d</td><td>d 加入后缀表达式</td></tr><tr><td>9</td><td>-e*f)/g</td><td>+(★</td><td>ab/cd</td><td>-</td><td>-优先级低于栈顶的*,弹出*, -入栈</td></tr><tr><td>10</td><td>e*f)/g</td><td>+(-</td><td>ab/cd*</td><td>e</td><td>e 加入后缀表达式</td></tr><tr><td>11</td><td>*e/f)/g</td><td>+(-</td><td>ab/cd*e</td><td>✘</td><td>*优先级高于栈顶的-, *入栈</td></tr><tr><td>12</td><td>f)/g</td><td>+(-*</td><td>ab/cd*e</td><td>f</td><td>f 加入后缀表达式</td></tr><tr><td>13</td><td>)/g</td><td>+(-*</td><td>ab/cd*ef</td><td>)</td><td>遇到),依次弹出*、-加入表达式,删除 (</td></tr><tr><td>14</td><td>/g</td><td>+</td><td>ab/cd*ef*-</td><td>/</td><td>/优先级高于栈顶的+, /入栈</td></tr><tr><td>15</td><td>g</td><td>+/</td><td>ab/cd*ef*-</td><td>g</td><td>g 加入后缀表达式</td></tr><tr><td>16</td><td></td><td>+/</td><td>ab/cd*ef*-g</td><td></td><td>扫描完毕, 运算符依次弹出加入表达式</td></tr><tr><td>17</td><td></td><td></td><td>ab/cd*ef*-g/+</td><td></td><td>完成</td></tr></table>

由此可知，当扫描到f时，栈中的元素依次是  $+(-\star)$

【另解】采用手算方法，得出中缀式  $a / b + (c^* d - e^* f) / g$  对应的后缀式为  $ab / cd * ef * -g / +$ 。中缀表达式转后缀表达式时，操作数都直接输出，因此操作数的顺序是固定的。扫描到  $f$  时，在后缀表达式  $f$  后面的运算符要么还未入栈，要么还在栈中，需要结合中缀式来判断， $f$  后面依次出栈的运算符为  $\star - / +$ ，/在中缀表达式  $f$  之后，此时还未入栈，因此栈中的运算符（从栈底到栈顶）为  $+ - \star$ ；此外，已入栈的界限符（此时还未消解，因此（也还在栈中，栈中的元素依次是  $+(-\star)$ 。

# 15. A

递归调用函数时，在系统栈中保存的函数信息需满足先进后出的特点，依次调用了main(),S(1),S(0)，所以栈底到栈顶的信息依次是main(),S(1),S(0)。

# 注意

在递归中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来存储。

# 16. C

根据题意：入队顺序为8,4,2,5,3,9,1,6,7，出队顺序为  $1\sim 9$  。入口和出口之间有多个队列（ $n$  条轨道），且每个队列（轨道）可容纳多个元素（多列列车)，为便于区分，队列用字母编号。分析如下：显然先入队的元素必须小于后入队的元素（否则，若8和4入同一个队列，8在4前面，则出队时也只能8在4前面)，这样8入队列A，4入队列B，2入队列C，5入队列B（按照前述原则“大的元素在小的元素后面”也可将5入队列C，但这时剩下的元素3就必须放入一个新的队列中，无法确保“至少”），3入队列C，9入队列A，这时共占了3个队列，后面还有元素1，直接再用一个新的队列D，1从队列D出队后，剩下的元素6和7或入队列B，或入队列C。综上，共占用了4个队列。当然还有其他的入队、出队情况，请读者自己推演，但要确保满足：①队列中后面的元素大于前面的元素；②确保占用最少（满足题意中“至少”）的队列。

# 17. C

I的反例：计算斐波那契数列迭代实现只需要一个循环即可实现。III的反例：入栈序列为1,2，进行Push, Push, Pop, Pop操作，出栈次序为2、1；进行Push, Pop, Push, Pop操作，出栈次序为1,2。IV，栈是一种受限的线性表，只允许在一端进行操作。II正确。

# 18. B

第一次调用：①从S1中弹出2和3；②从S2中弹出+；③执行  $3 + 2 = 5$  ；④将5压入S1中，第一次调用结束后S1中剩余5、8、5（5在栈顶)，S2中剩余\*、-（-在栈顶)。第二次调用：①从S1中弹出5和8；②从S2中弹出-；③执行  $8 - 5 = 3$  ；④将3压入S1中，第二次调用结束后S1中剩余5、3（3在栈顶)，S2中剩余\*。第三次调用：①从S1中弹出3和5；②从S2中弹出\*；③执行  $5^{*}3 = 15$  ；④将15压入S1中，第三次调用结束后S1中仅剩余15，S2为空。

# 19. A

根据中缀表达式画出对应的二叉树如右图所示，对该二叉树进行后序遍历即可得到后缀表达式为  $xyz - *y / +$  。本题也可采用本书前面描述的手算方法。

# 二、综合应用题

# 01.【解答】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0db018cd06ee7566531654d36acf5b07386ad951e913aad72c2ec0c0610c785b.jpg)


括号匹配是栈的一个典型应用，给出这道题是希望读者好好掌握栈的应用。

算法的基本思想是扫描每个字符，遇到花、方、圆的左括号时入栈，遇到花、方、圆的右括号时检查栈顶元素是否为相应的左括号，若是，出栈，否则配对错误。最后栈若不为空也为错误。

```javascript
bool BracketsCheck(char \*str){ InitStack(S); //初始化栈 int  $i = 0$  while(str[i]！  $= '\backslash 0'$  { switch(str[i]){ //左括号入栈 case '(':push(S,'('); break; case ['':push(S,'['); break; case '\{:':push(S,'{'); break; //遇到右括号，检测栈顶 case')':Pop(S,e); if(e!  $= '('$  return false; break; case']':pop(S,e); if(e!  $= '('$  return false; break; case }':pop(S,e); if(e!  $= '('$  return false; break; default: break; }//switch i++; }//while if(!isEmpty(S)){ printf("括号不匹配\n"); return false; } else{ printf("括号匹配\n"); return true; }
```

# 3.4 数组和特殊矩阵

矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。所以，我们不研究矩阵及其运算等，而把精力放在如何将矩阵更有效地存储在内存中，并能方便地提取矩阵中的元素。

# 3.4.1 数组的定义

数组是由  $n$  （  $n \geq 1$  ）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在  $n$  个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。

数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素是定长数组的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。

# 3.4.2 数组的存储结构

大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数据类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。

以一维数组A[0..n-1]为例，其存储结构关系式为

$$
\operatorname {L O C} \left(a _ {i}\right) = \operatorname {L O C} \left(a _ {0}\right) + i \times L (0 \leqslant i <   n)
$$

其中，  $L$  是每个数组元素所占的存储单元。

# 命题追踪 二维数组按行优先存储的下标对应关系（2021）

对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组的行下标与列下标的范围分别为  $[0, h_1]$  与  $[0, h_2]$ ，则存储结构关系式为

$$
\operatorname {L O C} \left(a _ {i, j}\right) = \operatorname {L O C} \left(a _ {0, 0}\right) + \left[ i \times \left(h _ {2} + 1\right) + j \right] \times L
$$

例如，对于数组  $A_{[2][3]}$ ，它按行优先方式在内存中的存储形式如图3.18所示。

$$
A _ {[ 2 | | 3 ]} = \left[ \begin{array}{l l l} a _ {[ 0 | | 0 ]} & a _ {[ 0 | | 1 ]} & a _ {[ 0 | | 2 ]} \\ a _ {[ 1 | | 0 ]} & a _ {[ 1 | | 1 ]} & a _ {[ 1 | | 2 ]} \end{array} \right] \quad \underbrace {a _ {[ 0 | | 0 ]}} _ {\text {第} 1 \text {行}} \quad \underbrace {a _ {[ 0 | | 1 ]}} _ {\text {第} 2 \text {行}} \quad \underbrace {a _ {[ 1 | | 0 ]}} _ {\text {第} 2 \text {行}} \quad \underbrace {a _ {[ 1 | | 1 ]}} _ {\text {第} 1 \text {行}}
$$


图3.18 二维数组按行优先顺序存放


当以列优先方式存储时，得出存储结构关系式为

$$
\operatorname {L O C} \left(a _ {i, j}\right) = \operatorname {L O C} \left(a _ {0, 0}\right) + \left[ j \times \left(h _ {1} + 1\right) + i \right] \times L
$$

例如，对于数组  $A_{[2][3]}$ ，它按列优先方式在内存中的存储形式如图3.19所示。

$$
A _ {\left| 2 \right| \left| 3 \right|} = \left[ \begin{array}{l l l} a _ {\left| 0 \right| \left| 0 \right|} & a _ {\left| 0 \right| \left[ 1 \right]} & a _ {\left| 0 \right| \left| 2 \right|} \\ a _ {\left| 1 \right| \left| 0 \right|} & a _ {\left| 1 \right| \left| 1 \right|} & a _ {\left| 1 \right| \left| 2 \right|} \end{array} \right] \quad \underbrace {a _ {\left| 0 \right| \left| 0 \right|}} _ {\text {第} 1 \text {列}} \quad \underbrace {a _ {\left| 1 \right| \left| 0 \right|}} _ {\text {第} 2 \text {列}} \quad \underbrace {a _ {\left| 1 \right| \left| 1 \right|}} _ {\text {第} 3 \text {列}}
$$


图3.19 二维数组按列优先顺序存放


# 3.4.3 特殊矩阵的压缩存储

压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配空间。

特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。

特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。

# 1. 对称矩阵

# 命题追踪 对称矩阵压缩存储的下标对应关系（2018、2020）

若对一个  $n$  阶矩阵  $\mathbf{A}$  中的任意一个元素  $a_{i,j}$  都有  $a_{ij} = a_{j,i}$  （  $1\leqslant i,j\leqslant n)$  ，则称其为对称矩阵。其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如图3.20所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c7a83f3cb05c88455b0c0e64e7373dd1030b9b2fc9b654d5313439b7c6e76368.jpg)



图3.20  $n$  阶矩阵的划分


对于  $n$  阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将  $n$  阶对称矩阵  $\mathbf{A}$  存放在一维数组  $\mathrm{B}[\mathrm{n}(\mathrm{n} + 1) / 2]$  中，即元素  $a_{l,j}$  存放在  $b_{k}$  中。比如只存放下三角部分（含主对角线）的元素。

在数组B中，位于元素  $a_{i,j}$  （  $i\geq j$  ）前面的元素个数为

第1行：1个元素  $(a_{1,1})$

第2行：2个元素  $(a_{2,1}, a_{2,2})$ 。

··

第  $i - 1$  行：  $i - 1$  个元素  $(a_{i - 1,1},a_{i - 1,2},\dots ,a_{i - 1,i - 1})$

第  $i$  行：  $j - 1$  个元素  $(a_{i,1}, a_{i,2}, \dots, a_{i,j - 1})$

因此，元素  $a_{ij}$  在数组B中的下标  $k = 1 + 2 + \dots +(i - 1) + j - 1 = i(i - 1) / 2 + j - 1$  （数组下标从0开始）。因此，元素下标之间的对应关系如下：

$$
k = \left\{ \begin{array}{l l} \frac {i (i - 1)}{2} + j - 1, & i \geqslant j (\text {下 三 角 区 和 主 对 角 线 元 素}) \\ \frac {j (j - 1)}{2} + i - 1, & i <   j (\text {上 三 角 区 元 素} a _ {i, j} = a _ {j, i}) \end{array} \right.
$$

当数组下标从1开始时，可以采用同样的推导方法，请读者自行思考。

# 注意

二维数组A[n][n]和A[0..n-1][0..n-1]的写法是等价的。若数组写成A[1..n][1..n]，则表示指定了下标是从1开始的。二维数组元素写为a[i][j]，注意数组元素下标i和j通常是从0开始的。矩阵元素通常写为ai,j，行号i和列号j通常是从1开始的。

# 2. 三角矩阵

下三角矩阵［见图3.22(a)]中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，所以可以将  $\mathbf{n}$  阶下三角矩阵  $A$  压缩存储在  $\mathrm{B}[\mathrm{n}(\mathrm{n} + 1) / 2 + 1]$  中。

元素下标之间的对应关系为

$$
k = \left\{ \begin{array}{l l} \frac {i (i - 1)}{2} + j - 1, & i \geqslant j (\text {下 三 角 区 和 主 对 角 线 元 素}) \\ \frac {n (n + 1)}{2}, & i <   j (\text {上 三 角 区 元 素}) \end{array} \right.
$$

下三角矩阵在内存中的压缩存储形式如图3.21所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e36a4529c5edbfa0373be1eacb537394ee73062a0d304814da5fe80b967648ff.jpg)



图3.21 下三角矩阵的压缩存储


# 命题追踪 上三角矩阵采用行优先存储的应用（2011）

上三角矩阵［见图3.22(b)]中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在B[n(n+1)/2+1]中。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f60402352083ab397ebb9824c50458b67a628aaa3083ada2b49f8ced1b3818e8.jpg)



(a) 下三角矩阵


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/51d0649b9726c2dce6c7b623819de38f7038779ae8bf32ed3002c45a3cf83603.jpg)



(b) 上三角矩阵



图3.22 三角矩阵


在数组B中，位于元素  $a_{i,j}$  （ $i \leqslant j$ ）前面的元素个数为

第1行：  $n$  个元素

第2行：  $n - 1$  个元素

···

第  $i - 1$  行：  $n - i + 2$  个元素

第  $i$  行：  $j - i$  个元素

因此，元素  $a_{i,j}$  在数组B中的下标

$$
k = n + (n - 1) + \dots + (n - i + 2) + (j - i + 1) - 1 = (i - 1) (2 n - i + 2) / 2 + (j - i)
$$

因此，元素下标之间的对应关系如下：

$$
k = \left\{ \begin{array}{l l} \frac {(i - 1) (2 n - i + 2)}{2} + (j - i), & i \leqslant j (\text {上 三 角 区 和 主 对 角 线 元 素}) \\ \frac {n (n + 1)}{2}, & i > j (\text {下 三 角 区 元 素}) \end{array} \right.
$$

上三角矩阵在内存中的压缩存储形式如图3.23所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0d5f32958a4c7d4b6f16eeb28e5bbc69a219db3c66d1cf6abea52daf146b5f4f.jpg)



图3.23 上三角矩阵的压缩存储


以上推导均假设数组的下标从0开始，若题设有具体要求，则应该灵活应对。

# 3. 三对角矩阵 公众号：小兔网盘 免费分享无水印PDF

对角矩阵也称带状矩阵。对  $n$  阶矩阵  $\mathbf{A}$  中的任意一个元素  $a_{i,j}$ ，当  $|i - j| > 1$  时，若有  $a_{i,j} = 0$ （ $1 \leqslant i, j \leqslant n$ ），则称为三对角矩阵，如图3.24所示。在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5cd66b55c23a2a6bcd2a5e222d7d96bafe54b618d904e70a3c8244f3d3de0d4c.jpg)



图3.24 三对角矩阵  $\mathbf{A}$


三对角矩阵  $A$  也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且  $a_{1,1}$  存放于B[0]中，其存储形式如图3.25所示。

<table><tr><td>a1,1</td><td>a1,2</td><td>a2,1</td><td>a2,2</td><td>a2,3</td><td>...</td><td>an-1,n</td><td>an,n-1</td><td>an,n</td></tr></table>


图3.25 三对角矩阵的压缩存储


# 命题追踪 三对角矩阵压缩存储的下标对应关系（2016）

由此可以计算矩阵  $A$  中3条对角线上的元素  $a_{i,j}$  （  $1\leqslant i,j\leqslant n,|i - j|\leqslant 1$  ）在一维数组B中存放的下标为  $k = 2i + j - 3$

反之，若已知三对角矩阵中的某个元素  $a_{i,j}$  存放在一维数组B的第  $k$  个位置，则有  $i = \lfloor (k + 1) / 3 + 1\rfloor$ $j = k - 2i + 3$  。例如，当  $k = 0$  时，  $i = \lfloor (0 + 1) / 3 + 1\rfloor = 1$  ，  $j = 0 - 2\times 1 + 3 = 1$  ，存放的是  $a_{1,1}$  ；当  $k =$  2时，  $i = \lfloor (2 + 1) / 3 + 1\rfloor = 2$  ，  $j = 2 - 2\times 2 + 3 = 1$  ，存放的是  $a_{2,1}$  ；当  $k = 4$  时，  $i = \lfloor (4 + 1) / 3 + 1\rfloor = 2$ $j = 4 - 2\times 2 + 3 = 3$  ，存放的是  $a_{2,3}$

# 3.4.4 稀疏矩阵

矩阵中非零元素的个数  $t$  ，相对矩阵元素的个数  $s$  来说非常少，即  $s \gg t$  的矩阵称为稀疏矩阵。例如，一个矩阵的阶为  $100 \times 100$  ，该矩阵中只有少于100个非零元素。

# 命题追踪 存储稀疏矩阵需要保存的信息（2023）

若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组（行标  $i$  ，列标  $j$  ，值  $a_{i,j}$  ），如图3.26所示。然后按照某种规律存储这些三元组线性表。稀疏矩阵压缩存储后便失去了随机存取特性。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/19099649a2b9fca9a67e54c432e13b818fb7d78cfab6bee813b67524e7097eed.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/082093e60c1c33a1657afc9e1a7e8734e2517fba8441d3a956cc9d3c18b7971a.jpg)



图3.26 稀疏矩阵及其对应的三元组


# 命题追踪 适合稀疏矩阵压缩存储的存储结构（2017）

稀疏矩阵的三元组表既可以采用数组存储，又可以采用十字链表存储（见6.2节）。当存储稀疏矩阵时，不仅要保存三元组表，而且要保存稀疏矩阵的行数、列数和非零元素的个数。

# 3.4.5 本节试题精选

# 单项选择题

01. 对特殊矩阵采用压缩存储的主要目的是（）。

A. 表达变得简单

B. 对矩阵元素的存取变得简单

C. 去掉矩阵中的多余元素

D. 减少不必要的存储空间

02. 对  $n$  阶对称矩阵压缩存储时，需要表长为（）的顺序表。

A.  $n / 2$

B.  $n \times n / 2$

C.  $n(n + 1) / 2$

D.  $n(n - 1) / 2$

03. 有一个  $n \times n$  的对称矩阵  $A$ ，将其下三角部分按行存放在一维数组 B 中，而 A[0][0] 存放于 B[0] 中，则元素 A[i][i] 存放于 B 中的（）处。

A.  $(i + 3)i / 2$

B.  $(i + 1)i / 2$

C.  $(2n - i + 1)i / 2$

D.  $(2n - i - 1)i / 2$

04. 在二维数组 A 中，假设每个数组元素的长度为 3 个存储单元，行下标  $i$  为  $0 \sim 8$ ，列下标  $j$  为  $0 \sim 9$ ，从首地址 SA 开始连续存放。在这种情况下，元素 A[8][5] 的起始地址为（）。

A. SA+141

B. SA+144

C. SA+222

D. SA+255

05. 二维数组  $A$  按行优先存储，其中每个元素占1个存储单元。若A[1][1]的存储地址为

420，A[3][3]的存储地址为446，则A[5][5]的存储地址为（）。

A. 472

B. 471

C. 458

D. 457

06. 将三对角矩阵即数组 A[1...100][1...100] 按行优先存入一维数组 B[1...298] 中，数组 A 中元素 A[66][65] 在数组 B 中的位置  $k$  为（）。

A. 198

B. 195

C. 197

D. 196

07. 若将  $n$  阶上三角矩阵  $A$  按列优先级压缩存放在一维数组  $\mathrm{B}[1..n(n + 1) / 2 + 1]$  中，则存放到  $\mathrm{B}[k]$  中的非零元素  $a_{i,j} (1 \leqslant i,j \leqslant n)$  的下标  $i$ 、 $j$  与  $k$  的对应关系是（）。

A.  $i(i + 1) / 2 + j$

B.  $i(i - 1) / 2 + j - 1$

C.  $j(j - 1) / 2 + i$

D.  $j(j - 1) / 2 + i - 1$

08. 若将  $n$  阶下三角矩阵  $A$  按列优先顺序压缩存放在一维数组  $B[1 \dots n(n + 1) / 2 + 1]$  中，则存放到  $B[k]$  中的非零元素  $a_{i,j} (1 \leqslant i,j \leqslant n)$  的下标  $i, j$  与  $k$  的对应关系是（）。

A.  $(j - 1)(2n - j + 1) / 2 + i - j$

B.  $(j - 1)(2n - j + 2) / 2 + i - j + 1$

C.  $(j - 1)(2n - j + 2) / 2 + i - j$

D.  $(j - 1)(2n - j + 1) / 2 + i - j - 1$

09. 稀疏矩阵采用压缩存储后的缺点主要是（）。

A. 无法判断矩阵的行列数

B. 丧失随机存取的特性

C. 无法由行、列值查找某个矩阵元素

D. 使矩阵元素之间的逻辑关系更复杂

10. 下列关于矩阵的说法中，正确的是（）。

I. 在  $n(n > 3)$  阶三对角矩阵中，每行都有3个非零元

II. 稀疏矩阵的特点是矩阵中的元素较少

A. 仅 I

B. 仅 II

C. I 和 II

D. 无正确项

11.【2016统考真题】有一个100阶的三对角矩阵  $M$  ，其元素  $m_{i,j}$  （  $1\leqslant i,j\leqslant 100$  ）按行优先依次压缩存入下标从0开始的一维数组N中。元素  $m_{30,30}$  在  $\mathbf{N}$  中的下标是（）。

A. 86

B. 87

C. 88

D. 89

12.【2017统考真题】适用于压缩存储稀疏矩阵的两种存储结构是（）。

A. 三元组表和十字链表

B. 三元组表和邻接矩阵

C. 十字链表和二叉链表

D. 邻接矩阵和十字链表

13.【2018统考真题】设有一个  $12 \times 12$  阶对称矩阵  $M$ ，将其上三角部分的元素  $m_{i,j} (1 \leqslant i \leqslant j \leqslant 12)$  按行优先存入C语言的一维数组N中，元素  $m_{6,6}$  在N中的下标是（）。

A. 50

B. 51

C. 55

D. 66

14.【2020统考真题】将一个  $10 \times 10$  阶对称矩阵  $M$  的上三角部分的元素  $m_{i,j}$  （  $1 \leqslant i \leqslant j \leqslant 10$  ）按列优先存入C语言的一维数组N中，元素  $m_{7,2}$  在N中的下标是（）。

A. 15

B. 16

C. 22

D. 23

15.【2021统考真题】二维数组  $A$  按行优先方式存储，每个元素占用1个存储单元。若元素A[0][0]的存储地址是100，A[3][3]的存储地址是220，则元素A[5][5]的存储地址是（）。

A. 295

B. 300

C. 301

D. 306

16.【2023统考真题】若采用三元组表存储结构存储稀疏矩阵  $M$  ，则除三元组表外，下列数据中还需要保存的是（）。

I.  $M$  的行数

II.  $M$  中包含非零元素的行数

III.  $M$  的列数

IV.  $M$  中包含非零元素的列数

A. 仅 I、III

B. 仅 I、IV

C. 仅 II、IV

D. I、II、III、

# 3.4.6 答案与解析

# 单项选择题

01. D

特殊矩阵中含有很多相同元素或零元素，所以可采用压缩存储，以节省存储空间。

02.C

只需存储其上三角或下三角部分（含对角线），元素个数为  $n + (n - 1) + \dots + 1 = n(n + 1)/2$ 。

03. A

此题要注意3个细节：矩阵的最小下标为0；数组下标也是从0开始的；矩阵按行优先存在数组中。注意到此三点，答案不难得到为选项A。此外，本类题建议采用特殊值代入法求解，例如，A[1][1]对应的下标应为2，代入后只有选项A满足条件。

# 技巧

对于特殊三角矩阵压缩存储的题，心中应有“平移”搬动的思想，并结合草图，这样会比较形象，在计算时再注意矩阵和数组的起始下标，就不容易出错。

04. D

二维数组计算地址（按行优先顺序）的公式为

$$
\operatorname {L O C} (i, j) = \operatorname {L O C} (0, 0) + (i \times m + j) \times L
$$

其中，  $\mathrm{LOC}(0,0) = \mathrm{SA}$  ，是数组存放的首地址；  $L = 3$  是每个数组元素的长度；  $m = 9 - 0 + 1 = 10$  是数组的列数。因此有  $\mathrm{LOC}(8,5) = \mathrm{SA} + (8\times 10 + 5)\times 3 = \mathrm{SA} + 255$  ，所以选择选项D。

05. A

本题未直接给出数组A的行数和列数，因此需要根据题目中的信息来推理。因为该二维数组按行优先存储，且A[3][3]的存储地址为446，所以A[3][1]的存储地址为444，又A[1][1]的存储地址为420，显然A[1][1]和A[3][1]正好相差2行，所以该矩阵的列数为12。而A[5][3]和A[3][3]正好相差2行，A[5][5]和A[5][3]又相差2个元素，所以A[5][5]的存储地址是  $446 + 24 + 2 = 472$

06. B

对于三对角矩阵，将A[1...n][1...n]压缩至B[1...3n-2]时， $a_{i,j}$  与  $b_{k}$  的对应关系为  $k = 2i + j - 2$ 。则A中的元素A[66][65]在数组B中的位置  $k$  为  $2 \times 66 + 65 - 2 = 195$ 。

07. C

按列优先存储，所以元素  $a_{i,j}$  前面有  $j - 1$  列，共有  $1 + 2 + 3 + \dots + j - 1 = j(j - 1) / 2$  个元素，元素  $a_{i,j}$  在第  $j$  列上是第  $i$  个元素，数组  $B$  的下标是从1开始，因此  $k = j(j - 1) / 2 + i$ 。

08. B

按列优先存储，所以元素  $a_{ij}$  之前有  $j - 1$  列，共有  $n + (n - 1) + \dots + (n - j + 2) = (j - 1)(2n - j + 2) / 2$  个元素，元素  $a_{ij}$  是第  $j$  列上第  $i - j + 1$  个元素，数组B的下标从1开始， $k = (j - 1)(2n - j + 2) / 2 + i - j + 1$ 。

09. B

稀疏矩阵通常采用三元组来压缩存储，存储矩阵元素的行列下标和相应的值，因此不能根据矩阵元素的行列下标快速定位矩阵元素，失去了随机存取的特性。

10. D

在三对角矩阵中，第1行和最后1行只有2个非零元，其余各行均有3个非零元。稀疏矩阵的特点是矩阵中非零元的个数较少。

# 11. B

三对角矩阵如下所示。

$$
\left[ \begin{array}{c c c c c c} a _ {1, 1} & a _ {1, 2} & & & & \\ a _ {2, 1} & a _ {2, 2} & a _ {2, 3} & & 0 & \\ & a _ {3, 2} & a _ {3, 3} & a _ {3, 4} & & \\ & & \ddots & \ddots & \ddots & \\ & 0 & & a _ {n - 1, n - 2} & a _ {n - 1, n - 1} & a _ {n - 1, n} \\ & & & & a _ {n, n - 1} & a _ {n, n} \end{array} \right]
$$

采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且  $a_{1,1}$  存放于B[0]中，其存储形式如下所示：

<table><tr><td>a1,1</td><td>a1,2</td><td>a2,1</td><td>a2,2</td><td>a2,3</td><td>···</td><td>an-1,n</td><td>an,n-1</td><td>an,n</td></tr></table>

可以计算矩阵  $A$  中3条对角线上的元素  $a_{i,j}$  （  $1\leqslant i,j\leqslant n,|i - j|\leqslant 1$  ）在一维数组B中存放的下标为  $k = 2i + j - 3$  ，公式很难记忆，我们通常采用解法2。

解法1：针对该题，仅需将数字逐一代入公式：  $k = 2 \times 30 + 30 - 3 = 87$ ，结果为87。

解法2：观察上图的三对角矩阵不难发现，第一行有两个元素，剩下的在元素  $m_{30,30}$  所在行之前的28行（注意下标  $1 \leqslant i, j \leqslant 100$ ）中，每行都有3个元素，而  $m_{30,30}$  之前仅有一个元素  $m_{30,29}$ ，不难发现元素  $m_{30,30}$  在数组  $N$  中的下标是  $2 + 28 \times 3 + 2 - 1 = 87$ 。

# 注意

矩阵和数组的下标从0或1开始（如矩阵可能从  $a_{0,0}$  或  $a_{1,1}$  开始，数组可能从B[0]或B[1]开始），这时就需要适时调整计算方法（方法无非是多计算1或少计算1的问题）。

# 12. A

三元组表的结点存储了行（row）、列（col）、值（value）三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达  $O(n^{2})$  ，不适合于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。

# 13. A

在C语言中，数组  $N$  的下标从0开始。第一个元素  $m_{1,1}$  对应存入  $n_0$  ，矩阵  $\pmb{M}$  的第一行有12个元素，第二行有11个，第三行有10个，第四行有9个，第五行有8个，所以  $m_{6,6}$  是第 $12 + 11 + 10 + 9 + 8 + 1 = 51$  个元素，下标应为50。

# 14.C

上三角矩阵按列优先存储，先存储只有1个元素的第一列，再存储有2个元素的第二列，以此类推。  $m_{7,2}$  位于左下角，对应右上角的元素为  $m_{2,7}$ ，在  $m_{2,7}$  之前存有

第1列：1

第2列：2

··

第6列：6

第7列：1

前面共存储有  $1 + 2 + 3 + 4 + 5 + 6 + 1 = 22$  个元素（数组下标范围为  $0\sim 21$ ），注意数组下标从0开始，所以  $m_{2,7}$  在数组N中的下标为22，即  $m_{7,2}$  在数组N中的下标为22。

# 15. B

二维数组A按行优先存储，每个元素占用1个存储单元，由A[0][0]和A[3][3]的存储地址可知A[3][3]是二维数组A中的第121个元素，假设二维数组A的每行有  $n$  个元素，则  $n \times 3 + 4 = 121$  求得  $n = 39$  ，所以元素A[5][5]的存储地址为  $100 + 39 \times 5 + 6 - 1 = 300$  。

# 16. A

用三元组表存储结构存储稀疏矩阵  $M$  时，每个非零元素都由三元组（行标、列标、关键字值）组成。但是，仅通过三元组表中的元素无法判断稀疏矩阵  $M$  的大小，因此还要保存  $M$  的行数和列数。此外，还可以保存  $M$  的非零元素个数。例如，如下两个稀疏矩阵的三元组表是相同的，若不保存行数和列数，则无法判断两个稀疏矩阵的大小。

<table><tr><td>0</td><td>2</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>5</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>

<table><tr><td>0</td><td>2</td><td>0</td></tr><tr><td>0</td><td>0</td><td>5</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></table>

# 归纳总结

本章所讲的几种数据结构类型是线性表的应用和推广，在考试中主要以选择题形式进行考查，但栈和队列也仍然有可能出现在算法设计题中。很多读者看到课本上有好多个函数时很恐惧，若考到了栈或队列的大题，难道要把每个操作的函数都写出来吗？

其实，在考试中，栈或队列都是作为一个工具来解决其他问题的，我们可以把栈或队列的声明和操作写得很简单，而不必分函数写出。以顺序栈的操作为例：

（1）声明一个栈并初始化：

Elemtype stack[maxSize]; int top=-1; //两句话连声明带初始化都有了

（2）元素入栈：

stack[++top] = x; //仅一句话即实现入栈操作

（3）元素  $\mathbf{x}$  出栈：

X=stack[top--]； //单目运算符在变量之前表示“先运算后使用”，之后则相反

对于链式栈，同样只需定义一个结构体，然后从讲解中摘取必要的语句组合在自己的函数代码中即可。另外，在考研真题中，链式栈出现的概率要比顺序栈低得多，因此大家应该有所侧重，多训练与顺序栈相关的题目。

# 思维拓展

设计一个栈，使它可以在  $O(1)$  的时间复杂度内实现Push、Pop和min操作。所谓min操作，是指得到栈中最小的元素。

# 提示

使用双栈，两个栈是同步关系。主栈是普通栈，用来实现栈的基本操作Push和Pop；辅助栈用来记录同步的最小值min，例如元素x入栈，则辅助栈stack_min  $\mathrm{[top + + ] = (x <   min)?x:min}$  ；即在每次Push中，都将当前最小元素放到stack_min的栈顶。在主栈中Pop最小元素y时，stack_min栈中相同位置的最小元素y也会随着top--而出栈。因此stack_min的栈顶元素必然是y之前入栈的最小元素。本题是典型的以空间换时间的算法。

# 串

# 【考纲内容】

字符串模式匹配

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8c29b98417faac3e2154b68e8cbbfdd5cceb6a95fcff987539a392502467b657.jpg)



扫一扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e4eb95d3c0b1988817cde6282392cdde655bf9fe9168464edfb51b9ecc4eac4b.jpg)



视频讲解


# 【复习提示】

本章是统考大纲第6章内容，采纳读者建议单独作为一章，大纲只要求掌握字符串模式匹配，重点掌握KMP匹配算法的原理及next数组的推理过程，手工求next数组可以先计算出部分匹配值表然后变形，或根据公式来求解。了解nextval数组的求解方法。

# *4.1 串的定义和实现①

字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统（如搜索引擎）、文本编辑程序（如Word）、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。本章详细介绍字符串的存储结构及相应的操作。

# 4.1.1 串的定义

串（string）是由零个或多个字符组成的有限序列。一般记为

$$
S = ^ {\prime} a _ {1} a _ {2} \dots a _ {n} ^ {\prime} \quad (n \geqslant 0)
$$

其中，  $S$  是串名，单引号括起来的字符序列是串的值；  $a_{i}$  可以是字母、数字或其他字符；串中字符的个数  $n$  称为串的长度。  $n = 0$  时的串称为空串（用  $\varnothing$  表示）。

串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。某个字

符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第1个字符在主串中的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。

例如，有串  $A =$  'China Beijing'， $B =$  'Beijing'， $C =$  'China'，则它们的长度分别为13、7和5。B和C是A的子串，B在A中的位置是7，C在A中的位置是1。

注意，由一个或多个空格（空格是特殊字符）组成的串称为空格串（空格串不是空串），其长度为串中空格字符的个数。

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。

# 4.1.2 串的基本操作

- StrAssign(&T, chars): 赋值操作。把串 T 赋值为 chars。

- StrCopy(&T,S)：复制操作。由串S复制得到串T。

- StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。

- StrCompare(S,T)：比较操作。若  $S > T$ ，则返回值  $> 0$ ；若  $S = T$ ，则返回值  $= 0$ ；若  $S < T$ ，则返回值  $< 0$ 。

- StrLength(S): 求串长。返回串 S 的元素个数。

- SubString(&Sub,S,pos,len): 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。

- Concat(&T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串。

- Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。

- ClearString(&S): 清空操作。将 S 清为空串。

- DestroyString(&S): 销毁串。将串 S 销毁。

不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值StrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串SubString五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。

# 4.1.3 串的存储结构

# 1. 定长顺序存储表示

类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。

```txt
define MAXLEN 255 //预定义最大串长为255 typedef struct{ char ch [MAXLEN]; //每个分量存储一个字符 int length; //串的实际长度 }CString;
```

串的实际长度只能小于或等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。串长有两种表示方法：一是如上述定义描述的那样，用一个额外的变量len来存放串的长度；二是在串值后面加一个不计入串长的结束标记字符“\0”，此时的串长为隐含值。

在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界MAXLEN，约定用“截

断”法处理，要克服这种弊端，只能不限定串长的最大长度，即采用动态分配的方式。

# 2. 堆分配存储表示

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。

```txt
typedef struct{ char \*ch; //按串长分配存储区，ch指向串的基地址 int length; //串的长度 }HString;
```

在C语言中，存在一个称为堆的自由存储区，并用malloc()和free()函数来完成动态存储管理。利用malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来指示；若分配失败，则返回NULL。已分配的空间可用free()释放掉。

上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。

# 3. 块链存储表示

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点称为块，整个链表称为块链结构。图4.1(a)是结点大小为4（每个结点存放4个字符）的链表，最后一个结点占不满时通常用“#”补上；图4.1(b)是结点大小为1的链表。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1a41bee1338e1fa64082b1003e0e657f3793a862435e2c41564f697c2c1cbfb4.jpg)



(a) 结点大小为4的链表


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bd2d0b0a99c77e321494930185fe7c17d61fbb815af9cebeeafef45596d2d22d.jpg)



(b) 结点大小为1的链表



图4.1 串值的链式存储方式


# 4.2 串的模式匹配

# 4.2.1 简单的模式匹配算法

模式匹配是指在主串中找到与模式串（想要搜索的某个字符串）相同的子串，并返回其所在的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。

```javascript
int Index(SSString S,SString T){ int  $i = 1,j = 1$  · while  $(\mathrm{i} <   = \mathrm{S}$  .length&&j  $<   =$  T.length）{ if(S.ch[i]  $\equiv   =$  T.ch[j]) { ++i;++j; //继续比较后继字符 } else{ i=i-j+2;j=1; //指针后退重新开始匹配 } } if(j>T.length) return i-T.length; else return 0;
```

在上述算法中，分别用计数指针 i 和 j 指示主串 S 和模式串 T 中当前待比较的字符位置。

算法思想是：从主串S的第一个字符起，与模式串T的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，再重新和模式串T的字符比较；以此类推，直至模式串T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式串T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。

图4.2展示了模式串  $\mathrm{T} = {}^{\prime}$  abcac'和主串S的匹配过程。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e86aeaf1a07a656f70dd241e59c6cfa73f29b1baf3a5eec560db36fbec801228.jpg)



图4.2 简单模式匹配算法举例


在简单模式匹配算法中，设主串和模式串的长度分别为  $n$  和  $m$  （ $n \gg m$ ），则最多需要进行  $n - m + 1$  趟匹配，每趟最多需要进行  $m$  次比较，最坏时间复杂度为  $O(nm)$ 。例如，当模式串为'0000001'而主串为'0000000000000000000000000000000000000000000'时，由于模式串中的前6个字符均为'0'，主串中的前45个字符均为'0'，每趟匹配都是比较到模式串中的最后一个字符时才发现不等，整个匹配过程中指针i需要回溯39次，总比较次数为  $40 \times 7 = 280$  次。

# 4.2.2 串的模式匹配算法——KMP算法

在图4.2的第三趟匹配过程中，  $i = 7$  、  $j = 5$  的字符比较，结果不等，于是又从  $i = 4$  、  $j = 1$  重新开始比较。然而，仔细观察会发现，  $i = 4$  和  $j = 1$  、  $i = 5$  和  $j = 1$  以及  $i = 6$  和  $j = 1$  这三次比较都是不必进行的。从第三趟部分匹配的结果可知，主串的第4个、第5介、第6个字符是'b'、'c'、'a'(模式串的第2、第3、第4个字符)，因为模式串的第1个字符是'a'，所以再和这三个字符进行比较纯属多余，而只需将模式串向右滑动三个字符的位置，再进行  $i = 7$  、  $j = 2$  的比较即可。

在简单模式匹配算法中，每趟匹配失败都是模式串向右滑动一位后从头开始比较的。而某趟已匹配相等的字符序列是模式串的某个前缀，因此可从分析模式串本身的结构着手，若已匹配相等的前缀序列中有某个后缀正好是模式串的前缀，则可将模式串向右滑动到与这些相等字符对齐

的位置（也是后面手算next数组的依据），主串指针i无须回溯，并从该位置开始继续比较。而模式串向右滑动位数的计算仅与模式串本身的结构有关，与主串无关。

# 1. KMP算法的原理

要了解模式串的结构，首先要弄清楚几个概念：前缀、后缀和部分匹配值。前缀是指除最后一个字符外，字符串的所有头部子串；后缀是指除第一个字符外，字符串的所有尾部子串；部分匹配值则是指字符串的前缀和后缀的最长相等前后缀长度。下面以'ababa'为例进行说明：

- 'a'的前缀和后缀都为空集，最长相等前后缀长度为0。

- 'ab'的前缀为{a},后缀为{b},  $\{\mathbf{a}\} \cap \{\mathbf{b}\} = \emptyset$  ，最长相等前后缀长度为0。

- 'aba'的前缀为{a,ab},后缀为{a,ba}, {a,ab}∩{a,ba}={a},最长相等前后缀长度为1。

- 'abab'的前缀{a, ab, aba}∩后缀{b, ab, bab}={ab}, 最长相等前后缀长度为2。

- 'ababa'的前缀{a, ab, aba, abab}∩后缀{a, ba, aba, baba}={a, aba}, 公共元素有两个，最长相等前后缀长度为3。

因此，模式串'ababa'的部分匹配值为00123。

这个部分匹配值有什么作用呢？

回到最初的问题，主串为'ababcacbcab', 模式串为'abcac'。

利用上述方法容易求出模式串'abcac'的部分匹配值为00010，将部分匹配值写成数组形式，就得到了部分匹配值（Partial Match，PM）的表。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>S</td><td>a</td><td>b</td><td>c</td><td>a</td><td>c</td></tr><tr><td>PM</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></table>

下面用PM表来进行字符串匹配：

主串 a b a b c a b c a c b a b模式串 a b c

第一趟匹配过程：

发现c与a不匹配，前面的2个字符'ab'是匹配的，查表可知，最后一个匹配字符b对应的部分匹配值为0，因此按照下面的公式算出模式串需要的右滑位数：

右滑位数 = 已匹配的字符数 - 对应的部分匹配值

因为  $2 - 0 = 2$  ，所以将模式串向右滑动2位如下，进行第二趟匹配：

主串 a b a b c a b c a c b a b模式串 a b c a c

第二趟匹配过程：

发现c与b不匹配，前面的4个字符'abca'是匹配的，查表可知，最后一个匹配字符a对应的部分匹配值为1，  $4 - 1 = 3$  ，将模式串向右滑动3位如下，进行第三趟匹配：

主串 a b a b c a b c a c b a b模式串 a b c a c

第三趟匹配过程：

模式串全部比较完成，匹配成功。整个匹配过程中，主串始终没有回退，所以KMP算法可在  $O(n + m)$  的时间数量级上完成串的模式匹配操作，大大提高了匹配效率。

某趟发生失配时，若已匹配相等的序列中没有相等的前后缀，则对应的部分匹配值为0，此时滑动的位数最大，直接将模式串首字符向右滑动到主串当前位置进行下一趟比较；若已匹配相等的序列中存在最大相等前后缀（可理解为首尾重合），则将模式串向右滑动到和主串中该相等后缀对齐（这些重合的字符下一趟显然无需再比较），然后从主串当前位置进行下一趟比较。两种情况的模式串右滑位数都等于“已匹配的字符数-对应的部分匹配值”。

还有一种特例，在上述举例中并未出现，当某趟第一个字符比较就失配时，应如何处理呢？此时，应让模式串向右滑动一位，再从主串当前位置的下一位开始比较。

# 2. next 数组的手算方法

在实际的匹配过程中，模式串在内存中是不会滑动的，发生变化的是指针，前面的举例只是手动模拟KMP算法的过程，也是为了让读者更为形象地进行理解。

# 命题追踪 KMP算法中指针变化、比较次数的分析（2015、2019）

每趟匹配失败时，只有模式串指针i在变化，主串指针j不会回溯，为此可以定义一个next数组，next[j]的含义是当模式串的第j个字符失配时，跳到next[j]位置继续比较。

下面给出一种求 next 数组的手算方法，仍以模式串'abcac'为例。

第1个字符失配时，令  $\text{next}[1] = 0$ ，然后指针i和j同时加1，即下次将模式串的第1个位置与主串当前位置的下一位置进行比较（注意，图中的下标为模式串编号）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8c0ff92ede100227e5b2f892276c3bb9b6f69adaed8b455b05e0783499c379bf.jpg)


第2个字符失配时，令next[2] = 1，模式串的下次比较位置为1，相当于向右滑动1位。注，模式串的 next[1] = 0、next[2] = 1 都是固定不变的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d57f1f231fca48dc6bde81884ab3103097c94a57340e5cfb91166151d6fd6665.jpg)


在后面的手算过程中，在不匹配的位置前画一条分界线，模式串一步一步往后退，直到分界线之前能对上（首尾重合），或模式串完全跨过分界线为止。

第3个字符失配时，模式串的下次比较位置为1，即next[3] = 1，相当于向右滑动2位。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/79a36447300189337905cb7a8ab4ab267537dbe7d51ad607e40e5e1dd2ec3ba8.jpg)


第4个字符失配时，模式串的下次比较位置为1，即next[4] = 1，相当于向右滑动3位。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6d43f8c66fac32f48ac7b491d1da0c20fce8260b78964827f42d4193b7954aea.jpg)


第5个字符失配时，模式串的下次比较位置为2，即next  $[5] = 2$  ，相当于向右滑动3位。

匹配失败，说明此元素不是c

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7fb6e5fd38f8ebbdf19300cc87a68691f3c2021d408109246a634a673c0bb71d.jpg)


next 数组和 PM 表的关系是怎样的？

通过上述举例，可以推理出 next 数组和 PM 表之间的关系：

next[j] = j-右滑位数 = j-(已匹配的字符数①-对应的部分匹配值)

$$
\begin{array}{l} = j - [ (j - 1) - P M [ j - 1 ] ] \\ = \mathrm {P M} [ j - 1 ] + 1 \\ \end{array}
$$

根据上述结论，将模式串'abcac'的PM表右移一位，并整体加1，就得到了模式串'abcac'对应的next数组，通过与前面手算的结果比较，可以验证上述结论。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>S</td><td>a</td><td>b</td><td>c</td><td>a</td><td>c</td></tr><tr><td>next</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td></tr></table>

我们注意到：

1）第一个元素右滑以后空缺的用0来填充，因为若是第一个元素匹配失败，则需要将主串指针和模式串指针同步右移一位，从而不需要计算模式串指针移动的位数。

2）最后一个元素在右滑的过程中溢出，因为原来的模式串中，最后一个元素的部分匹配值是其下一个元素使用的，但显然已没有下一个元素，所以可以舍去。

# 注意

上述KMP算法的举例中，都假设串的编号是从1开始的；若串的编号是从0开始的，则next数组需要整体减1。

# *3. next 数组的推理公式

如何推理 next 数组的一般公式？设主串为  $s_1s_2\dots s_n'$ ，模式串为  $p_1p_2\dots p_m'$ ，当主串的第  $i$  个字符与模式串的第  $j$  个字符失配时，应让主串当前位置与模式串的哪个字符进行比较？

假设此时应与模式串的第  $\mathrm{k}$  （  $\mathrm{k} < \mathrm{j}$  ）个字符进行比较，则模式串的前  $\mathrm{k} - 1$  个字符的子串必须满足下列条件，且不可能存在  $\mathrm{k}' > \mathrm{k}$  满足下列条件：

$$
p _ {1} p _ {2} \dots p _ {k - 1} ^ {\prime} = ^ {\prime} p _ {j - k + 1} p _ {j - k + 2} \dots p _ {j - 1} ^ {\prime}
$$

若存在满足如上条件的子串，则发生失配时，仅需将模式串的第k个字符和主串的第i个字符对齐，此时模式串的前k-1个字符的子串必定与主串的第i个字符之前长度为k-1的子串相等，因此，只需从模式串的第k个字符与主串的第i个字符进行比较即可，如图4.3所示。

<table><tr><td>主串</td><td>\( S_1 \)</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>\( S_{i-k+1} \)</td><td>...</td><td>\( S_{i-1} \)</td><td>\( S_i \)</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>\( S_n \)</td></tr><tr><td>子串</td><td></td><td></td><td>\( p_1 \)</td><td>...</td><td>\( p_{k-1} \)</td><td>...</td><td>\( p_{j-k+1} \)</td><td>...</td><td>\( p_{j-1} \)</td><td>\( p_j \)</td><td>...</td><td>\( p_m \)</td><td></td><td></td><td></td><td></td></tr><tr><td>右滑</td><td></td><td></td><td></td><td></td><td></td><td></td><td>\( p_1 \)</td><td>...</td><td>\( p_{k-1} \)</td><td>\( p_k \)</td><td>...</td><td>...</td><td>\( p_m \)</td><td></td><td></td><td></td></tr></table>

图4.3 模式串右滑到合适位置（阴影对齐部分表示上下字符相等）

当模式串已匹配相等序列中不存在满足上述条件的子串时（可视为  $k = 1$ ），显然应让主串的第i个字符和模式串的第1个字符进行比较。

当模式串的第1个字符（  $j = 1$  ）与主串的第i个字符发生失配时，规定next[1]  $= 0$  。

通过上述分析可以得出 next 函数的公式：

$$
\operatorname {n e x t} [ j ] = \left\{ \begin{array}{l l} 0, & j = 1 \\ \max  \left\{k \mid 1 <   k <   j \text {且} ^ {\prime} p _ {1} \dots p _ {k - 1} ^ {\prime} = ^ {\prime} p _ {j - k + 1} \dots p _ {j - 1} ^ {\prime} \right\}, & \text {当 此 集 合 不 为 空 时} \\ 1, & \text {其 他 情 况} \end{array} \right.
$$

要用代码来实现，难度貌似还不小，下面来尝试推理求解的科学步骤。

首先由公式可知

$$
\mathrm {n e x t} [ 1 ] = 0
$$

设 next[j] = k，此时 k 应满足的条件在上文中已描述。

此时 next[j+1] = ? 可能有两种情况：

（1）若  $\mathsf{p_k = p_j}$  ，则表明在模式串中

$$
' p _ {1} \dots p _ {k - 1} p _ {k} ^ {\prime} = ^ {\prime} p _ {j - k + 1} \dots p _ {j - 1} p _ {j} ^ {\prime}
$$

且不可能存在  $\mathrm{k}^{\prime} > \mathrm{k}$  满足上述条件，此时 next  $[j + 1] = k + 1$  ，即

$$
\text {n e x t} [ j + 1 ] = \text {n e x t} [ j ] + 1
$$

（2）若  $p_k \neq p_j$ ，则表明在模式串中

$$
' p _ {1} \dots p _ {k - 1} p _ {k} ^ {\prime} \neq^ {\prime} p _ {j - k + 1} \dots p _ {j - 1} p _ {j} ^ {\prime}
$$

此时可将求 next 函数值的问题视为一个模式匹配问题。用前缀  $p_1 \cdots p_k$  去与后缀  $p_{j-k+1} \cdots p_j$  匹配，当  $p_k \neq p_j$  时，应将  $p_1 \cdots p_k$  向右滑动至用第 next[k] 个字符与  $p_j$  进行比较，若  $p_{\text{next}[k]}$  与  $p_j$  仍不匹配，则需要寻找长度更短的相等前后缀，下一步继续用  $P_{\text{next[next[k]}}$  与  $p_j$  进行较，以此类推，直到找到某个更小的  $k' = \text{next[next[...]}\left(1 < k' < k < j\right)$ ，满足条件

$$
' p _ {1} \dots p _ {k ^ {\prime}} ^ {\prime} = ^ {\prime} p _ {j - k ^ {\prime} + 1} \dots p _ {j} ^ {\prime}
$$

则 next[j+1] = k' + 1。

也可能不存在任何  $\mathrm{k}^{\prime}$  满足上述条件，即不存在长度更短的相等前后缀，令 next[j+1]=1。

理解起来有点儿费劲？下面举一个简单的例子。

图4.4的模式串中已求得6个字符的next值，现求next[7]，因为  $\mathrm{next}[6] = 3$ ，又  $\mathsf{p}_6\neq \mathsf{p}_3$  所以需要比较  $\mathbb{P}_6$  和  $\mathbb{P}_1$  （因  $\mathrm{next}[3] = 1$ ），  $\mathbb{P}_6\neq \mathbb{P}_1$ ，而  $\mathrm{next}[1] = 0$ ，因此  $\mathrm{next}[7] = 1$ ；求  $\mathrm{next}[8]$ ，因为  $\mathbb{P}_7 = \mathbb{P}_1$ ，所以  $\mathrm{next}[8] = \mathrm{next}[7] + 1 = 2$ ；求  $\mathrm{next}[9]$ ，因为  $\mathbb{P}_8 = \mathbb{P}_2$ ，所以  $\mathrm{next}[9] = 3$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5c2ef5a972f65a953ca9633ca909da7494ceb359e0ca9549bcd92fd3c60d3f37.jpg)



图4.4 求模式串的 next 值


# *4. KMP算法的实现

通过上述分析写出求 next 值的程序如下：

```txt
void get_next(SSString T,int next[]) { int  $i = 1$  ，  $j = 0$  · next[1]  $\equiv 0$  · while(i<T.length）{ if  $(\mathrm{j} = = 0||\mathrm{T}.ch[i] == \mathrm{T}.ch[j])$  { ++i；++j; next[i]=j；//若  $\mathfrak{p}_{\mathrm{i}} = \mathfrak{p}_{\mathrm{j}}$  ，则next[j+1]=next[j]+1 }
```

```txt
else j=next[j]；//否则令j=next[j]，循环继续}
```

计算机执行起来效率很高，但需要手工计算时，仍然采用前面的方法。

与 next 数组的求解相比，KMP 的匹配算法相对要简单很多，它在形式上与简单的模式匹配算法很相似。不同之处仅在于当匹配过程产生失配时，指针 i 不变，指针 j 退回到 next[j] 的位置并重新进行比较，且当指针 j 为 0 时，指针 i 和 j 同时加 1。也就是说，若主串的第 i 个位置和模式串的第 1 个字符不等，则应从主串的第 i+1 个位置开始匹配。具体代码如下：

```javascript
int Index_KMP(String S,SString T,int next[]) { int i=1，j=1; while(i<=S.length&&j<=T.length) { if(j==0||S.ch[i] ==T.ch[j]) { ++i；++j; //继续比较后继字符 } else j  $=$  next[j]; //模式串向右滑动 } if(j>T.length) return i-T.length; //匹配成功 else return 0;   
}
```

尽管普通模式匹配的时间复杂度是  $O(mn)$ ，KMP算法的时间复杂度是  $O(m + n)$ ，但在一般情况下，普通模式匹配的实际执行时间复杂度近似为  $O(m + n)$ ，因此至今仍被采用。KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快，其主要优点是主串不回溯。

# 4.2.3 KMP算法的进一步优化

# 命题追踪 nextval数组的计算（2024）

前面定义的 next 数组在某些情况下尚有缺陷，还可以进一步优化。如图 4.5 所示，模式串 'aaaab' 在和主串 'aaabaaaab' 进行匹配时。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f844f2f0d7c171ab74a64b4095c36687574350c3f3490a3c7bd49b84ec04e565.jpg)



图4.5 KMP算法进一步优化示例


当  $i = 4$  、  $j = 4$  时，  $\mathbf{s}_4$  跟  $\mathrm{p_4}$  （  $b\neq a$  ）失配，若用之前的next数组，则还需要进行  $\mathbf{s}_4$  与  $\mathfrak{p}_3$  、s4与  $\mathbb{P}_2$  、  $\mathbf{s}_4$  与  $\mathfrak{p}_1$  这3次比较。事实上，因为  $\mathrm{p_{next[4] = 3} = p_4 = a}$  、  $\mathrm{p_{next[3] = 2} = p_3 = a}$  、  $\mathrm{p_{next[2] = 1} = p_2 = a}$  显然后而3次用一个和  $\mathbb{P}_4$  相同的字符跟  $\mathbf{s}_4$  比较毫无意义，必然失配。那么问题出在哪里呢？

问题在于不应该出现  $p_j = p_{\text{next}[j]}$  。理由是：当  $p_j \neq s_i$  时，下次匹配必然是  $p_{\text{next}[j]}$  跟  $s_i$  比较，若  $p_j = p_{\text{next}[j]}$ ，则相当于拿一个和  $p_j$  相等的字符跟  $s_i$  比较，这必然导致继续失配，这样的比较毫无意义。若出现  $p_j = p_{\text{next}[j]}$ ，则如何处理呢？

若出现  $p_j = p_{\text{next}[j]}$ ，则需要再次递归，将 next[j] 修正为 next next[j]，直至两者不相等为止，更新后的数组命名为 nextval。计算 next 数组修正值的算法如下，此时匹配算法不变。

```txt
void get_nextval(SSstring T,int nextval[]) {
```

```txt
int i=1, j=0;  
nextval[1]=0;  
while(i<T.length) {  
    if(j==0||T.ch[i] == T.ch[j]) {  
        ++i; ++j;  
        if(T.ch[i] != T.ch[j]) nextval[i] = j;  
        else nextval[i] = nextval[j];  
    }  
    else  
        j = nextval[j];  
}
```

KMP算法对于初学者来说可能不太容易掌握，建议读者结合王道课程来理解。

# 4.2.4 本节试题精选

# 一、单项选择题

01. 设有两个串  $S_{1}$  和  $S_{2}$ ，求  $S_{2}$  在  $S_{1}$  中首次出现的位置的运算称为（）。

A. 求子串

B. 判断是否相等

C. 模式匹配

D. 连接

02. KMP算法的特点是在模式匹配时，指示主串的指针（）。

A. 不会变大

B. 不会变小

C. 都有可能

D. 无法判断

03. 设主串的长度为  $n$ ，子串的长度为  $m$ ，则简单的模式匹配算法的时间复杂度为（），KMP算法的时间复杂度为（）。

A.  $O(m)$

B.  $O(n)$

C.  $O(mn)$

D.  $O(m + n)$

04. 在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位 j 与主串位 i 比较时，两个字符不相等，则 j 的位移方式是（）。

A.  $j = 0$

B.  $j = j + 1$

C.  $j$  不变

D.  $j = \text{next}[j]$

05. 在 KMP 算法中，用 next 数组存放模式串的部分匹配信息，当模式串位 j 与主串位 i 比较时，两个字符不相等，则 i 的位移方式是（）。

A.  $i = \text{next}[i]$

B. i 不变

C.  $i = 0$

D.  $i = i + 1$

06.串'ababaaababaaa'的next数组为（）。

A.  $0,1,2,3,4,5,6,7,8,9,9$

B.  $0, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2$

C.  $0,1,1,2,3,4,2,2,3,4,5,6$

D.  $0, 1, 2, 3, 0, 1, 2, 3, 2, 2, 3, 4, 5$

07. 串'ababaaababaa'的next数组为（）。

A.  $-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8$

B.  $-1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1$

C.  $-1, 0, 0, 1, 2, 3, 1, 1, 2, 3, 4, 5$

D.  $-1, 0, 1, 2, -1, 0, 1, 2, 1, 1, 2, 3$

08. 设主串  $S =$  'aabaaaba'，模式串  $T =$  'aaab'，采用 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是（）。

A. 10

B. 9

C. 8

D. 7

09. 设主串  $S =$  'aabaaaba'，模式串  $T =$  'aaab'，采用改进后的 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是（）。

A. 9

B. 8

C. 7

D. 6

10. KMP算法使用nextval数组进行模式匹配，模式串为S='ababaaa'，当主串中的某字符与S中的第6个字符失配时，S向右滑动的距离是（）。

A. 1

B. 2

C. 3

D. 4

11.【2015统考真题】已知字符串s为'abaabaabacacaabaabcc'，模式串t为'abaabc'。

采用KMP算法进行匹配，第一次出现“失配”（ $s[i] \neq t[j]$ ）时， $i = j = 5$ ，则下次开始匹配时，i和j的值分别是（）。

A.  $i = 1, j = 0$

B.  $i = 5, j = 0$

C.  $i = 5, j = 2$

D.  $i = 6, j = 2$

12.【2019统考真题】设主串  $\mathrm{T} = {}^{\prime}$  abaabaabcabaabc'，模式串  $S = {}^{\prime}$ abaabc'，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是（）。

A. 9

B. 10

C. 12

D. 15

13.【2024统考真题】KMP算法使用修正后的next数组进行模式匹配，模式串为  $S =$  'aabaab'，当主串的某个字符与S的某个字符失配时，S向右滑动的最长距离是（）。

A. 5

B. 4

C. 3

D. 2

# 二、综合应用题

01. 在字符串模式匹配的 KMP 算法中，求模式的 next 数组值的定义如下：

next[j]=  $\left\{ \begin{array}{ll}0, & j = 1\\ \max \{k|1 <   k <   j\text{且} 'p_{1}\dots p_{k - 1}' = 'p_{j - k + 1}\dots p_{j - 1}'\} ,\\ 1, & \text{其他情况} \end{array} \right.$  集合不为空

1）当  $j = 1$  时，为什么要取 next[1] = 0？

2）为什么要取  $\max \{k\}$ ， $k$  最大是多少？

3）其他情况是什么情况，为什么取 next[j] = 1？

02. 设有字符串  $S = {}^{\prime }$  aabaabaabaac',  $P = {}^{\prime }$  aabaac'。

1）求出P的next数组。

2）若S作主串，P作模式串，试给出KMP算法的匹配过程。

# 4.2.5 答案与解析

# 一、单项选择题

01. C

求子串操作是从串  $S$  中截取第  $i$  个字符起长度为  $l$  的子串，选项A错误。选项B、D明显错误。

02. B

在KMP算法的比较过程中，主串不会回溯，所以主串的指针不会变小。

03. C、D

尽管实际应用中，一般情况下简单的模式匹配算法的时间复杂度近似为  $O(m + n)$ ，但它的理论时间复杂度还是  $O(mn)$ 。KMP算法的时间复杂度为  $O(m + n)$ 。

04. D

在KMP算法中，当主串的第i个字符和模式串的第j个字符不匹配时，主串的位指针i不变，将主串的第i个字符与模式串的第next[j]个字符比较，即  $j = \text{next}[j]$ 。

05. B

在KMP算法中，当主串的第i个字符和模式串的第j个字符失配时，主串指针i不回溯。

06. C

本题采用先求串  $S = {}^{\prime}$  ababaaababaaa'的部分匹配值,再求 next 数组的方法。

- 'a'的前后缀都为空，最长相等前后缀长度为0。

- 'ab'的前缀  $\{a\} \cap$  后缀  $\{b\} = \emptyset$  ，长相等前后缀长度为0。

- 'aba'的前缀{a,ab}∩后缀{a,ba}={a},最长相等前后缀长度为1。

- 'abab'的前缀{a, ab, aba}∩后缀{b, ab, bab}={ab},最长相等前后缀长度为2。

.

依次求出的部分匹配值见下表第3行，将其整体右移一位，低位用-1填充，见下表第4行。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td>S</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>PM</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></table>

选项中 next[1]等于0，所以将 next 数组整体加 1。

# 07. C

解析见上题。读者也可尝试用前面介绍的手算方法。

注意，next数组是否整体加1都正确，需根据题意具体分析。

# 08. B

假设位序从1开始的，手工计算出T的next数组如下。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>S</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>next</td><td>0</td><td>1</td><td>2</td><td>3</td></tr></table>

采用KMP匹配算法时：第一趟，经过3次比较后，发现S[3]  $\neq$  T[3]；第二趟，用S[3]和T[2]（next[3]=2）比较，不相等；第三趟，用S[3]和T[1]（next[2]=1）比较，不相等；第四趟，next[1]=0，因此开始用S[4]和T[1]比较，经过4次比较后，匹配成功。整个匹配过程如下。

<table><tr><td></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>第一趟</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td></tr><tr><td>第二趟</td><td></td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td></tr><tr><td>第三趟</td><td></td><td></td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td></tr><tr><td>第四趟</td><td></td><td></td><td></td><td>a</td><td>a</td><td>a</td><td>b</td><td></td></tr></table>

总比较次数为  $3 + 1 + 1 + 4 = 9$

# 09. C

假设位序从1开始的，计算出T的nextval数组如下。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>S</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>nextval</td><td>0</td><td>0</td><td>0</td><td>3</td></tr></table>

采用改进的KMP匹配算法时：第一趟，经过3次比较后，发现S[3]  $\neq$  T[3]；第二趟，nextval[3]=0，因此开始用S[4]和T[1]比较，经过4次比较后，匹配成功。整个匹配过程如下。

<table><tr><td></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>第一趟</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td></tr><tr><td>第二趟</td><td></td><td></td><td></td><td>a</td><td>a</td><td>a</td><td>b</td><td></td></tr></table>

总比较次数为  $3 + 4 = 7$

# 10. B

假设位序从0开始的，计算出nextval数组。当比较到S[j]失配时，模式串向右滑动的距离为  $j - \text{nextval}[j]$  （ $0 \leq j \leq 6$ ），由下图可知，当  $j = 5$  时向右滑动的距离为  $5 - 3 = 2$ 。

<table><tr><td>编号j</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>S[j]</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td></tr><tr><td>next[j]</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td></tr><tr><td>nextval[j]</td><td>-1</td><td>0</td><td>-1</td><td>0</td><td>-1</td><td>3</td><td>1</td></tr><tr><td>j-nextval[j]</td><td>1</td><td>1</td><td>3</td><td>3</td><td>5</td><td>2</td><td>5</td></tr></table>

此外，若对KMP算法很熟悉，则此类题也可直接动手模拟，而不需要求nextval数组，与第6个字符匹配失败，说明前面的ababa匹配成功，S可向右滑动2位继续尝试匹配。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9480fdf527f258ec6de4d29dadd77ecac5cfc3a6990b9e311ea65f93d1e7ab61.jpg)


11. C

由题中“失配  $s[i] \neq t[j]$  时， $i = j = 5$ ”，可知题中的主串和模式串的位序都是从0开始的（要注意灵活应变）。按照next数组生成算法，对于t有

<table><tr><td>编号</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>t</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td></tr></table>

发生失配时，主串指针i不变，子串指针j回退到next[j]位置重新比较，当s[i]≠t[j]时，i=j=5，由next表得知next[j]=next[5]=2（位序从0开始）。因此，i=5，j=2。

12. B

假设位序从0开始的，按照next数组生成算法，对于S有

<table><tr><td>编号</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>S</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td></tr></table>

第一趟连续比较6次，在模式串的5号位和主串的5号位匹配失败，模式串的下一个比较位置为next[5]，即下一次比较从模式串的2号位和主串的5号位开始，然后直到模式串的5号位和主串的8号位匹配，第二趟比较4次，匹配成功。单个字符的比较次数为10次。

13. A

假设位序从0开始的，计算出nextval数组。当比较到S[j]失配时，模式串向右滑动的距离为  $j^{-}nextval[j](0 \leqslant j \leqslant 5)$ ，由下图可知，当  $j = 4$  时向右滑动的距离最长，此时距离为5。

<table><tr><td>编号j</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>S[j]</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td></tr><tr><td>next[j]</td><td>-1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td></tr><tr><td>nextval[j]</td><td>-1</td><td>-1</td><td>1</td><td>-1</td><td>-1</td><td>1</td></tr><tr><td>j NEXTVAL[j]</td><td>1</td><td>2</td><td>1</td><td>4</td><td>5</td><td>4</td></tr></table>

# 二、综合应用题

# 01. 【解答】

1）当模式串的第1个字符与主串的当前字符比较不相等时，next[1] = 0，表示模式串应右滑一位，主串当前指针后移一位，再和模式串的第1个字符进行比较。

2）当主串的第i个字符与模式串的第j个字符失配时，主串i不回溯，则假定模式串的第k个字符与主串的第i个字符比较，k值应满足条件  $1 < k < j$  且  $\mathrm{p_1\dots p_{k - 1} = 'p_{j - k + 1}\dots p_{j - 1}}$  即  $\mathbf{k}$  为模式串的下次比较位置。k值可能有多个，为了不使向右滑动丢失可能的匹配，右滑距离应该取最小，因为  $\mathrm{j - k}$  表示右滑的距离，所以取max{k}。k的最大值为j-1。

3）除上面两种情况外，发生失配时，主串指针i不回溯，在最坏情况下，模式串从第1个字符开始与主串的第i个字符比较。

# 02. 【解答】

1）  $\mathsf{P} =$  'aabaac'，按照next数组生成算法，对于P有：

① 设 next[1] = 0，next[2] = 1。

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>S</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr><tr><td>next</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td></tr></table>

②  $j = 3$  时  $k = \text{next}[j - 1] = \text{next}[2] = 1$ ，观察  $S[j - 1]$ （ $S[2]$ ）与  $S[k]$ （ $S[1]$ ）是否相等， $S[2] = a$ ， $S[1] = a$ ， $S[2] = S[1]$ ，所以 next[j] = k + 1 = 2。

```txt
↓j-1=2 a a b a a c a a b a a a k=1
```

③  $j = 4$  时  $k = \text{next}[j - 1] = \text{next}[3] = 2$  ，观察S[j-1](S[3])与S[k](S[2])是否相等， $S[3] = b$  ， $S[2] = a$  ， $S[3] != S[2]$  。

```txt
↓j-1=3 a a b a a c a a b a a a k=2
```

此时  $k = \text{next}[k] = 1$ ，观察S[3]与S[k](S[1])是否相等， $S[3] = b$ ， $S[1] = a$ ， $S[3] != S[1]$ 。 $k = \text{next}[k] = 0$ ，因为  $k = 0$ ，所以  $n e x t[j] = 1$ 。

```txt
↓j-1=3 a a b a a c a a b a b a a C  $\uparrow k = 0$
```

④  $j = 5$  时  $k = \text{next}[j - 1] = \text{next}[4] = 1$  ，观察S[j-1](S[4])与S[k](S[1])是否相等， $S[4] = a$  ， $S[1] = a$  ， $S[4] = S[1]$  ，所以 next[j]=k+1=2。

```txt
↓j-1=4 a a b a a c a a b a a a k=1
```

⑤  $j = 6$  时  $k = \text{next}[j - 1] = \text{next}[5] = 2$  ，观察S[j-1](S[5])与S[k](S[2])是否相等， $S[5] = a$  ， $S[2] = a$  ， $S[5] = S[2]$  ，所以  $n e x t[j] = k + 1 = 3$  。

```txt
↓j-1=5 a a b a a c a a b a a a a C  $\uparrow k = 2$
```

最后的结果为

<table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>S</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr><tr><td>next</td><td>0</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td></tr></table>

也可以通过求部分匹配值表的方法来求 next 数组。

2）利用KMP算法的匹配过程如下。

第一趟：从主串和模式串的第1个字符开始比较，失配时  $i = 6$  ，  $j = 6$  。

<table><tr><td>主串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr><tr><td></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>

第二趟：next  $[6] = 3$  ，主串当前位置和模式串的第3个字符继续比较，失配时  $i = 9$  ，  $j = 6$  。

<table><tr><td>主串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td><td></td><td></td><td></td></tr></table>

第三趟：next  $[6] = 3$  ，主串当前位置和模式串的第3个字符继续比较，匹配成功。

<table><tr><td>主串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>c</td></tr></table>

# 归纳总结

学习KMP算法时，应从分析暴力法的弊端入手，思考如何去优化它。实际上，已匹配相等的序列就是模式串的某个前缀，因此每次回溯就相当于模式串与模式串的某个前缀在比较，这种频繁的重复比较是其效率低的原因。这时，可从分析模式串本身的结构入手，以便得知当匹配到某个字符不等时，应该向右滑动到什么位置，即已匹配相等的某个前缀若与模式串首尾重合，则对齐它们，对齐部分显然无需再比较，然后直接从主串的当前位置继续开始比较。

# 思维拓展

编程实现：模式串在主串中有多少个完全匹配的子串？注意，统考不考KMP算法题。

# 树与二叉树

# 【考纲内容】

# （一）树的基本概念

# （二）二叉树

二叉树的定义及其主要特征；二叉树的顺序存储结构和链式存储结构；

二叉树的遍历；线索二叉树的基本概念和构造

# （三）树、森林

树的存储结构；森林与二叉树的转换；树和森林的遍历

# （四）树与二叉树的应用

哈夫曼（Huffman）树和哈夫曼编码；并查集及其应用；堆及其应用

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/766f536f13f2ebd8026399375ac59b92ed21503bbeb8875847a36da12159b211.jpg)



扫一扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9d5daacedbb771eb0974d429da1684239aee540fa2d155668a8b6f3474f1db2c.jpg)



视频讲解


# 【复习提示】

本章内容多以选择题或综合题的形式考查，但统考也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，都是选择题必然会涉及的内容。

# 5.1 树的基本概念

# 5.1.1 树的定义

树是  $n$  （  $n\geq 0$  ）个结点的有限集。当  $n = 0$  时，称为空树。在任意一棵非空树中应满足：

1）有且仅有一个特定的称为根的结点。

2）当  $n > 1$  时，其余结点可分为  $m(m > 0)$  个互不相交的有限集  $T_{1}, T_{2}, \dots, T_{m}$ ，其中每个集合本身又是一棵树，并且称为根的子树。

显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：

1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。

2）树中所有结点都可以有零个或多个后继。

树适用于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（其父结点）有直接关系，根结点没有直接上层结点，因此在  $n$  个结点的树中有  $n - 1$  条边。而树中每个结点与其下一层的零个或多个结点（其孩子结点）都有直接关系。

# 5.1.2 基本术语

下面结合图5.1中的树来说明一些基本术语和概念。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/212a82a47279dc786b70ab276c77bf57bc353cadd4eafea95746d71020cd7b35.jpg)



图5.1 树的树形表示


1）祖先、子孙、双亲、孩子、兄弟和堂兄弟。

考虑结点  $K$  ，从根  $A$  到结点  $K$  的唯一路径上的所有其他结点，称为结点  $K$  的祖先。如结点  $B$  是结点  $K$  的祖先，而  $K$  是  $B$  的子孙，结点  $B$  的子孙包括  $E, F, K, L$  。路径上最接近结点  $K$  的结点  $E$  称为  $K$  的双亲，而  $K$  为  $E$  的孩子。根  $A$  是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟，如结点  $K$  和结点  $L$  有相同的双亲  $E$  ，即  $K$  和  $L$  为兄弟。双亲在同一层的结点互为堂兄弟，结点  $G$  与  $E, F, H, I, J$  互为堂兄弟。

2）结点的层次、深度和高度。

结点的层次从树根开始定义，根结点为第1层，它的孩子为第2层，以此类推。结点的深度就是结点所在的层次。树的高度（或深度）是树中结点的最大层数。结点的高度是以该结点为根的子树的高度。图5.1中树的高度为4。

3）结点的度和树的度。

树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点  $B$  的度为2，结点  $D$  的度为3，树的度为3。

4）分支结点和叶结点。

度大于0的结点称为分支结点（也称非终端结点）；度为0（没有孩子结点）的结点称为叶结点（也称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。

5）有序树和无序树。

树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。假设图5.1为有序树，若将子结点位置互换，则变成一棵不同的树。

6）路径和路径长度。

树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。

# 注意

因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。

7）森林。

# 命题追踪 森林中树的数量、边数和结点数的关系（2016）

森林是  $m(m\geqslant 0)$  棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给  $m$  棵独立的树加上一个结点，并把这  $m$  棵树作为该结点的子树，则森林就变成了树。

# 注意

上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。

# 5.1.3 树的性质

树具有如下最基本的性质：

# 命题追踪 树中结点数和度数的关系的应用（2010、2016）

1）树的结点数  $n$  等于所有结点的度数之和加1。

结点的度是指该结点的孩子数量，每个结点与其每个孩子都由唯一的边相连，因此树中所有结点的度数之和等于树中的边数之和。树中的结点（除根外）都有唯一的双亲，因此结点数  $n$  等于边数之和加1，即所有结点的度数之和加1。

2）度为  $m$  的树中第  $i$  层上至多有  $m^{i - 1}$  个结点（ $i\geqslant 1$ ）。

第1层至多有1个结点（根结点），第2层至多有  $m$  个结点，第3层至多有  $m^2$  个结点，以此类推。使用数学归纳法可推出第  $i$  层至多有  $m^{i - 1}$  个结点。

3）高度为  $h$  的  $m$  叉树至多有  $(m^{h} - 1) / (m - 1)$  个结点。

当各层结点数达到最大时，树中至多有  $1 + m + m^2 + \dots + m^{h - 1} = (m^h - 1) / (m - 1)$  个结点。

# 命题追踪 指定结点数的三叉树的最小高度分析（2022）

4）度为  $m$  、具有  $n$  个结点的树的最小高度  $h$  为  $\left[\log_{m}(n(m - 1) + 1)\right]$  。

为使树的高度最小，在前  $h - 1$  层中，每层的结点数都要达到最大，前  $h - 1$  层最多有  $(m^{h - l} - 1) / (m - 1)$  个结点，前  $h$  层最多有  $(m^h -1) / (m - 1)$  个结点。因此  $(m^{h - l} - 1) / (m - 1) < n\leqslant$ $(m^{h} - 1) / (m - 1)$  ，即  $h - 1 < \log_m(n(m - 1) + 1)\leqslant h$  ，解得  $h_{\mathrm{min}} = \lceil \log_m(n(m - 1) + 1)\rceil$  。

5）度为  $m$  、具有  $n$  个结点的树的最大高度  $h$  为  $n - m + 1$  。

树的度为  $m$ ，因此至少有一个结点有  $m$  个孩子，它们处于同一层。为使树的高度最大，其他层可仅有一个结点，因此最大高度（层数）为  $n - m + 1$  。由此，也可逆推出高度为  $h$  、度为  $m$  的树至少有  $h + m - 1$  个结点。

# 5.1.4 本节试题精选

# 一、单项选择题

01. 树最适合用来表示（）的数据。

A. 有序

B. 无序

C. 任意元素之间具有多种联系

D. 元素之间具有分支层次关系

02.一棵有  $n$  个结点的树的所有结点的度数之和为（）。

A.  $n - 1$

B.  $n$

C.  $n + 1$

D.  $2 n$

03. 树的路径长度是从树根到每个结点的路径长度的（）。

A. 总和

B. 最小值

C. 最大值

D. 平均值

04. 对于一棵具有  $n$  个结点、度为 4 的树来说，（）。

A. 树的高度至多是  $n - 3$

B. 树的高度至多是  $n - 4$

C. 第  $i$  层上至多有  $4(i - 1)$  个结点

D. 至少在某一层上正好有 4 个结点

05. 度为4、高度为  $h$  的树，（）。

A. 至少有  $h + 3$  个结点

B. 至多有  $4h - 1$  个结点

C. 至多有  $4h$  个结点

D. 至少有  $h + 4$  个结点

06. 假定一棵度为3的树中，结点数为50，则其最小高度为（）。

A. 3

B. 4

C. 5

D. 6

07. 设有一棵度为 3 的树，其中度为 3 的结点数  $n_3 = 2$ ，度为 2 的结点数  $n_2 = 1$ ，叶结点数  $n_0 = 6$ ，则该树的结点总数为（）。

A. 12

B. 9

C. 10

D.  $\geqslant 9$  的任意整数

08. 设一棵  $m$  叉树中有  $N_{1}$  个度数为 1 的结点， $N_{2}$  个度数为 2 的结点…… $N_{m}$  个度数为  $m$  的结点，则该树中共有（）个叶结点。

A.  $\sum_{i=1}^{m}(i-1)N_{i}$

B.  $\sum_{i=1}^{m} N_{i}$

C.  $\sum_{i=2}^{m}(i-1)N_{i}$

D.  $\sum_{i=2}^{m}(i-1)N_{i}+1$

09.【2010统考真题】在一棵度为4的树  $T$  中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树  $T$  的叶结点个数是（）。

A. 41

B. 82

C. 113

D. 122

10.【2016统考真题】若森林  $F$  有15条边、25个结点，则  $F$  包含树的个数是（）。

A. 8

B. 9

C. 10

D. 11

# 二、综合应用题

01. 含有  $n$  个结点的三叉树的最小高度是多少？

02. 已知一棵度为 4 的树中，度为 0,1,2,3 的结点数分别为 14,4,3,2，求该树的结点总数  $n$  和度为 4 的结点个数，并给出推导过程。

03. 已知一棵度为  $m$  的树中，有  $n_1$  个度为 1 的结点，有  $n_2$  个度为 2 的结点……有  $n_m$  个度为  $m$  的结点，问该树有多少个叶结点？

# 5.1.5 答案与解析

# 一、单项选择题

01. D

树是一种分层结构，它特别适合组织那些具有分支层次关系的数据。

02. A

除根结点外，其他每个结点都是某个结点的孩子，因此树中所有结点的度数加1等于结点数，

即所有结点的度数之和等于总结点数减1。这是一个重要的结论，做题时经常用到。

# 03. A

树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是树的高度减1。注意与哈夫曼树的带权路径长度相区别。

# 04. A

要使得具有  $n$  个结点、度为4的树的高度最大，就要使得每层的结点数尽可能少，类似下图所示的树，除最后一层外，每层的结点数是1，最终该树的高度为  $n - 3$  。树的度为4只能说明存在某结点正好（也最多）有4个孩子结点，选项D错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2d2b5f5cd14fa564cce3f7a14976674700345b8385324723159ead54b63ebc6f.jpg)


# 05. A

要使得度为4、高度为  $h$  的树的总结点数最少，需要满足以下两个条件：

① 至少有一个结点有4个分支。

$②$  每层的结点数目尽可能少。

情况类似下图所示的树，结点个数为  $h + 3$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0af0a0d7ac89e51f953385729184cb3de23f394bbdd17866b6e909762ecaf69f.jpg)


要使得度为4、高度为  $h$  的树的总结点数最多，应使每个非叶结点的度均为4，即满树，总结点个数最多为  $1 + 4 + 4^{2} + \dots + 4^{h - 1}$ 。

对于上面的两题，应画出草图来求解，就能一目了然。

# 06. C

要求满足条件的树，那么该树是一棵完全三叉树。在度为3的完全三叉树中，第1层有1个结点，第2层有  $3^{1} = 3$  个结点，第3层有  $3^{2} = 9$  个结点，第4层有  $3^{3} = 27$  个结点，因此结点数之和为  $1 + 3 + 9 + 27 = 40$ ，第5层的结点数  $= 50 - 40 = 10$  个，因此最小高度为5。

# 07. D

总结点数  $n = n_0 + n_1 + n_2 + n_3 = 6 + n_1 + 1 + 2 = n_1 + 9$  ，总度数  $= n - 1 = n_{1} + 2n_{2} + 3n_{3} = n_{1} + 2 + 6 =$ $n_1 + 8$  ，根据题目条件无法得出  $n$  的具体值，只能证明  $n$  是一个大于或等于9的任意整数。画出满足题目条件的树，可以是如下图所示的一棵树，该树中无法确定  $n$  的具体数量。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/11b22f31c6339158eaf5f7582e5daef0b6cc0fd970b898fd388b6289f4833c9d.jpg)


08. D

设叶结点数为  $N_{0}$ ，总结点数为  $N$ ，则  $N = N_{1} + 2N_{2} + 3N_{3} + \dots + mN_{m} + 1$ ，又因为  $N = N_{0} + N_{1} + N_{2} + N_{3} + \dots + N_{m}$ ，所以  $N_{0} = N_{2} + 2N_{3} + \dots + (m - 1)N_{m} + 1 = \sum_{i=2}^{m}(i - 1)N_{i} + 1$ 。

09.B

设树中度为  $i$  （ $i = 0,1,2,3,4$ ）的结点数分别为  $n_i$ ，树中结点总数为  $n$ ，则  $n =$  分支数  $+1$ ，而分支数又等于树中各结点的度之和，即  $n = 1 + n_1 + 2n_2 + 3n_3 + 4n_4 = n_0 + n_1 + n_2 + n_3 + n_4$ 。依题意， $n_1 + 2n_2 + 3n_3 + 4n_4 = 10 + 2 + 30 + 80 = 122$ ， $n_1 + n_2 + n_3 + n_4 = 10 + 1 + 10 + 20 = 41$ ，可得出  $n_0 = 82$ ，即树  $T$  的叶结点的个数是82。

10. C

解法1：树有一个重要性质，即在  $n$  个结点的树中有  $n - 1$  条边，“那么对于每棵树，其结点数比边数多1”。本题森林中的结点数比边数多10（ $25 - 15 = 10$ ），显然共有10棵树。

解法2：仔细分析后发现此题也是考查图的性质：生成树和生成森林。对于图的生成树有一个重要的性质，即图中顶点数若为  $n$  ，则其生成树含有  $n - 1$  条边。对比解法1中树的性质，不难发现两种解法都用到了性质“树中结点数比边数多1”，后面的分析如解法1。

# 二、综合应用题

# 01.【解答】

要求含有  $n$  个结点的三叉树的最小高度，那么满足条件的一定是一棵完全三叉树，设含有  $n$  个结点的完全三叉树的高度为  $h$  ，第  $h$  层至少有1个结点，至多有  $3^{h - 1}$  个结点。则有

$$
1 + 3 ^ {1} + 3 ^ {2} + \dots + 3 ^ {h - 2} <   n \leqslant 1 + 3 ^ {1} + 3 ^ {2} + \dots + 3 ^ {h - 2} + 3 ^ {h - 1}
$$

即  $(3^{h - 1} - 1) / 2 <   n\leqslant (3^h -1) / 2$  ，得  $3^{h - 1} <   2n + 1\leqslant 3^h$  ，即  $h <   \log_3(2n + 1) + 1$  ，  $h\geqslant \log_3(2n + 1)$  。

因为  $h$  只能为正整数，  $h = \lceil \log_3(2n + 1)\rceil$  ，所这种三叉树的最小高度是  $\lceil \log_3(2n + 1)\rceil$

# 02.【解答】

设树中度为  $i$  （ $i = 0,1,2,3,4$ ）的结点数为  $n_i$ ，则结点总数  $n = n_0 + n_1 + n_2 + n_3 + n_4$ ，即  $n = 23 + n_4$ ，根据“树中所有结点的度数加1等于结点数”的结论，有  $n = 0 + n_1 + 2n_2 + 3n_3 + 4n_4 + 1$ ，即有  $n = 17 + 4n_4$ 。

综合两式得  $n_4 = 2$  ，  $n = 25$  。所以该树的结点总数为25，度为4的结点个数为2。

# 03.【解答】

树中的结点数等于所有结点的度数加1，因此有  $n = \sum_{i=0}^{m} i n_{i} + 1 = n_{1} + 2n_{2} + 3n_{3} + \dots + mn_{m} + 1$ 。

又有  $n = n_0 + n_1 + n_2 + \dots + n_m$ ，所以

$$
\begin{array}{l} n _ {0} = \left(n _ {1} + 2 n _ {2} + 3 n _ {3} + \dots + m n _ {m} + 1\right) - \left(n _ {1} + n _ {2} + \dots + n _ {m}\right) \\ = n _ {2} + 2 n _ {3} + \dots + (m - 1) n _ {m} + 1 = 1 + \sum_ {i = 2} ^ {m} (i - 1) n _ {i} \\ \end{array}
$$

# 注意

综合以上几题，常用于求解树结点与度之间关系的有：

① 总结点数  $= n_{0} + n_{1} + n_{2} + \dots +n_{m}$

② 总分支数  $= 1n_{1} + 2n_{2} + \dots +mn_{m}$  （度为  $m$  的结点引出  $m$  条分支）。

③ 总结点数  $=$  总分支数  $+1$

这类题目常在选择题中出现，读者对以上关系应当熟练掌握并灵活应用。

# 5.2 二叉树的概念

# 5.2.1 二叉树的定义及其主要特性

# 1. 二叉树的定义

二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

与树相似，二叉树也以递归的形式定义。二叉树是  $n$  （ $n \geqslant 0$ ）个结点的有限集合：

① 或者为空二叉树，即  $n = 0$ 。

② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图5.2所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6bbe8460303a63dfebddc21d9c1b887f31af9aa2fcc42d6ece0af554aea08892.jpg)



图5.2 二叉树的5种基本形态


二叉树与度为2的有序树的区别：

① 度为2的树至少有3个结点，而二叉树可以为空。

② 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。

# 2. 几种特殊的二叉树

1）满二叉树。一棵高度为  $h$  ，且有  $2^{h} - 1$  个结点的二叉树称为满二叉树，即二叉树中的每层都含有最多的结点，如图5.3(a)所示。满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2。

可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为  $i$  的结点，若有双亲，则其双亲为  $\lfloor i / 2\rfloor$  若有左孩子，则左孩子为  $2i$  ；若有右孩子，则右孩子为  $2i + 1$  。

# 命题追踪 完全二叉树中结点数和叶结点数的关系（2009、2011、2018）

2）完全二叉树。高度为  $h$  、有  $n$  个结点的二叉树，当且仅当其每个结点都与高度为  $h$  的满二叉树中编号为  $1\sim n$  的结点一一对应时，称为完全二叉树，如图5.3(b)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e61cf1cd030d37c74d64b6cece1594ed0e0eda2bc189ce8d07d50fb17ffdda64.jpg)



(a) 满二叉树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/41ca5dbb1608132260f8283452263cc5576295f10e082c5af0e5d608123da795.jpg)



(b) 完全二叉树



图5.3 两种特殊形态的二叉树①


3）二叉排序树。左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。

4）平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。关于二叉排序树和平衡二叉树的详细介绍，见本书中的7.3节。

# 命题追踪 正则  $k$  叉树树高和结点数的关系的应用（2016）

5）正则二叉树。树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。

# 3. 二叉树的性质

1）非空二叉树上的叶结点数等于度为2的结点数加1，即  $n_0 = n_2 + 1$

证明：设度为0,1和2的结点个数分别为  $n_0,n_1$  和  $n_2$  ，结点总数  $n = n_{0} + n_{1} + n_{2}$  。

再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设  $B$  为分支总数，则  $n = B + 1$  。这些分支是由度为1或2的结点射出的，因此又有  $B = n_{1} + 2n_{2}$  。

于是得  $n_0 + n_1 + n_2 = n_1 + 2n_2 + 1$  ，则  $n_0 = n_2 + 1$  。

# 注意

该性质经常在选择题中涉及，希望读者牢记并灵活应用。

2）非空二叉树的第  $k$  层最多有  $2^{k - 1}$  个结点（ $k \geqslant 1$ ）。

第1层最多有  $2^{1 - 1} = 1$  个结点（根），第2层最多有  $2^{2 - 1} = 2$  个结点，以此类推，可以证明其为一个公比为2的等比数列  $2^{k - 1}$ 。

3）高度为  $h$  的二叉树至多有  $2^{h} - 1$  个结点（ $h \geqslant 1$ ）。

该性质利用性质2求前  $h$  项的和，即等比数列求和的结果。

# 注意

性质2和性质3还可以拓展到  $m$  叉树的情况，即  $m$  叉树的第  $k$  层最多有  $m^{k - 1}$  个结点，高度为  $h$  的  $m$  叉树至多有  $(m^h -1) / (m - 1)$  个结点。

4）对完全二叉树按从上到下、从左到右的顺序依次编号  $1,2,\dots ,n$  ，则有以下关系：

① 最后一个分支结点的编号为  $\lfloor n / 2\rfloor$  ，若  $i\leqslant \lfloor n / 2\rfloor$  ，则结点  $i$  为分支结点，否则为叶结点。

② 叶结点只可能在最后两层上出现（相当于在相同高度的满二叉树的最底层、最右边减少一些连续叶结点，当减少2个或以上叶结点时，次底层将出现叶结点）。

③ 若有度为1的结点，则最多只可能有一个，且该结点只有左孩子而无右孩子（度为1的分支结点只可能是最后一个分支结点，其结点编号为  $\lfloor n / 2\rfloor$ ）。

④ 按层序编号后，一旦出现某结点（如编号  $i$  ）为叶结点或只有左孩子的情况，则编号大于  $i$  的结点均为叶结点（与结论①和结论③是相通的）。

⑤ 若  $n$  为奇数，则每个分支结点都有左、右孩子；若  $n$  为偶数，则编号最大的分支结点（编号为  $n / 2$  ）只有左孩子，没有右孩子，其余分支结点都有左、右孩子。

⑥ 当  $i > 1$  时，结点  $i$  的双亲结点的编号为  $\lfloor i / 2\rfloor$

⑦ 若结点  $i$  有左、右孩子，则左孩子编号为  $2i$  ，右孩子编号为  $2i + 1$  。

⑧ 结点  $i$  所在层次（深度）为  $\left\lfloor \log_2 i \right\rfloor + 1$ 。

5）具有  $n$  个（  $n > 0$  ）结点的完全二叉树的高度为  $\lceil \log_2(n + 1)\rceil$  或  $\lfloor \log_2n\rfloor +1$

设高度为  $h$  ，根据性质3和完全二叉树的定义有

$$
2 ^ {h - 1} - 1 <   n \leqslant 2 ^ {h} - 1 \quad {\text {或 者}} \quad 2 ^ {h - 1} \leqslant n <   2 ^ {h}
$$

得  $2^{h - 1} < n + 1 \leqslant 2^h$  ，即  $h - 1 < \log_2(n + 1) \leqslant h$  ，因为  $h$  为正整数，所以  $h = \lceil \log_2(n + 1) \rceil$  或者得  $h - 1 \leqslant \log_2 n < h$  ，所以  $h = \lfloor \log_2 n \rfloor + 1$  。

# 5.2.2 二叉树的存储结构

# 1. 顺序存储结构

二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为  $i$  的结点元素存储在一维数组下标为  $i - 1$  的分量中。

依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。

# 命题追踪 特定条件下二叉树树形及占用存储空间的分析（2020）

但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为  $h$  且只有  $h$  个结点的单支树却需要占据近  $2^{h} - 1$  个存储单元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b09696ae10e491322bfaacdcdda788e1bc66579796aa7d9c546493b977b488bd.jpg)



(a) 完全二叉树的顺序存储结构


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3664d27a21776c1581dae76629cc717180c3917ca881c173e529d96d035743fd.jpg)



(b) 一般二叉树的顺序存储结构



图5.4 二叉树的顺序存储结构


# 注意

建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。

# 2. 链式存储结构

顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域data、左指针域lchild和右指针域rchild，如图5.5所示。

<table><tr><td>lchild</td><td>data</td><td>rchild</td></tr></table>


图5.5 二叉树链式存储的结点结构


图5.6所示为一棵二叉树及其对应的二叉链表。而实际上在不同的应用中，还可以增加某些指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/084de90fa2d22cd562736b497663c7093371b68e298e06e59945d7860de8894f.jpg)



图5.6 二叉链表的存储结构


二叉树的链式存储结构描述如下：

```javascript
typedef struct BiTreeNode{ElemType data; //数据域structBiTreeNode\*lchild,\*rchild; //左、右孩子指针}BiTreeNode,\*BiTree;
```

使用不同的存储结构时，实现二叉树操作的算法也会不同，因此要根据实际应用场合（二叉树的形态和需要进行的运算）来选择合适的存储结构。

容易验证，在含有  $n$  个结点的二叉链表中，含有  $n + 1$  个空链域（重要结论，经常出现在选择题中）。在下一节中，我们将利用这些空链域来组成另一种链表结构——线索链表。

# 5.2.3 本节试题精选

# 一、单项选择题

01. 下列关于二叉树的说法中，正确的是（）。

A. 度为 2 的有序树就是二叉树

B. 含有  $n$  个结点的二叉树的高度为  $\lfloor \log_2 n \rfloor + 1$

C. 在完全二叉树中, 若一个结点没有左孩子, 则它必是叶结点

D. 含有  $n$  个结点的完全二叉树的高度为  $\lceil \log_2 n \rceil$

02. “二叉树为空”意味着二叉树（）。

A. 根结点没有子树

B. 不存在

C. 没有结点

D. 由一些没有赋值的空结点构成

03. 下列关于完全二叉树的说法中，正确的是（）。

A. 在完全二叉树中，叶结点的双亲的左兄弟（若存在）一定不是叶结点

B. 任何一棵二叉树中, 叶结点数为度为 2 的结点数减 1 , 即  $n_{0} = n_{2} - 1$

C. 完全二叉树不适合顺序存储结构，只有满二叉树适合顺序存储结构

D. 结点按完全二叉树层序编号的二叉树中, 第  $i$  个结点的左孩子的编号为  $2i$

04. 具有 10 个叶结点的二叉树中有（）个度为 2 的结点。

A. 8

B. 9

C. 10

D. 11

05. 设高度为  $h$  的二叉树上只有度为 0 和度为 2 的结点，则此类二叉树中所包含的结点数至少为（）。

A.  $h$

B.  ${2h} - 1$

C.  ${2h} + 1$

D.  $h + 1$

06. 具有  $n$  个结点且高度为  $n$  的二叉树的数目为（）。

A.  $\log_2 n$

B.  $n / 2$

C.  $n$

D.  $2^{n - 1}$

07. 假设一棵二叉树的结点个数为 50，则它的最小高度是（）。

A. 4

B. 5

C. 6

D. 7

08. 设二叉树有  $2n$  个结点，且  $m < n$  ，则不可能存在（）的结点。

A.  $n$  个度为0

B.  ${2m}$  个度为 0

C.  $2m$  个度为1

D.  $2 m$  个度为 2

09. 一个具有1025个结点的二叉树的高  $h$  为（）。

A. 11

B. 10

C.  $11 \sim 1025$

D.  $10 \sim 1024$

10. 设二叉树只有度为 0 和 2 的结点，其结点个数为 15，则该二叉树的最大深度为（）。

A. 4

B. 5

C. 8

D. 9

11. 高度为  $h$  的完全二叉树最少有（）个结点。

A.  $2^{h}$

B.  $2^{h} + 1$

C.  $2^{h - 1}$

D.  $2^{h} - 1$

12. 已知一棵完全二叉树的第 6 层（设根为第 1 层）有 8 个叶结点，则完全二叉树的结点个数最少是（）。

A. 39

B. 52

C. 111

D. 119

13. 若一棵深度为6的完全二叉树的第6层有3个叶结点，则该二叉树共有（）个叶结点。

A. 17

B. 18

C. 19

D. 20

14.一棵完全二叉树上有1001个结点，其中叶结点的个数是（）。

A. 250

B. 500

C. 254

D. 501

15. 若一棵二叉树有 126 个结点，在第 7 层（根结点在第 1 层）至多有（）个结点。

A. 32

B. 64

C. 63

D. 不存在第7层

16.一棵有124个叶结点的完全二叉树，最多有（）个结点。

A. 247

B. 248

C. 249

D. 250

17. 某完全二叉树  $T$  中，结点个数最大的层有8个结点，则  $T$  中至多有（）个结点。

A. 8

B. 15

C. 23

D. 31

18.一棵有  $n$  个结点的二叉树采用二叉链存储结点，其中空指针数为（）。

A.  $n$

B.  $n + 1$

C.  $n - 1$

D.  $2 n$

19. 设有  $n$  （  $n \geq 1$  ）个结点的二叉树采用三叉链表表示，其中每个结点包含三个指针，分别指向其左孩子、右孩子及双亲（若不存在，则置为空），则下列说法中正确的是（）。

I. 树中空指针的数量为  $n + 2$

II. 所有度为 2 的结点均被三个指针指向

III. 每个叶结点均被一个指针所指向

A. I

B. I、II

C. I、III

D. II、III

20. 在一棵完全二叉树中，其根的序号为1，（）可判定序号为  $p$  和  $q$  的两个结点是否在同一层。

A.  $\lfloor \log_2p\rfloor = \lfloor \log_2q\rfloor$

B.  $\log_2p = \log_2q$

C.  $\lfloor \log_2p\rfloor +1 = \lfloor \log_2q\rfloor$

D.  $\lfloor \log_2p\rfloor = \lfloor \log_2q\rfloor +1$

21. 在一个用数组表示的完全二叉树中，根结点的下标为 1，那么下标为 17 和 19 的结点的

最近公共祖先的下标是（）。

A. 1

B. 2

C. 4

D. 8

22. 假定一棵三叉树的结点数为50，则它的最小高度为（）。

A. 3

B. 4

C. 5

D. 6

23. 具有  $n$  个结点的三叉树用三叉链表表示，则树中空指针域的个数为（）。

A.  $3n + 1$

B.  ${2n} + 1$

C.  ${3n} - 1$

D.  $3 n$

24. 对于一棵满二叉树，共有  $n$  个结点和  $m$  个叶结点，高度为  $h$ ，则（）。

A.  $n = h + m$

B.  $n + m = 2h$

C.  $m = h - 1$

D.  $n = 2^{h} - 1$

25.【2009统考真题】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是（）。

A. 39

B. 52

C. 111

D. 119

26.【2011统考真题】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数是（）。

A. 257

B. 258

C. 384

D. 385

27.【2018统考真题】设一棵非空完全二叉树  $T$  的所有叶结点均位于同一层，且每个非叶结点都有2个子结点。若  $T$  有  $k$  个叶结点，则  $T$  的结点总数是（）。

A.  ${2k} - 1$

B.  $2 k$

C.  $k^{2}$

D.  $2^{k} - 1$

28.【2020统考真题】对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是（）。

A. 31

B. 16

C. 15

D. 10

29.【2022统考真题】若三叉树  $T$  中有244个结点（叶结点的高度为1），则  $T$  的高度至少是（）。

A. 8

B. 7

C. 6

D. 5

# 二、综合应用题

01. 在一棵完全二叉树中，含有  $n_0$  个叶结点，当度为 1 的结点数为 1 时，该树的高度是多少？当度为 1 的结点数为 0 时，该树的高度是多少？

02. 一棵有  $n$  个结点的满二叉树有多少个分支结点和多少个叶结点？该满二叉树的高度是多少？

03. 已知完全二叉树的第 9 层有 240 个结点，则整个完全二叉树有多少个结点？有多少个叶结点？

04. 一棵高度为  $h$  的满  $m$  叉树有如下性质：根结点所在层次为第1层，第  $h$  层上的结点都是叶结点，其余各层上每个结点都有  $m$  棵非空子树，若按层次自顶向下，同一层自左向右，顺序从1开始对全部结点进行编号，试问：

1）各层的结点个数是多少？

2）编号为  $i$  的结点的双亲结点（若存在）的编号是多少？

3）编号为  $i$  的结点的第  $k$  个孩子结点（若存在）的编号是多少？

4）编号为  $i$  的结点有右兄弟的条件是什么？其右兄弟结点的编号是多少？

05. 已知一棵二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为  $i$  和  $j$  的两个结点的最近的公共祖先结点的值。

06.【2016统考真题】若一棵非空  $k(k\geqslant 2)$  叉树  $T$  中的每个非叶结点都有  $k$  个孩子，则称  $T$  为正则  $k$  叉树。请回答下列问题并给出推导过程。

1）若  $T$  有  $m$  个非叶结点，则  $T$  中的叶结点有多少个？

2）若  $T$  的高度为  $h$  （单结点的树  $h = 1$ ），则  $T$  的结点数最多为多少个？最少为多少个？

# 5.2.4 答案与解析

# 一、单项选择题

# 01. C

在二叉树中，若某个结点只有一个孩子，则这个孩子的左右次序是确定的；而在度为2的有序树中，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，选项A错误。选项B仅当是完全二叉树时才有意义，对于任意一棵二叉树，高度可能为  $\lfloor \log_2n\rfloor +1\sim n$  。在完全二叉树中，若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子，选项C正确。完全二叉树的高度为  $\lceil \log_2(n + 1)\rceil$  或  $\lfloor \log_2n\rfloor +1$  ，也可通过举例  $n = 4$  来排除，选项D错误。

# 02. C

“二叉树为空”意味着二叉树中没有结点，但并不意味着二叉树不存在。注意，线性表可以是空表，树可以是空树，但图不能是空图（图中不能没有结点）。

# 03. A

在完全二叉树中，叶结点的双亲的左兄弟的孩子一定在其前面（且一定存在），所以双亲的左兄弟（若存在）一定不是叶结点，选项A正确。  $n_0$  应等于  $n_2 + 1$  ，选项B错误。完全二叉树和满二叉树均可以采用顺序存储结构，选项C错误。第  $i$  个结点的左孩子不一定存在，选项D错误。

选项B的这种通用公式适用于所有二叉树，我们应能立即联想到采用特殊值代入法验证，如画一个只含3个结点的满二叉树的草图来验证是否满足条件。

# 04. B

由二叉树的性质  $n_0 = n_2 + 1$  ，得  $n_2 = n_0 - 1 = 10 - 1 = 9$

【另解】画出草图，如下图所示。首先画出10个叶结点，然后每2个结点向上合并，构造一个新的度为2的分支结点，直到构成如下图所示的二叉树，其中度为2的分支结点数为9。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/64c1f8497f3b59ac047d46becb422c300ca6ef74c4bc6ed1df6bd5e1e189f5b9.jpg)


# 05. B

结点最少的情况如下图所示。除根结点层只有1个结点外，其他  $h - 1$  层均有两个结点，结点总数  $= 2(h - 1) + 1 = 2h - 1$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1f252868c04c5d60b9b8d537b05c904f4bc063c62b5db2b151e0ce81596ac3c1.jpg)


# 06. D

除根结点外，在其余  $n - 1$  个结点中，每个结点要么是其父结点的左孩子，要么是其父结点的右孩子，每个结点都有两种可能， $n - 1$  个结点共有  $2^{n - 1}$  种不同的组合形态。

# 07. C

要求满足条件的树，分析可知当这50个结点构成一棵完全二叉树时高度最小，  $h = \lfloor \log_2n\rfloor +1 =$ $\lfloor \log_250\rfloor +1 = 6$

【另解】第1层最多有1个结点，第2层最多有  $2^{1}$  个结点，第3层最多有  $2^{2}$  个结点，第4层最多有  $2^{3}$  个结点，以此类推，可以得到  $h$  最少为6。

08. C

由二叉树的性质1可知  $n_0 = n_2 + 1$  ，结点总数  $= 2n = n_{0} + n_{1} + n_{2} = n_{1} + 2n_{2} + 1$  ，则  $n_1 = 2(n - n_2) - 1$  所以  $n_1$  为奇数，说明该二叉树中不可能有  $2m$  个度为1的结点。

09.C

当二叉树为单支树时具有最大高度，即每层上只有一个结点，最大高度为1025。而当树为完全二叉树时，其高度最小，最小高度为  $\lfloor \log_2n\rfloor +1 = 11$

10. C

建议画图，第一层有1个结点，其余  $h - 1$  层各有2个结点，总结点数  $= 1 + 2(h - 1) = 15$  ，  $h = 8$  。

11. C

高度为  $h$  的完全二叉树中，第1层～第  $h - 1$  层构成一个高度为  $h - 1$  的满二叉树，结点个数为  $2^{h - 1} - 1$  。第  $h$  层至少有一个结点，所以最少的结点个数  $= (2^{h - 1} - 1) + 1 = 2^{h - 1}$  。

12. A

第6层有叶结点说明完全二叉树的高度可能为6或7，显然树高为6时结点最少。若第6层上有8个叶结点，则前5层为满二叉树，所以完全二叉树的结点个数最少为  $2^{5} - 1 + 8 = 39$  个结点。

13. A

深度为6的完全二叉树，第5层共有  $2^{4} = 16$  个结点。第6层最左边有3个叶结点，其对应的双亲结点为第5层最左边的两个结点，所以第5层剩余的结点均为叶结点，共有  $16 - 2 = 14$  个，加上第6层的3个叶结点，共有17个叶结点。

14. D

由完全二叉树的性质，最后一个分支结点的序号为  $\lfloor 1001 / 2\rfloor = 500$  ，所以叶结点个数为501。

【另解】  $n = n_0 + n_1 + n_2 = n_0 + n_1 + (n_0 - 1) = 2n_0 + n_1 - 1$ ，因为  $n = 1001$ ，而在完全二叉树中， $n_1$  只能取0或1。当  $n_1 = 1$  时， $n_0$  为小数，不符合题意。所以  $n_1 = 0$ ，于是有  $n_0 = 501$ 。

15. C

要使二叉树第7层的结点数最多，只考虑树高为7层的情况，7层满二叉树有127个结点，126仅比127少1个结点，只能少在第7层，所以第7层最多有  $2^{6} - 1 = 63$  个结点。

16. B

在非空的二叉树当中，由度为0和2的结点数的关系  $n_0 = n_2 + 1$  可知  $n_2 = 123$ ；总结点数  $n = n_0 + n_1 + n_2 = 247 + n_1$ ，其最大值为248（ $n_1$  的取值为1或0，当  $n_1 = 1$  时结点最多）。注意，由完全二叉树总结点数的奇偶性可以确定  $n_1$  的值，但不能根据  $n_0$  来确定  $n_1$  的值。

【另解】  $124 < 2^{7} = 128$  ，所以第8层没满，前7层为完全二叉树，由此可推算第8层可能有120个叶结点，第7层的最右4个为叶结点，考虑最多的情况，这4个叶结点中的最左边可以有1个左孩子（不改变叶结点数），因此结点总数  $= 2^{7} - 1 + 120 + 1 = 248$  。

17. C

在完全二叉树中，第4层刚好最多有8个结点（前4层对应高度为4的满二叉树），若第5层也有8个结点，则对应于结点个数最多的情况，此时树高为5，总结点数为  $15 + 8 = 23$ 。

18. B

非空指针数  $=$  总分支数  $= n - 1$  ，空指针数  $= 2\times$  结点总数-非空指针数  $= 2n - (n - 1) = n + 1$  。

【另解】在树中，1个指针对应1个分支， $n$  个结点的树共有  $n - 1$  个分支，即  $n - 1$  个非空指针，每个结点都有2个指针域，所以空指针数  $= 2n - (n - 1) = n + 1$ 。

# 19. A

二叉链表表示的二叉树中空指针的数量为  $n + 1$ ，三叉链表表示的二叉树多了一个根结点指向双亲的空指针，所以树中空指针的数量为  $n + 2$ ，选项I正确。若根结点的度为2，则只有左、右两个孩子指向它，选项II错误。若整棵树只有一个根结点，则没有指针指向它，选项III错误。

# 20. A

由完全二叉树的性质，编号为  $i$  （ $i \geqslant 1$ ）的结点所在的层次为  $\lfloor \log_2 i \rfloor + 1$ ，若两个结点位于同一层，则一定有  $\lfloor \log_2 p \rfloor + 1 = \lfloor \log_2 q \rfloor + 1$ ，因此有  $\lfloor \log_2 p \rfloor = \lfloor \log_2 q \rfloor$  成立。

# 21. C

当根结点下标为1时，下标为  $i$  的结点的父结点下标为  $\lfloor i / 2\rfloor$  ，那么下标为17的祖先的下标有8,4,2,1，下标为19的祖先的下标有9,4,2,1，因此两者最近的公共祖先的下标是4。

# 22. C

分析可知，满足条件的三叉树可以是完全三叉树，这棵树的第  $i$  （ $i \geqslant 1$ ）层最多有  $3^{i-1}$  个结点。设高度为  $h$ ，则  $3^0 + 3^1 + \dots + 3^{h-1} = (3^h - 1)/2$  是结点数的上限，问题是求解  $50 \leqslant (3^h - 1)/2$  的最小  $h$  值，即  $h \geqslant \log_3 101$ ，有  $h = \lceil \log_3 101 \rceil = 5$ 。

# 23. B

三叉树采用三叉链表表示，每个结点均有3个指针域指向3个孩子，共有  $3n$  个指针域，但  $n$  个结点构成的一棵树中只需要  $n - 1$  个指针（对于  $n - 1$  条边），因此空指针域有  $2n + 1$  个。

# 24. D

对于高度为  $h$  的满二叉树，结点总数  $n = 2^0 + 2^1 + \dots + 2^{h - 1} = 2^h - 1$  ，叶结点数  $m = 2^{h - 1}$  。

# 25. C

第6层有叶结点，完全二叉树的高度可能为6或7，显然树高为7时结点最多。完全二叉树与满二叉树相比，只是在最下一层的右边缺少部分叶结点，而最后一层之上是个满二叉树，且只有最后两层上有叶结点。若第6层上有8个叶结点，则前6层为满二叉树，而第7层缺失  $8 \times 2 = 16$  个叶结点，所以完全二叉树的结点个数最多为  $2^{7} - 1 - 16 = 111$  。

# 26. C

最后一个分支结点的编号为  $\lfloor 768 / 2\rfloor = 384$  ，所以叶结点的个数为  $768 - 384 = 384$  。

【另解】  $n = n_0 + n_1 + n_2 = n_0 + n_1 + (n_0 - 1) = 2n_0 + n_1 - 1$ ，其中  $n = 768$ ，而在完全二叉树中， $n_1$  只能取0或1，当  $n_1 = 0$  时， $n_0$  为小数，不符合题意。因此  $n_1 = 1$ ，所以  $n_0 = 384$ 。

# 27. A

非叶结点的度均为2，且所有叶结点都位于同一层的完全二叉树就是满二叉树。对于一棵高度为  $h$  的满二叉树（空树  $h = 0$ ），其最后一层全部是叶结点，数目为  $2^{h - 1}$ ；总结点数为  $2^{h} - 1$ 。因此当  $2^{h - 1} = k$  时，可以得到  $2^{h} - 1 = 2k - 1$ 。

# 28. A

二叉树采用顺序存储时，用数组下标来表示结点之间的父子关系。对于一棵高度为5的二叉树，为了满足任意性，其  $1\sim 5$  层的所有结点都要被存储起来，即考虑为一棵高度为5的满二叉树，共需要存储单元的数量为  $1 + 2 + 4 + 8 + 16 = 31$  。

# 29. C

高度一定的三叉树中结点数最多的情况是满三叉树。高度为5的满三叉树的结点数  $= 3^{0} + 3^{1} + 3^{2} + 3^{3} + 3^{4} = 121$  ，高度为6的满三叉树的结点数  $= 3^{0} + 3^{1} + 3^{2} + 3^{3} + 3^{4} + 3^{5} = 364$  。三叉树  $T$  的结点数为244，  $121 < 244 < 364$  ，因此  $T$  的高度至少为6。

# 二、综合应用题

# 01.【解答】

在非空的二叉树中，由度为0和度为2的结点之间的关系  $n_0 = n_2 + 1$ ，可知  $n_2 = n_0 - 1$  。因此总结点数  $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$  。

① 当  $n_1 = 1$  时， $n = 2n_0$ ， $h = \lceil \log_2(n + 1) \rceil = \lceil \log_2(2n_0 + 1) \rceil$ 。

② 当  $n_1 = 0$  时， $n = 2n_0 - 1$ ， $h = \lceil \log_2(n + 1) \rceil = \lceil \log_2(2n_0) \rceil = \lceil \log_2(n_0) \rceil + 1$ 。

# 02.【解答】

满二叉树中  $n_1 = 0$ ，由二叉树的性质1可知  $n_0 = n_2 + 1$ ，即  $n_2 = n_0 - 1$ ， $n = n_0 + n_1 + n_2 = 2n_0 - 1$ ，则  $n_0 = (n + 1) / 2$ 。分支结点个数  $n_2 = n - (n + 1) / 2 = (n - 1) / 2$ 。高度为  $h$  的满二叉树的结点数  $n = 1 + 2^1 + 2^2 + \dots + 2^{h-1} = 2^h - 1$ ，即高度  $h = \log_2(n + 1)$ 。

# 03.【解答】

在完全二叉树中，若第9层是满的，则结点数  $= 2^{9 - 1} = 256$  ，而现在第9层只有240个结点，说明第9层未满，是最后一层。  $1\sim 8$  层是满的，所以总结点数  $= 2^{8} - 1 + 240 = 495$  。

因为第9层是最后一层，所以第9层的结点都是叶结点。且第9层的240个结点的双亲在第8层中，其双亲个数为120，即第8层有120个分支结点，其余为叶结点，所以第8层的叶结点个数为  $2^{8 - 1} - 120 = 8$  。因此，总的叶结点个数  $= 8 + 240 = 248$  。

【另解】总结点数  $n = n_0 + n_1 + n_2$  ，  $n_2 = n_0 - 1$  ，  $n = n_0 + n_1 + n_2 = 2n_0 + n_1 - 1$  。若  $n_1 = 1$  ，则  $2n_{0} + n_{1} - 1 = 2n_{0} = 495$  ，不符合；若  $n_1 = 0$  ，则  $2n_{0} + n_{1} - 1 = 2n_{0} - 1 = 495$  ，则  $n_0 = 248$  。

# 注意

对于本题，应理解完全二叉树中只有最底层的结点是不满的，其他各层的结点都是满的。

# 04.【解答】

1）第1层有  $m^0 = 1$  个结点，第2层有  $m^1$  个结点，第3层有  $m^2$  个结点……一般地，第  $i$  层有  $m^{i - 1}$  个结点（ $1 \leqslant i \leqslant h$ ）。

2）在  $m$  叉树的情形下，结点  $i$  的第1个子女编号为  $j = (i - 1)m + 2$  ，反过来，结点  $i$  的双亲的编号是  $\lfloor (i - 2) / m\rfloor +1$  ，根结点没有双亲，所以要求  $i > 1$  。

3）因为结点  $i$  的第1个子女编号为  $(i - 1)m + 2$  ，若设该结点子女的序号为  $k = 1,2,\dots ,m$  ，则第  $k$  个子女结点的编号为  $(i - 1)m + k + 1$  （  $1\leqslant k\leqslant m)$  。

4）结点  $i$  不是其双亲的第  $m$  个子女时才有右兄弟。设其双亲编号为  $j$  ，可得  $j = \left\lfloor (i + m - 2) / m\right\rfloor$  结点  $j$  的第  $m$  个子女的编号为  $(j - 1)m + m + 1 = jm + 1 = \left\lfloor (i + m - 2) / m\right\rfloor m + 1$  ，所以当结点的编号  $i \leqslant \left\lfloor (i + m - 2) / m\right\rfloor m$  时才有右兄弟，右兄弟的编号为  $i + 1$  。或者，对于任意一个双亲结点  $j$  ，其第  $m$  个子女结点的编号是  $jm + 1$  ，故若不为第  $m$  个子女结点，则  $(i - 1)\% m! = 0$  。

# 05.【解答】

首先，必须明确二叉树中任意两个结点必然存在最近的公共祖先结点，最坏的情况下是根结点（两个结点分别在根结点的左右分支中)，而且从最近的公共祖先结点到根结点的全部祖先结点都是公共的。由二叉树顺序存储的性质可知，任意一个结点  $i$  的双亲结点的编号为  $i / 2$  。求解  $i$  和  $j$  最近公共祖先结点的算法步骤如下（设从数组下标1开始存储）：

1）若  $i > j$  ，则结点  $i$  所在层次大于或等于结点  $j$  所在层次。结点  $i$  的双亲结点为结点  $i / 2$  若  $i / 2 = j$  ，则结点  $i / 2$  是原结点  $i$  和结点  $j$  的最近公共祖先结点，若  $i / 2\neq j$  ，则令  $i = i / 2$  即以该结点  $i$  的双亲结点为起点，采用递归的方法继续查找。

2）若  $j > i$  ，则结点  $j$  所在层次大于或等于结点  $i$  所在层次。结点  $j$  的双亲结点为结点  $j / 2$  若  $j / 2 = i$  ，则结点  $j / 2$  是原结点  $i$  和结点  $j$  的最近公共祖先结点，若  $j / 2\neq i$  ，则令  $j = j / 2$  。重复上述过程，直到找到它们最近的公共祖先结点为止。

本题代码如下：

```txt
ElemType Comm_Ancessor(SqTree T, int i, int j) {
//本算法在二叉树中查找结点i和结点j的最近公共祖先结点
if (T[i] != '#&&T[j] != '#') {
//结点存在
while (i != j) {
//两个编号不同时循环
if (i > j)
i = i / 2;
else
j = j / 2;
}
return T[i];
}
```

由解题中算法的步骤描述可知，本题也很容易地联想到采用递归的方法求解。

# 06.【解答】

1）正则  $k$  叉树中仅含有两类结点：叶结点（个数记为  $n_0$  ）和度为  $k$  的分支结点（个数记为  $n_k$ ）。树  $T$  中的结点总数  $n = n_0 + n_k = n_0 + m$ 。树中所含的边数  $e = n - 1$ ，这些边均是从  $m$  个度为  $k$  的结点发出的，即  $e = mk$ 。整理得  $n_0 + m = mk + 1$ ，所以  $n_0 = (k - 1)m + 1$ 。

2）高度为  $h$  的正则  $k$  叉树  $T$  中，含最多结点的树形为：除第  $h$  层外，第1到第  $h - 1$  层的结点都是度为  $k$  的分支结点；而第  $h$  层均为叶结点，即树是“满”树。此时第  $j$  （  $1\leqslant j\leqslant h)$  层的结点数为  $k^{j - 1}$  ，结点总数  $M_{1}$  为

$$
M _ {1} = \sum_ {j = 1} ^ {h} k ^ {j - 1} = \frac {k ^ {h} - 1}{k - 1}
$$

含最少结点的正则  $k$  叉树的树形为：第1层只有根结点，第2到第  $h - 1$  层仅含1个分支结点和  $k - 1$  个叶结点，第  $h$  层有  $k$  个叶结点。也就是说，除根外，第2到第  $h$  层中每层的结点数均为  $k$  ，所以  $T$  中所含结点总数  $M_2$  为

$$
M _ {2} = 1 + (h - 1) k
$$

# 5.3 二叉树的遍历和线索二叉树

# 5.3.1 二叉树的遍历

二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。

命题追踪 二叉树遍历方式的分析（2009、2011、2012）

命题追踪 （算法题）二叉树遍历的相关应用（2014、2017、2022）

由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中序指的是根结点在何时被访问。

# 1. 先序遍历（PreOrder）

若二叉树为空，则什么也不做；否则，公众号：小兔网盘 免费分享无水印PDF

1）访问根结点；

2）先序遍历左子树；

3）先序遍历右子树。

图5.7中的虚线表示对该二叉树进行先序遍历的路径，得到先序遍历序列为124635。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/350ab12c6375b4ad6417c56eefdb09c3264f1f42285b070f53e74a8642f7193b.jpg)



图5.7 二叉树的先序遍历


对应的递归算法如下：

```txt
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T); //访问根结点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```

# 2. 中序遍历 (InOrder)

若二叉树为空，则什么也不做；否则，

1）中序遍历左子树；

2）访问根结点；

3）中序遍历右子树。

# 命题追踪 中序序列中结点关系的分析（2017、2024）

图5.8中的虚线表示对该二叉树进行中序遍历的路径，得到中序遍历序列为264135。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1dde9628377d3ccba8fe89495980d3d70eb8df7e9951fd8317f6c808d4c68b50.jpg)



图5.8 二叉树的中序遍历


对应的递归算法如下：

```txt
void InOrder(BiTree T) { if  $(\mathrm{T}! = \mathrm{NULL})$  { InOrder(T->lchild); //递归遍历左子树
```

```txt
visit(T); //访问根结点 InOrder(T->rchild); //递归遍历右子树 }
```

# 3. 后序遍历(PostOrder)

若二叉树为空，则什么也不做；否则，

1）后序遍历左子树；

2）后序遍历右子树；

3）访问根结点。

图5.9中的虚线表示对该二叉树进行后序遍历的路径，得到后序遍历序列为642531。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e532776a144f7d40aaf781aa02bf4e050dc3c6ebd6783ee16d22a3d7fb7bfc8d.jpg)



图5.9 二叉树的后序遍历


对应的递归算法如下：

```txt
void PostOrder(BiTree T) { if  $(\mathrm{T}! = \mathrm{NULL})$  { PostOrder  $(\mathrm{T} - > 1)$  child); //递归遍历左子树 PostOrder  $(\mathrm{T} - > r\mathrm{child})$  //递归遍历右子树 visit(T); //访问根结点 }
```

上述三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度都是  $O(n)$  。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有  $n$  个结点且深度为  $n$  的单支树，遍历算法的空间复杂度为  $O(n)$  。

# 4. 层次遍历

图5.10所示为二叉树的层次遍历，即按照箭头所指方向，按照1,2,3,4的层次顺序，自上而下、从左至右对二叉树中的各个结点进行逐层访问。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f8928672904c47083acf112cf8a92c24ebb838af58156906e157a6e75848d494.jpg)



图5.10 二叉树的层次遍历


进行层次遍历时，需要借助一个队列。层次遍历的思想如下：①首先将根结点入队。②若队

列非空，则队头结点出队，访问该结点，若它有左孩子，则将其左孩子入队；若它有右孩子，则将其右孩子入队。③重复步骤②，直至队列为空。

二叉树的层次遍历算法如下：

```txt
void LevelOrder(BiT){ InitQueue(Q); //初始化辅助队列 BiTree p; EnQueue(Q,T); //将根结点入队 while(!IsEmpty(Q)){ //队列不空则循环 DeQueue(Q,p); //队头结点出队 visit(p); //访问出队结点 if(p->lchild!=NULL) EnQueue(Q,p->lchild); //若左孩子不空，则左孩子入队 if(p->rchild!=NULL) EnQueue(Q,p->rchild); //若右孩子不空，则右孩子入队 }
```

在复习过程中，读者应将上述二叉树层次遍历的算法作为一个模板，熟练掌握其执行过程，并达到熟练手写的程度。

# 注意

遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。

# 5. 由遍历序列构造二叉树

# 命题追踪 先序序列对应的不同二叉树的分析（2015）

对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是确定的。然而，只给出四种遍历序列中的任意一种，却不能唯一地确定一棵二叉树。若已知中序序列，再给出其他三种遍历序列中的任意一种，就可以唯一地确定一棵二叉树。

（1）由先序序列和中序序列构造二叉树

# 命题追踪 先序序列和中序序列相同时确定的二叉树（2017）

# 命题追踪 由先序序列和中序序列构造一棵二叉树（2020、2021）

在先序序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根的左子树的中序序列，后一个子序列是根的右子树的中序序列。左子树的中序序列和先序序列的长度是相等的，右子树的中序序列和先序序列的长度是相等的。根据这两个子序列，可以在先序序列中找到左子树的先序序列和右子树的先序序列，如图5.11所示。如此递归地分解下去，便能唯一地确定这棵二叉树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/35100cd1ec4e078b7a5e17c3e73e9a6480542edb4f8be73721207a801ae20f46.jpg)



图5.11 由先序序列和中序序列构造二叉树


例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。首先，由先序序列可知  $A$  为二叉树的根结点。中序序列中  $A$  之前的  $BC$  为左子树的中序序列，EDGHFI为右子树的中序序列。然后，由先序序列可知  $B$  是左子树的根结点，  $D$  是右子树的根结点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如图5.12(c)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/261673f31b0db571e217dc955eb1cbcadb7611ead50d2b8aa316e3147acb2bb9.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2762099a9d32ec1612c504c9bd5660e9a5cdd459727df94575daaeabe0688fed.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cfcbcf72a9274c3674cf2e6ee243d0b40900ad431d655542137e0e5d07139d23.jpg)



(c)



图5.12 一棵二叉树的构造过程


# （2）由后序序列和中序序列构造二叉树

# 命题追踪 由后序序列和树形构造一棵二叉树（2017、2023）

同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，如图5.13所示，然后采用类似的方法递归地进行分解，进而唯一地确定这棵二叉树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/05b82ad9df6e7f128d325ae15204185e0340f52b0e16abd356f6d1a79ee4ff79.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/26eb93cc786cece14025387a766074f7b98389c16ce15264fe903ea732e401da.jpg)



图5.13 由后序序列和中序序列构造二叉树


请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。

# （3）由层序序列和中序序列构造二叉树

在层序遍历中，第一个结点一定是二叉树的根结点，这样就将中序序列分割成了左子树的中序序列和右子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可进一步划分左子树；若存在右子树，则层序序列中紧接着的下一个结点一定是右子树的根，可进一步划分右子树，如图5.14所示。采用这种方法继续分解，就能唯一确定这棵二叉树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/48cf7c7a51b49fa34c6594c501a77c392b4f6d55dfd28019877a7ab6572327a2.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/20db93946539762ec59305c0076b231eb7bc9085e29e876fee2802b29f53fc5a.jpg)



图5.14 由层序序列和中序序列构造二叉树


请读者分析层序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。

注意，先序序列、后序序列和层序序列的两两组合，无法唯一确定一棵二叉树。例如，图5.15所示的两棵二叉树的先序序列都为  $AB$  ，后序序列都为  $BA$  ，层序序列都为  $AB$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1d914a796a371b441011e5151c1d62207b41efb285069288d4be4c80cd442cf9.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a0d533afac049fee1ae4d7941fd317991a53591f2812df0d49ff898a12d42136.jpg)



(b)



图5.15 两棵不同的二叉树


# 5.3.2 线索二叉树

# 1. 线索二叉树的基本概念

遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。

# 命题追踪 线索二叉树的定义（2010）

传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含  $n$  个结点的二叉树中，有  $n + 1$  个空指针。这是因为每个叶结点都有2个空指针，每个度为1的结点都有1个空指针，空指针总数为  $2n_{0} + n_{1}$ ，又  $n_{0} = n_{2} + 1$ ，所以空指针总数为  $n_{0} + n_{1} + n_{2} + 1 = n + 1$  。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。

规定：若无左子树，令 lchild 指向其前驱结点；若无右子树，令 rchild 指向其后继结点。如图 5.16 所示，还需增加两个标志域，以标识指针域指向左（右）孩子或前驱（后继）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e2119df27130cef5f0c9cb1112129f0e7a34455d13673b7be686590712d4a9aa.jpg)



图5.16 线索二叉树的结点结构


其中，标志域的含义如下：

$$
\begin{array}{r l} & \text {l t a g} = \left\{ \begin{array}{l l} 0, & \quad \text {l c h i l d 域 指 示 结 点 的 左 孩 子} \\ 1, & \quad \text {l c h i l d 域 指 示 结 点 的 前 驱} \end{array} \right. \\ & \text {r t a g} = \left\{ \begin{array}{l l} 0, & \quad \text {r c h i l d 域 指 示 结 点 的 右 孩 子} \\ 1, & \quad \text {r c h i l d 域 指 示 结 点 的 后 继} \end{array} \right. \end{array}
$$

线索二叉树的存储结构描述如下：

```txt
typedef struct ThreadNode{ElemType data; //数据元素struct ThreadNode \*lchild,\*rchild; //左、右孩子指针int ltag,rtag; //左、右线索标志}ThreadNode,\*ThreadTree;
```

以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱和后继的指针称为线索。加上线索的二叉树称为线索二叉树。

# 2. 中序线索二叉树的构造

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。

# 命题追踪 中序线索二叉树中线索的指向（2014）

以中序线索二叉树的建立为例。附设指针 pre 指向刚刚访问过的结点，指针 p 指向正在访问的结点，即 pre 指向 p 的前驱。在中序遍历的过程中，检查 p 的左指针是否为空，若为空就将它指向 pre；检查 pre 的右指针是否为空，若为空就将它指向 p，如图 5.17 所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5bd75763fecc5929f90880707730cff9f56a09890a8d120ee95a77e61c949cd8.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/03e651ce9a28ea68cb12b062f0abe53cc13815d42b2433f07bf4de26a68a57a9.jpg)



图5.17 中序线索二叉树及其二叉链表示


通过中序遍历对二叉树线索化的递归算法如下：

```c
void InThread( ThreadTree &p, ThreadTree &pre) {
    if (p != NULL) {
        InThread(p->lchild, pre); //递归，线索化左子树
        if (p->lchild == NULL) {
            p->lchild = pre; //建立当前结点的左子树为空
            p->ltag = 1;
        }
    }
    if (pre != NULL && pre->rchild == NULL) { //前驱结点非空且其右子树为空
        pre->rchild = p; //建立前驱结点的后继线索
        pre->rtag = 1;
    }
    pre = p; //标记当前结点成为刚刚访问过的结点
    InThread(p->rchild, pre); //递归，线索化右子树
}
```

通过中序遍历建立中序线索二叉树的主过程算法如下：

```txt
void CreateInThread( ThreadTree T) {  
    ThreadTree pre = NULL;  
    if (T != NULL) { //非空二叉树，线索化  
        InThread(T, pre); //线索化二叉树  
        pre->rchild = NULL; //处理遍历的最后一个结点  
        pre->rtag = 1;  
    }
```

为方便起见，可在二叉树的线索链表上也添加一个头结点，令其 lchild 域的指针指向二叉树的根结点，其 rchild 域的指针指向中序遍历时访问的最后一个结点；令二叉树中序序列中的第一个结点的 lchild 域指针和最后一个结点的 rchild 域指针均指向头结点。这好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如图 5.18 所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/deb0d3734e1e31dd6f06f209e422c8dcc2a3e01307488e7816dba2b16b17be35.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2bf24eb28e823279550f96d4fb3d0ead276b9691af5d0b94c129c624e71e4f3f.jpg)



图5.18 带头结点的中序线索二叉树


# 3. 中序线索二叉树的遍历

中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。

1）求中序线索二叉树的中序序列下的第一个结点：

```txt
ThreadNode \*Firstnode (ThreadNode \*p){ while(p->1tag==0)p=p->lchild; //最左下结点（不一定是叶结点） return p; }
```

2）求中序线索二叉树中结点  $\mathfrak{p}$  在中序序列下的后继：

```txt
ThreadNode *Nextnode (ThreadNode *p) { if(p->rtag == 0) return Firstnode(p->rchild); //右子树中最左下结点 else return p->rchild; //若rtag == 1则直接返回后继线索 }
```

请读者自行分析并完成求中序线索二叉树的最后一个结点和结点  $\mathfrak{p}$  前驱的运算①。

3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法：

```txt
void Inorder( ThreadNode *T) { for ( ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) visit(p); }
```

# 4. 先序线索二叉树和后序线索二叉树

上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。

以图5.19(a)的二叉树为例给出手工求先序线索二叉树的过程：先序序列为  $ABCDF$ ，然后依次判断每个结点的左右链域，若为空，则将其改造为线索。结点  $A, B$  均有左右孩子；结点  $C$  无左孩子，将左链域指向前驱  $B$ ，无右孩子，将右链域指向后继  $D$ ；结点  $D$  无左孩子，将左链域指向前驱  $C$ ，无右孩子，将右链域指向后继  $F$ ；结点  $F$  无左孩子，将左链域指向前驱  $D$ ，无右孩子，也无后继，所以置空，得到的先序线索二叉树如图5.19(b)所示。求后序线索二叉树的过程：后序序列为  $CDBFA$ ，结点  $C$  无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继  $D$ ；结点  $D$  无左孩子，将左链域指向前驱  $C$ ，无右孩子，将右链域指向后继  $B$ ；结点  $F$  无左孩子，将左链域指向前驱  $B$ ，无右孩子，将右链域指向后继  $A$ ，得到的后序线索二叉树如图5.19(c)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7fd9197fd7a86ee2b98f0f20acf5c4c1217bac40c017298cdca5f78db9fcd6a2.jpg)



(a)一颗二叉树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/64dafdb307473fd2c2903a21cc05e15d84e4ab2b9b22028a654e9183b31976f1.jpg)



(b) 先序线索二叉树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/13cc615001a6b3da2afbcca5f4c5185c27e9435922e2aa3d8925e1f337cd3479.jpg)



(c)后序线索二叉树



图5.19 先序线索二叉树和后序线索二叉树


如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。

# 命题追踪 后序线索二叉树中线索的指向（2013）

在后序线索二叉树中找结点的后继较为复杂，可分三种情况：①若结点  $x$  是二叉树的根，则其后继为空；②若结点  $x$  是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即双亲；③若结点  $x$  是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。图5.19(c)中找结点  $B$  的后继无法通过链域找到，可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。

# 5.3.3 本节试题精选

# 一、单项选择题

01. 在下列关于二叉树遍历的说法中，正确的是（）。

A. 若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点

B. 若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点

C. 若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点

D. 若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点

02. 在任何一棵二叉树中，若结点  $a$  有左孩子  $b$  、右孩子  $c$  ，则在结点的先序序列、中序序列、后序序列中，（）。

A. 结点  $b$  一定在结点  $a$  的前面

B. 结点  $a$  一定在结点  $c$  的前面

C. 结点  $b$  一定在结点  $c$  的前面

D. 结点  $a$  一定在结点  $b$  的前面

03. 设  $n, m$  为一棵二叉树上的两个结点，在中序遍历时， $n$  在  $m$  前的条件是（）。

A.  $n$  在  $m$  右方

B.  $n$  是  $m$  祖先

C.  $n$  在  $m$  左方

D.  $n$  是  $m$  子孙

04. 设  $n, m$  为一棵二叉树上的两个结点，在后序遍历时， $n$  在  $m$  前的充分条件是（）。

A.  $n$  在  $m$  右方

B.  $n$  是  $m$  祖先

C.  $n$  在  $m$  左方

D.  $n$  是  $m$  子孙

05. 某非空二叉树采用顺序存储结构，树中的结点信息按完全二叉树的层次序列依次存放在如下所示的一维数组中，则该二叉树的后序遍历序列为（）。

<table><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td>a</td><td>b</td><td>c</td><td></td><td>d</td><td>e</td><td>f</td><td></td><td></td><td>g</td><td></td><td></td><td>h</td></tr></table>

A. ghbefhca

B.  $gbdehcfa$

C. gdbhefca

D. bgdehcfa

06. 在二叉树的前序序列、中序序列和后序序列中，所有叶结点的先后顺序（）。

A. 都不相同

B. 完全相同

C. 前序和中序相同, 而与后序不同

D. 中序和后序相同, 而与前序不同

07. 对二叉树的结点从 1 开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用（）次序的遍历实现编号。

A. 先序遍历

B. 中序遍历

C. 后序遍历

D. 层次遍历

08. 按某种顺序对二叉树的结点进行编号，编号为  $1,2,\dots ,n$  ，规定：树中任一结点  $\nu$  ，其编号等于  $\nu$  的左子树上的最小编号减1，而  $\nu$  的右子树中的最小编号等于  $\nu$  的左子树上的

最大编号加1，则说明该二叉树是按（）次序编号的。

A. 中序遍历

B. 先序遍历

C. 后序遍历

D. 层次遍历

09. 前序序列为  $A, B, C$ ，后序序列为  $C, B, A$  的二叉树共有（）。

A. 1棵

B. 2 棵

C. 3 棵

D. 4 裸

10. 一棵完全二叉树的后序遍历序列为 CDBFGEA，则其先序遍历序列是（）。

A. CBDAFEG

B. ABECDFG

C. ABCDEFG

D. 无法确定

11. 设结点  $X$  和  $Y$  是二叉树中任意的两个结点。在该二叉树的先序遍历序列中  $X$  在  $Y$  之前，而在其后序遍历序列中  $X$  在  $Y$  之后，则  $X$  和  $Y$  的关系是（）。

A.  $X$  是  $Y$  的左兄弟

B.  $X$  是  $Y$  的右兄弟

C.  $X$  是  $Y$  的祖先

D.  $X$  是  $Y$  的后裔

12. 若二叉树中结点的先序序列是  $a \dots b \dots$ ，中序序列是  $b \dots a \dots$ ，则（）。

A. 结点  $a$  和结点  $b$  分别在某结点的左子树和右子树中

B. 结点  $b$  在结点  $a$  的右子树中

C. 结点  $b$  在结点  $a$  的左子树中

D. 结点  $a$  和结点  $b$  分别在某结点的两棵非空子树中

13.一棵二叉树的先序遍历序列为1234567，它的中序遍历序列可能是（）。

A. 3124567

B. 1234567

C. 4135627

D. 1463572

14. 下列序列中，不能唯一地确定一棵二叉树的是（）。

A. 层次序列和中序序列

B. 先序序列和中序序列

C. 后序序列和中序序列

D. 先序序列和后序序列

15. 若一棵二叉树的中序序列和后序序列相同，则（）。

A. 二叉树为空树或二叉树任一结点没有左子树

B. 二叉树为空树或二叉树任一结点没有右子树

C. 二叉树为空树或二叉树中每个结点的度为 1

D. 二叉树为空树或二叉树为满二叉树

16. 已知一棵二叉树的后序序列为  $DABEC$ ，中序序列为  $DEBAC$ ，则先序序列为（）。

A. ACBED

B. DECACB

C. DEABC

D. CEDBA

17. 已知一棵二叉树的先序遍历结果为  $ABCDEF$ ，中序遍历结果为  $CBAEDF$ ，则后序遍历的结果为（）。

A. CBEFDA

B. FEDCBA

C. CBEDFA

D. 不确定

18. 已知一棵二叉树的层次序列为  $ABCDEF$ ，中序序列为  $BADCFE$ ，则先序序列为（）。

A. ACBEDF

B. ABCDEF

C. BDFECA

D. FCEDBA

19. 某二叉树中结点  $x$  在先序、中序、后序遍历序列中的编号分别为  $\operatorname{pre}(x)$  、 $\operatorname{in}(x)$  、 $\operatorname{post}(x)$  （假设都从1开始依次顺序编号）， $a$  和  $b$  是该二叉树中的两个结点，其中  $a$  是  $b$  的祖先，则下列选项中不可能出现的是（）。

A.  $\operatorname{pre}(a) < \operatorname{pre}(b)$

B.  $\operatorname {post}(a) <   \operatorname {post}(b)$

C.  $\operatorname {in}(a) <   \operatorname {in}(b)$

D.  $\operatorname{in}(a) > \operatorname{in}(b)$

20. 某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用（）遍历方法最合适。

A. 中序

B. 层次

C. 后序

D. 先序

21. 某二叉树  $T$  采用二叉链表存储结构， $T$  的中序遍历序列为一个升序序列，要求采用某种方法对  $T$  进行某种操作之后得到一棵新的二叉树  $T'$ ，要求  $T'$  的中序遍历序列为一个降序

序列，则下列关于该算法的叙述中，正确的是（）。

A. 采用中序遍历的方法最合适

B. 采用后序遍历的方法最合适

C.  $T'$  中的根结点还是原  $T$  中的根结点

D.  $T$  中的叶结点不一定是原  $T$  中的叶结点

22. 引入线索二叉树的目的是（）。

A. 加快查找结点的前驱或后继的速度

B. 为了能在二叉树中方便插入和删除

C. 为了能方便找到双亲

D. 使二叉树的遍历结果唯一

23. 线索二叉树是一种（）结构。

A. 逻辑

B. 逻辑和存储

C. 物理

D. 线性

24.  $n$  个结点的线索二叉树上含有的线索数为（）。

A.  ${2n}$

B.  $n - 1$

C.  $n + 1$

D.  $n$

25. 判断线索二叉树中  $\star p$  结点有右孩子结点的条件是（）。

A.  $p! = \text{NULL}$

B. p->rchild!=NULL

C. p->rtag==0

D. p->rtag==1

26.一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是（）。

A. 不确定

B. 0 个

C. 1 个

D. 2 个

27. 在线索二叉树中，下列说法不正确的是（）。

A. 在中序线索树中, 若某结点有右孩子, 则其后继结点是它的右子树的最左下结点

B. 在中序线索树中, 若某结点有左孩子, 则其前驱结点是它的左子树的最右下结点

C. 线索二叉树是利用二叉树的  $n + 1$  个空指针来存放结点的前驱和后继信息的

D. 每个结点通过线索都可以直接找到它的前驱和后继

28. 二叉树在线索化后，仍不能有效求解的问题是（）。

A. 先序线索二叉树中求先序后继

B. 中序线索二叉树中求中序后继

C. 中序线索二叉树中求中序前驱

D. 后序线索二叉树中求后序后继

29. 若  $X$  是二叉中序线索树中一个有左孩子的结点，且  $X$  不为根，则  $X$  的前驱为（）。

A.  $X$  的双亲

B.  $X$  的右子树中最左的结点

C.  $X$  的左子树中最右的结点

D.  $X$  的左子树中最右的叶结点

30. 若  $X$  是后序线索二叉树中的叶结点，且  $X$  存在左兄弟  $Y$  ，则  $X$  的右线索指向的是（）。

A.  $X$  的双亲

B. 以  $Y$  为根的子树的最左下结点

C.  $X$  的左兄弟  $Y$

D. 以  $Y$  为根的子树的最右下结点

31.（）的遍历仍需要栈的支持。

A. 前序线索树

B. 中序线索树

C. 后序线索树

D. 所有线索树

32. 某二叉树的先序序列和后序序列正好相反，则该二叉树一定是（）。

A. 空或只有一个结点

B. 高度等于其结点数

C. 任意一个结点无左孩子

D. 任意一个结点无右孩子

33. 某非空二叉树的先序序列和中序序列正好相反，则下列叙述中正确的是（）。

A. 该二叉树一定只有一个结点

B. 只有一个叶结点的二叉树一定满足条件

C. 任意一个结点无左孩子的二叉树一定满足条件

D. 任意一个结点无右孩子的二叉树一定满足条件

34.【2009统考真题】给定二叉树如下图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是3175624，则其遍历方式是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2994bee753bd913a3badab73b3a0614eb28fa2b96db070ddc20532f810b0d656.jpg)


A. LRN

B. NRL

C. RLN

D. RNL

35.【2010统考真题】下列线索二叉树中（用虚线表示线索），符合后序线索树定义的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3642b99a7e01ac11a3181e69d88c551d81ad0cd8052a3c350bd422dbeef9a421.jpg)



A.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d81a511902cc174f5ab5e6efae76474c56c5d39f4872320c7db26c96fa5fa653.jpg)



B.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e1a9ec2d031aea7b9db21403a668e32272e0dfefb0fd1726e75e8cab0cfb3d4a.jpg)



C.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d61ad2dae7b536c2bb5164f84d6ff0d8b63313d2b0e493229850265811a3f4cb.jpg)



D.


36.【2011统考真题】一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1，该二叉树的中序遍历序列不会是（）。

A.  $1,2,3,4$

B. 2,3,4,1

C. 3,2,4,1

D. 4,3,2,1

37.【2012统考真题】若一棵二叉树的前序遍历序列为  $a, e, b, d, c$ ，后序遍历序列为  $b, c, d, e, a$ ，则根结点的孩子结点（）。

A. 只有  $e$

B. 有  $e$  、  $b$

C. 有  $e$  、  $c$

D. 无法确定

38.【2013统考真题】若  $X$  是后序线索二叉树中的叶结点，且  $X$  存在左兄弟结点  $Y$  ，则  $X$  的右线索指向的是（）。

A.  $X$  的父结点

B. 以  $Y$  为根的子树的最左下结点

C.  $X$  的左兄弟结点  $Y$

D. 以  $Y$  为根的子树的最右下结点

39.【2014统考真题】若对下图所示的二叉树进行中序线索化，则结点  $X$  的左、右线索指向的结点分别是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/15b11ad6ef746a34b04938b0764778d454087360c5730e5332f173a53d43e099.jpg)


A.  $e, c$

B.  $e, a$

C.  $d, c$

D.  $b, a$

40.【2015统考真题】先序序列为  $a, b, c, d$  的不同二叉树的个数是（）。

A. 13

B. 14

C. 15

D. 16

41.【2017统考真题】某二叉树的树形如下图所示，其后序序列为  $e, a, c, b, d, g, f$  ，树中与结点  $a$  同层的结点是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f4b9c13d080f507c813477384b7e47e5e52130567883d61748d17d5efca9be48.jpg)


A.  $c$

B.  $d$

C.  $f$

D.  $g$

42.【2017统考真题】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须

满足的条件是（）。

A. 只有左子树

B. 只有右子树

C. 结点的度均为 1

D. 结点的度均为 2

43.【2022统考真题】若结点  $p$  与  $q$  在二叉树  $T$  的中序遍历序列中相邻，且  $p$  在  $q$  之前，则下列  $p$  与  $q$  的关系中，不可能的是（）。

I.  $q$  是  $p$  的双亲

II.  $q$  是  $p$  的右孩子

III.  $q$  是  $p$  的右兄弟

IV.  $q$  是  $p$  的双亲的双亲

A. 仅 I

B. 仅III

C. 仅 II、III

D. 仅 II、IV

44.【2023统考真题】已知一棵二叉树的树形如下图所示，若其后序遍历序列为fdbeca，则其先（前）序遍历序列是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/75bfa8d6811dbb5ec8255167067fe78e764528343e7fc62f47656974f36e62aa.jpg)


A. aedfbc

B. acebdf

C. cabefd

D. dfebac

45.【2024统考真题】若  $p$  、  $q$  和  $\nu$  均为二叉树  $T$  中的结点，  $\nu$  有两个孩子结点，  $T$  的中序遍历序列形如“…，  $p, \nu, q, \cdots$  ”，则在下列叙述中，正确的是（）。

A.  $p$  没有右孩子,  $q$  没有左孩子

B.  $p$  没有右孩子,  $q$  有左孩子

C.  $p$  有右孩子,  $q$  没有左孩子

D.  $p$  有右孩子,  $q$  有左孩子

# 二、综合应用题

01. 若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？

02. 若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？

03. 假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。

04. 二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。

05. 假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。

06. 设树  $B$  是一棵采用链式结构存储的二叉树，编写一个把树  $B$  中所有结点的左、右子树进行交换的函数。

07. 假设二叉树采用二叉链存储结构存储，设计一个算法，求先序遍历序列中第  $k$  （ $1 \leqslant k \leqslant$  二叉树中结点个数）个结点的值。

08. 已知二叉树以二叉链表存储，编写算法完成：对于树中每个元素值为  $x$  的结点，删除以它为根的子树，并释放相应的空间。

09. 在二叉树中查找值为  $x$  的结点，试编写算法（用 C 语言）打印值为  $x$  的结点的所有祖先，假设值为  $x$  的结点不多于一个。

10. 设一棵二叉树的结点结构为(PLLINK, INFO, RLINK)，ROOT 为指向该二叉树根结点的指针，p 和 q 分别为指向该二叉树中任意两个结点的指针，试编写算法 ANCESTOR (ROOT, p, q, r)，找到 p 和 q 的最近公共祖先结点 r。

11. 假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树  $b$  的宽度（具有结点数最多的那一层的结点个数）。

12. 设有一棵满二叉树（所有结点值均不同），已知其先序序列为 pre，设计一个算法求其后序序列 post。

13. 设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为 head。二叉树按二叉链表方式存储，链接时用叶结点的右指针域来存放单链表指针。

14. 试设计判断两棵二叉树是否相似的算法。所谓二叉树  $T_{1}$  和  $T_{2}$  相似，指的是  $T_{1}$  和  $T_{2}$  都是空的二叉树或都只有一个根结点；或者  $T_{1}$  的左子树和  $T_{2}$  的左子树是相似的，且  $T_{1}$  的右子树和  $T_{2}$  的右子树是相似的。

15.【2014统考真题】二叉树的带权路径长度（WPL）是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树  $T$  ，采用二叉链表存储，结点结构为

<table><tr><td>left</td><td>weight</td><td>right</td></tr></table>

其中叶结点的 weight 域保存该结点的非负权值。设 root 为指向  $T$  的根结点的指针，请设计求  $T$  的 WPL 的算法，要求：

1）给出算法的基本设计思想。

2）使用C或  $\mathrm{C + + }$  语言，给出二叉树结点的数据类型定义。

3）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

16.【2017统考真题】请设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两棵表达式树作为算法的输入时：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b42f2fcd20262be8420811b232c3d712bb70803562acc7dd2e186a78ccc1ed56.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2ff6948e1c7a87cf0ee8d32962ca63692e7abda0ce2bc97f654e026982cd58df.jpg)


输出的等价中缀表达式分别为  $(a + b) * (c * (-d))$  和  $(a * b) + (-(c - d))$  。

二叉树结点定义如下：

```txt
typedef struct node{ char data[10]; //存储操作数或操作符 struct node \*left，\*right; }BTree;
```

要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

17.【2022统考真题】已知非空二叉树  $T$  的结点值均为正整数，采用顺序存储方式保存，数据结构定义如下：

```txt
typedef struct { //MAX_SIZE为已定义常量 int SqBiTreeNode[MAX_SIZE]; //保存二叉树结点值的数组 int ElemNum; //实际占用的数组元素个数 } SqBiTree;
```

$T$  中不存在的结点在数组 SqBiTreeNode 中用 -1 表示。例如，对于下图所示的两棵非空二叉树  $T_{1}$  和  $T_{2}$ ，

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2d9181bb859bb4a2b499ed6c5b71b1b153710c2769c09d6ce42e430f26a0597c.jpg)



二叉树  $T_{1}$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b9438b4b87764dd2f397db17c7fb909538ee23f9811de720a6307452c27eeb43.jpg)



二叉树  $T_{2}$


$T_{1}$  的存储结果如下：

T1.SqBiTNode

<table><tr><td>40</td><td>25</td><td>60</td><td>-1</td><td>30</td><td>-1</td><td>80</td><td>-1</td><td>-1</td><td>27</td><td></td><td></td></tr></table>

T1.ElemNum=10

$T_{2}$  的存储结果如下：

T2.SqBiTNode

<table><tr><td>40</td><td>50</td><td>60</td><td>-1</td><td>30</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>35</td><td></td></tr></table>

T2. ElemNum=11

请设计一个尽可能高效的算法，判定一棵采用这种方式存储的二叉树是否为二叉搜索树，若是，则返回 true，否则，返回 false。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

# 5.3.4 答案与解析

# 一、单项选择题

# 01. C

二叉树中序遍历的最后一个结点一定是从根开始沿右子女指针链走到底的结点，设用  $p$  指示。若结点  $p$  不是叶结点（其左子树非空），则前序遍历的最后一个结点在它的左子树中，选项A、B错误；若结点  $p$  是叶结点，则前序与中序遍历的最后一个结点就是它，选项C正确。若中序遍历的最后一个结点  $p$  不是叶结点，它还有一个左子女  $q$  ，结点  $q$  是叶结点，那么结点  $q$  是前序遍历的最后一个结点，但不是中序遍历的最后一个结点，选项D错误。

# 02. C

三种遍历方式中，都先遍历左子树，再遍历右子树，因此  $b$  一定在  $c$  的前面访问。

# 03. C

中序遍历时，先访问左子树，再访问根结点，后访问右子树。 $n$  在  $m$  前的3种可能性如下图所示，从中看出  $n$  总是在  $m$  的左方。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e2f1ec9e96d47ce10839bd9e374ec7196d5c868a40a366e360b6f3a29da81dc3.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5dcd1045f3855ca9b1a838dd4b0434cdd9f70ec10b4f33ec68881115d3c6b07a.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3be4859e1ed48bf5f1ab4770eb0e391492597ad338c48bb48f976aef16b2fd84.jpg)



(c)


【另解】设  $n$  和  $m$  的最近公共祖先  $p$  ，则有以下可能：

情形1，  $m$  和  $n$  分别在  $p$  的左、右（右、左）分支上；情形2，  $m$  或  $n$  为  $p$  结点，另一结点在  $p$  的分支上。只有  $n$  和  $m$  分别处于  $p$  的左、右分支上，  $m$  为祖先结点且  $n$  位于  $m$  的左分支，  $n$  为祖先结点且  $m$  位于  $n$  的右分支，符合题意。

# 04. D

后序遍历的顺序是LRN，若  $n$  在  $\mathbf{N}$  的左子树，  $m$  在  $\mathbf{N}$  的右子树，则在后序遍历的过程中  $n$  在  $m$  之前访问；若  $n$  是  $m$  的子孙，设  $m$  在  $\mathbf{N}$  的位置，则  $n$  无论是在  $m$  的左子树还是在右子树，在后序遍历的过程中  $n$  都在  $m$  之前访问。其他都不可以。选项C要成立，就需加上两个结点位于同一层这个条件。

# 05. C

在二叉树的数组存储结构中，下标为  $i$  的结点的左、右孩子的下标分别为  $2i + 1$  和  $2i + 2$  （若存在），画出二叉树的形态如下图所示，则后序遍历序列为gdbhefca。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/045507ac039b6018b45eaa1d9631d959d8c7cb9faf29024ca373b0091b4f422c.jpg)


06. B

三种遍历方式中，访问左、右子树的先后顺序是不变的，只是访问根结点的顺序不同，因此叶结点的先后顺序完全相同。此外，读者可以采用特殊值法，画一个结点数为3的满二叉树，采用三种遍历方式来验证答案的正确性。

07. C

对每个顶点从1开始按序编号，要求结点编号大于其左、右孩子编号，并且左孩子编号小于右孩子编号。编号越大说明遍历顺序越靠后，因此，三者遍历顺序为先左子树、再右子树、后根结点。4个选项中仅后序遍历满足要求。

08. B

结点  $\nu$  的编号比其左子树上的最小编号还小，而  $\nu$  的右子树中的最小编号大于  $\nu$  的左子树中的最大编号，因此  $\nu$  的编号比其左、右子树上的所有编号都小，显然是按先序遍历次序。

09. D

前序为  $A$  、  $B$  、  $C$  的不同二叉树共有5种，其中后序为  $C$  、  $B$  、  $A$  的有4种（前4种），都是单支树，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b8407f150b76e504a8f9d09356fc9c89c5aa5e8691abce7961bee0290f74c135.jpg)


10. C

7个结点的完全二叉树是一棵3层的满二叉树，画出相应二叉树的树形，根据后序遍历序列填入相应的结点，得到相应的完全二叉树，求得其先序遍历序列为ABCDEFG。

11. C

二叉树的前序遍历为NLR，后序遍历为LRN。根据题意，在前序序列中  $X$  在  $Y$  之前，在后序序列中  $X$  在  $Y$  之后，若设  $X$  在根的位置， $Y$  在其左子树或右子树中，即满足要求。

12. C

先序序列是  $a \cdots b \cdots$ ，因此  $a$  和  $b$  结点的 3 种情况如下图(a)～(c)所示。中序序列是  $a \cdots b \cdots a \cdots$ ，因此  $a$  和  $b$  结点的 3 种情况如下图(d)～(f)所示，相同部分是  $b$  在  $a$  的左子树中。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8f3cafef1e3b71cc2dddb80e0f6023222a7ca1fd7ea34ed99fb8c2eeb8b9cd4f.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ada8629c009ffa3580d7ebb02b00140fc925473bf9ec41d90d09dbfae3a348bb.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/23b93e4e1d5c7ec4a961bd94fdab3d5ba767e27c5bbda59e31b16b49f407532f.jpg)



(c)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/16c44b7da081acb9e17b32bf30a9e3f43ada7204bb3ad054c5fa1ea5ec55e30a.jpg)



(d)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1fe45b99a413eb1e133d8d928c87e03c246f0fa478ffefbcaaccb010dc57c697.jpg)



(c)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/06611325cdd9e8a4e1f3592261c2d81f1f36112027b7691ef601d296d340b708.jpg)



(f)


13. B

解法1：由题可知，1为根结点，2为1的孩子。对于选项A，3应为1的左孩子，前序序列应为  $13\dots$  ，不符题意。类似地，选项C也是错误的。对于选项B,2为1的右孩子，3为2的右孩子满足题意。对于选项D，463572应为1的右子树，2为1的右孩子，46357为2的左子树，3为2的左孩子，46为3的左子树，57为3的右子树，前序序列4、6应相连，5、7应相连，不符题意。

解法2：前序遍历时需要借助栈。二叉树的前序序列和中序序列的关系相当于以前序序列作为入栈次序，以中序序列作为出栈次序。题中以1234567入栈；对于选项A，第一个出栈的是3，所以1不可能在2之前出栈，错误。对于选项C，1不可能在3之前出栈，错误。对于选项D，6第三个出栈，此时栈顶元素是5，不是3，错误。选项B正确。

解法3：因前序序列和中序序列可以确定一棵二叉树，所以可试着用题目中的序列构造出相应的二叉树，即可得知，只有选项B的序列可以构造出二叉树。

# 14. D

先序序列为NLR，后序序列为LRN，虽然可以唯一确定树的根结点，但无法划分左、右子树。例如，先序序列为  $AB$  ，后序序列为  $BA$  ，则其对应的二叉树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4e29f6f66c562f3053bdcbda40b301f5f13d6110aa49cba72b0a7cde8b5608dc.jpg)


# 15. B

中序遍历是“左根右”，后序遍历是“左右根”，当任一结点没有右子树时，两种遍历都是“左根”。显然，当二叉树为空树或只有根结点时，其中序序列和后序序列也相同。

# 16. D

根据后序序列与中序序列可构造出二叉树，如下图所示。由图可知先序序列为 CEDBA。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/74d0c38fdc159f053976bca3fa7133cb619c9a8b64f6f3b615da3111953536f2.jpg)



(a)确定根结点


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/025f7ade09cb12c928ac816ab3d8c6706ca740a91e948cc1bb62d2bc1de61888.jpg)



(b) 确定左子树根结点


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/531547e89f2bd6a6c38855fe09b5debfe302be04215e8e9b502af8d9cdc48142.jpg)



(c) 确定剩下的子树


# 17. A

对于这种遍历序列问题，先根据遍历的性质排除若干项，若还无法确定答案，则再根据遍历结果得到二叉树，找到对应遍历序列。例如，在本题中，已知先序和中序遍历结果，可知本树的根结点为  $A$  ，左子树有  $C$  和  $B$  ，其余为右子树，则后序遍历结果中，  $A$  一定在最后，并且  $C$  和  $B$  一定在前面，排除选项B和D。又因先序中有DEF，中序中有EDF，则  $D$  为这个子树的根，所以  $D$  在后序中排在  $EF$  之后。

根据二叉树的递归定义，要确定二叉树，就要分别找到根结点和左、右子树。因此，根据遍历结果，必定要确定根结点位置和如何划分左、右子树，才可以确定最终的二叉树。因此，仅有先序和后序遍历不能唯一确定一棵二叉树，而二者之一加上中序遍历都可以唯一确定一棵二叉树。如在本题中，根据先序和中序遍历的结果确定二叉树的过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ffc4fdd06d4719d36d937f7256271589bd40e6366a02b440de3bc5cff0f362b5.jpg)



(a) 确定根结点


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/840ddb3775463e2e38b3750c069e9c212b6486887e0e60dff7e48fea3b5f7365.jpg)



(b)确定左子树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b0d28cc109475b151ce67cfd55fcc489e0d1fa7ccd74cacf4896b5cdc9095fcb.jpg)



(c)确定右子树


# 18. B

可构造出二叉树如下图所示。因此，先序序列为  $ABCDEF$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b406290d9398877a8404391a33d7ece8ce78e4df4af7c8c8d2e6d630bf5cd001.jpg)



(a) 确定根结点


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4e20ba647feb2079d1cbb5495c703d30b59c54abf58d5aacd78842e2ba6b1b7b.jpg)



(b)确定右子树的根结点


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fa075d60d9f2a2abc5c4844d57227feed83d3742a260a18229a2d51bf4d6222a.jpg)



(c) 确定剩下的子树


# 19. B

先序遍历是根左右，祖先  $a$  先于子孙  $b$  访问，即  $\mathrm{pre}(a) < \mathrm{pre}(b)$ ，因此选项A一定成立。后序遍历是左右根，子孙  $b$  先于祖先  $a$  访问，即  $\mathrm{post}(b) < \mathrm{post}(a)$ ，因此选项B一定不成立。中序遍历是左根右，左子树中的子孙先于祖先访问，右子树中的子孙后于祖先访问，因此子孙的编号可能小于祖先的编号，也可能大于祖先的编号，选项C和D都有可能。

# 20. C

删除一个结点时，需要先递归地删除它的左、右孩子，并释放它们所占的存储空间，然后删除该结点，并删除它所占的存储空间，这正好和后序遍历的访问顺序相吻合。

# 21. B

只要交换  $T$  中所有分支结点的左右子树，就能得到一棵中序遍历序列为降序序列的树，而这并不会改变根结点，叶结点也仅仅交换位置，仍是原  $T$  中的叶结点，选项C、D错误。交换  $T$  中所有分支结点的左右子树，要么先处理根结点，然后递归地处理左右子树，即先序遍历；要么先处理左右子树，然后处理根结点，即后序遍历；中序遍历是不适合的。选项A错误，选项B正确。

# 22. A

线索是前驱结点和后继结点的指针，引入线索的目的是加快对二叉树的遍历。

# 23.C

二叉树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构。

# 24.C

$n$  个结点共有链域指针  $2n$  个，其中，除根结点外，每个结点都被一个指针指向。剩余的链域建立线索，共  $2n - (n - 1) = n + 1$  个线索。

# 25. C

线索二叉树中用 ltag/rtag 标识结点的左/右指针域是否为线索，其值为 1 时，对应指针域为线索，其值为 0 时，对应指针域为左/右孩子。

# 26. D

对左子树为空的二叉树进行先序线索化，根结点的左子树为空并且也没有前驱结点（先遍历根结点），先序遍历的最后一个元素为叶结点，左、右子树均为空且有前驱无后继结点，所以线索化后，树中空链域有2个。

# 27. D

不是每个结点通过线索都可以直接找到它的前驱和后继。在先序线索二叉树中查找一个结点的先序后继很简单，而查找先序前驱必须知道该结点的双亲结点。同样，在后序线索二叉树中查找一个结点的后序前驱也很简单，而查找后序后继也必须知道该结点的双亲结点，二叉链表中没有存放双亲的指针。

# 28. D

后序线索二叉树不能有效解决求后序后继的问题。如下图所示，结点  $E$  的右指针指向右孩子，

而在后序序列中  $E$  的后继结点为  $B$  ，在查找  $E$  的后继时仍然只能按常规方法来查找。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8f2515333ad7e8d70f7be459ff100c48b0448a15e307d53b863827f8394b5e94.jpg)


29. C

在二叉中序线索树中，某结点若有左孩子，则按照中序“左根右”的顺序，该结点的前驱结点为左子树中最右的一个结点（注意，并不一定是最右叶结点）。

30. A

在二叉树的后序遍历中，叶结点  $X$  的后继是其双亲，因此  $X$  的右线索应指向该结点。

31. C

后序线索树遍历时，最后访问根结点，若从右孩子  $x$  返回访问父结点，则结点  $x$  的右孩子不一定为空（右指针无法指向其后继），因此通过指针可能无法遍历整棵树。如下图所示，结点中的数字表示遍历的顺序，图(c)中结点6的右指针指向其右孩子5，而不指向其后序后继结点7，因此后序遍历还需要栈的支持，而图(a)和图(b)均可遍历。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bc16e0afd48560759ac56c437c56bd6088bbd0127107dd65cb4224c65c10d615.jpg)



(a) 先序线索树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/49fbfd60eda8682d6ffd7d078a668d061e2583ca93d88e19d9e4acb0efd48171.jpg)



(b) 中序线索树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/de96fa3ff4d14ba761dfbdc7d2bc830b40866782bf72428949a67d01b0e0a29f.jpg)



(c)后序线索树


32. B

非空二叉树的先序序列和后序序列相反，即“根左右”与“左右根”顺序相反，因此树只有根结点，或根结点只有左子树或右子树，其子树也有同样的性质，任意结点只有一个孩子，才能满足先序序列和后序序列正好相反。此时树形应为一个长链，树中仅有一个叶结点。

33. D

非空二叉树的先序序列和中序序列相反，即“根左右”与“左根右”顺序相反，因此树只有根结点，或任意一个结点只有左孩子，此时树形应该是一棵向左倾斜的单支树，这棵单支树只有一个叶结点。但是，只有一个叶结点的二叉树不能保证任意一个结点无右孩子。

34. D

分析遍历后的结点序列，可以看出根结点是在中间被访问的，而且右子树结点在左子树之前，则遍历的方法是RNL。本题考查的遍历方法并不是二叉树遍历的3种基本遍历方法，对于考生而言，重要的是掌握遍历的思想。

35. D

题中所给二叉树的后序序列为  $dbca$  。结点  $d$  无前驱和左子树，左链域空，无右子树，右链域指向其后继结点  $b$  ；结点  $b$  无左子树，左链域指向其前驱结点  $d$  ；结点c无左子树，左链域指向其前驱结点  $b$  ，无右子树，右链域指向其后继结点  $a$  。

36. C

前序序列为NLR，后序序列为LRN，因为前序序列和后序序列刚好相反，所以不可能存在一个结点同时有左右孩子，即二叉树的高度为4。1为根结点，根结点只能有左孩子（或右孩子），

因此在中序序列中，1或在序列首或在序列尾，选项A、B、C、D皆满足要求。仅考虑以1的孩子结点2为根结点的子树，它也只能有左孩子（或右孩子），因此在中序序列中，2或在序列首或在序列尾，选项A、B、D皆满足要求。

【另解】画出各选项与题干信息所对应的二叉树如下，所以选项A、B、D均满足。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5d595aa04951553318ea1e77772e6d19d9f042da61482db07c776148f5298171.jpg)


# 37. A

前序序列和后序序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为  $XY$  与后序序列为  $YX$  时，则  $X$  为  $Y$  的祖先。考虑前序序列  $a, e, b, d, c$ 、后序序列  $b, c, d, e, a$ ，可知  $a$  为根结点， $e$  为  $a$  的孩子结点；此外，由  $a$  的孩子结点的前序序列  $e, b, d, c$ 、后序序列  $b, c, d, e$ ，可知  $e$  是  $bcd$  的祖先，所以根结点的孩子结点只有  $e$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a6431f711b668645fe2c6299314ab01e5bde22818c3eca4f9898ab82357cb121.jpg)


排除法：显然  $a$  为根结点，且确定  $e$  为  $a$  的孩子结点，排除选项D。各种遍历算法中左右子树的遍历次序是固定的，若  $b$  也为  $a$  的孩子结点，则在前序序列和后序序列中  $e$ 、 $b$  的相对次序应是不变的，所以排除选项B，同理排除选项C。

特殊法：前序序列和后序序列对应多棵不同的二叉树树形，我们只需画出满足该条件的任意一棵二叉树即可，任意一棵二叉树必定满足正确选项的要求。

显然选择选项A，最终得到的二叉树满足题设中前序序列和后序序列的要求。

# 38. A。

根据后序线索二叉树的定义， $X$  结点为叶结点且有左兄弟，因此这个结点为右孩子结点，利用后序遍历的方式可知  $X$  结点的后序后继是其父结点，即其右线索指向的是父结点。为了更加形象，在解题的过程中可以画出如下所示的草图。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f128ae42d21a75601f0e4a7b1dc78b02eeffd88f1c6daa837f298fcb2d2f6658.jpg)


# 39. D

线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列debxac，中序遍历中在  $x$  左边和右边的字符，就是它在中序线索化的左、右线索，即  $b, a$ 。

# 40. B

根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序

序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列  $a, b, c, d$  为入栈次序，则出栈序列的个数为？”对于  $n$  个不同元素入栈，出栈序列的个数为  $\frac{1}{n+1} C_{2n}^{n} = 14$ 。

# 41. B

后序序列先访问左子树，接着访问右子树，最后访问父结点，递归进行。根结点左子树的叶结点首先被访问，它是  $e$  。接下来是它的父结点  $a$  ，然后是  $a$  的父结点  $c$  。接着访问根结点的右子树。它的叶结点  $b$  首先被访问，然后是  $b$  的父结点  $d$  ，再后是  $d$  的父结点  $g$  ，最后是根结点  $f$  ，如下图所示。因此  $d$  与  $a$  同层，选项B正确。公众号：小兔网盘免费分享无水印PDF

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/015546d28ecec15caa4a7a76dad970ae5b456b55cef76aa2decea4a6a09715e1.jpg)


# 42. B

先序序列先访问父结点，接着访问左子树，然后访问右子树。中序序列先访问左子树，接着访问父结点，然后访问右子树，递归进行。若所有非叶结点只有右子树，则先序序列和中序序列都先访问父结点，后访问右子树，递归进行。

# 43. B

对于此类题，每种情况只需举出一个反例即可。如图1所示， $q$  是  $p$  的双亲，中序遍历序列为  $\{p, q\}$ ，选项I可能。如图2所示， $q$  是  $p$  的右孩子，中序遍历序列为  $\{p, q\}$ ，选项II可能。如图4所示， $q$  是  $p$  的双亲的双亲，中序遍历序列为  $\{x, p, q\}$ ，选项IV可能。如图3所示， $q$  是  $p$  的右兄弟， $F$  是  $q$  和  $p$  的父结点，中序遍历要求先遍历左子树，再访问根结点，最后遍历右子树，因此一定先访问  $p$ ，再访问  $F$ ，最后访问  $q$ ， $p$  和  $q$  不可能相邻出现，选项III不可能。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/818dfb8106c3b745215415514fd196f8f7c4d9db1fe4c3048276a20a74e5f536.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/58252c30dc6a1bafdefa8150de0bdd08c1f910694d52ddfdf7ce405cb0df7ddb.jpg)



图2


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/63e9151bcd50311997ad8dac29ba2f4e938fc44cd5877aa3f540f3d6a834b655.jpg)



图3


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d265cdfd9c2a57e5b18c2c00b68663b4e69d6092905a43782063f9911134b837.jpg)



图4


# 44. A

根据二叉树的树形和后序遍历序列，可以轻松地将各字母填入结点中，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6ec62209cbf9b5552bd243eb05f6a976375d51dc884810e65a2d02736849672a.jpg)


然后对该二叉树进行先序遍历，得到序列aedfbc。

# 45. A

根据中序遍历的特点， $\nu$  有左右子树，以  $\nu$  为根的子树的中序序列为： $\nu$  的左子树的中序序列， $\nu, \nu$  的右子树的中序序列。又因为  $T$  的中序序列为“ $\cdots, p, \nu, q, \cdots$ ”，可知  $p$  属于  $\nu$  的左子树， $q$  属于  $\nu$  的右子树。在  $\nu$  的左子树的中序序列中：假设  $p$  有右孩子，则  $p$  的右孩子在中序序列中应在  $p$  之后，与  $p$  是最后一个遍历结点矛盾，因此  $p$  不存在右孩子。在  $\nu$  的右子树的中序序列中：假设  $q$  存在左孩子，则  $q$  的左孩子在中序序列中应在  $q$  之前，与  $q$  是第一个遍历结点矛盾，因此  $q$  不存在左孩子。

# 二、综合应用题

# 01.【解答】

二叉树的先序序列是NLR，后序序列是LRN。要使  $\mathrm{NLR} = \mathrm{NRL}$  （后序序列反序）成立，L或R应为空，这样的二叉树每层只有一个结点，即二叉树的形态是其高度等于结点个数。以3个结点  $a, b, c$  为例，其形态如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/60d73b34a512a38a16a7ccf9aa25efec55bf93f667353a1e8d5c3e6171242572.jpg)


# 02.【解答】

二叉树的先序序列是NLR，后序序列是LRN。要使  $\mathrm{NLR} = \mathrm{LRN}$  成立，L和R应均为空，所以满足条件的二叉树只有一个根结点。

# 03.【解答】

采用层次遍历的算法，设置变量 level 记录当前结点所在的层数，设置变量 last 指向当前层的最右结点，每次层次遍历出队时与 last 指针比较，若两者相等，则层数加 1，并让 last 指向下一层的最右结点，直到遍历完成。level 的值即二叉树的高度。

算法实现如下：

```c
int Btdepth(BiT){  
//采用层次遍历的非递归方法求解二叉树的高度  
if(!T)  
return 0; //树空，高度为0  
int front  $= -1$  ,rear  $= -1$  .  
int last  $= 0$  ,level  $= 0$  ; //last指向当前层的最右结点  
BiTree Q[MaxSize]; //设置队列Q，元素是二叉树结点指针且容量足够  
Q[++rear]  $\equiv$  T; //将根结点入队  
BiTree p;  
while(front<rear} //队不空，则循环 $\mathrm{p = Q[ + + }$  front]; //队列元素出队，即正在访问的结点if(p->lchild)Q[++rear]=p->lchild;//左孩子入队if(p->rchild)Q[++rear]=p->rchild;//右孩子入队if(front  $= =$  last）{//处理该层的最右结点level++; //层数增1last=rear; //last指向下层}  
1  
return level;
```

求某层的结点个数、每层的结点个数、树的最大宽度等，都可采用与此题类似的思想。当然，

此题可编写为递归算法，其实现如下：

```javascript
int Btdepth2 (BiTree T) { if  $(\mathrm{T} = =\mathrm{NULL})$  return 0; //空树，高度为0 ldep=Btdepth2(T->lchild); //左子树高度 rdep=Btdepth2(T->rchild); //右子树高度 if(ldep>rdep) return ldep+1; //树的高度为子树最大高度加根结点 else return rdep+1;
```

# 04.【解答】

根据完全二叉树的定义，具有  $n$  个结点的完全二叉树与满二叉树中编号从  $1 \sim n$  的结点一一对应。算法思想：采用层次遍历算法，将所有结点加入队列（包括空结点）。遇到空结点时，查看其后是否有非空结点。若有，则二叉树不是完全二叉树。

算法实现如下：

```txt
bool IsComplete(BiTree T){ //本算法判断给定二叉树是否为完全二叉树 InitQueue(Q); if(!T) return true; //空树为满二叉树 EnQueue(Q,T); while (!IsEmpty(Q)) { DeQueue(Q,p); if(p) { //结点非空，将其左、右子树入队列 EnQueue(Q,p->lchild); EnQueue(Q,p->rchild); } else //结点为空，检查其后是否有非空结点 while (!IsEmpty(Q)) { DeQueue(Q,p); if(p) //结点非空，则二叉树为非完全二叉树 return false; } } return true; }
```

# 05.【解答】

计算一棵二叉树  $\mathsf{b}$  中所有双分支结点个数的递归模型  $f(b)$  如下：

```c
f  $(\mathsf{b}) = 0$  若  $\mathrm{b = NULL}$    
f  $(\mathsf{b}) = \mathsf{f}(\mathsf{b - > lchild}) + \mathsf{f}(\mathsf{b - > rchild}) + 1$  若  $\star \mathbf{b}$  为双分支结点  
f  $(\mathsf{b}) = \mathsf{f}(\mathsf{b - > lchild}) + \mathsf{f}(\mathsf{b - > rchild})$  其他情况（\*b为单分支结点或叶结点）  
具体算法实现如下：int DsonNodes(BiTree b){if(b==NULL)return 0;else if(b->lchild!=NULL&&b->rchild!=NULL）//双分支结点return DsonNodes(b->lchild)+DsonNodes(b->rchild)+1;elsereturn DsonNodes(b->lchild)+DsonNodes(b->rchild);
```

当然，本题也可以设置一个全局变量 Num，每遍历到一个结点时，判断每个结点是否为分支

结点（左、右结点都不为空，注意是双分支），若是，则  $\mathrm{Num}++$ 。

# 06.【解答】

采用递归算法实现交换二叉树的左、右子树，首先交换b结点的左孩子的左、右子树，然后交换b结点的右孩子的左、右子树，最后交换b结点的左、右孩子，当结点为空时递归结束（后序遍历的思想）。算法实现如下：

```javascript
void swap (BiTree b) { //本算法递归地交换二叉树的左、右子树 if(b){ swap(b->lchild); //递归地交换左子树 swap(b->rchild); //递归地交换右子树 temp=b->lchild; //交换左、右孩子结点 b->lchild=b->rchild; b->rchild=temp; }
```

# 07.【解答】

设置一个全局变量i（初值为1）来表示进行先序遍历时，当前访问的是第几个结点。然后可以借用先序遍历的代码模型，先序遍历二叉树。当二叉树b为空时，返回特殊字符'#'；当  $k == i$  时，该结点即要找的结点，返回b->data；当  $k \neq i$  时，递归地在左子树中查找，若找到则返回该值，否则继续递归地在右子树中查找，并返回其结果。对应的递归模型如下：

```txt
$\mathrm{f(b,k) = '}\# '$  当  $\mathbf{b} =$  NULL时  
 $\mathrm{f(b,k) = b->data}$  当  $i = k$  时  
 $\mathrm{f(b,k) = ((ch = f(b->lchild,k)) == '}\# '$  ?f(b->rchild,k):ch）其他情况
```

算法的实现如下：

```c
int i=1; //遍历序号的全局变量ElemType PreNode (BiTree b, int k) {//本算法查找二叉树先序遍历序列中第k个结点的值if  $(\mathrm{b} == \mathrm{NULL})$  //空结点，则返回特殊字符return '#'; if  $(\mathrm{i} == \mathrm{k})$  //相等，则当前结点即第k个结点return b->data;i++; //下一个结点ch=PreNode(b->lchild,k); //左子树中递归寻找if  $(\mathrm{ch} != '##')$  //在左子树中，则返回该值return ch;ch=PreNode(b->rchild,k); //在右子树中递归寻找return ch;
```

本题实质上就是一个遍历算法的实现，只不过用一个全局变量来记录访问的序号，求其他遍历序列的第  $k$  个结点也采用相似的方法。二叉树的遍历算法可以引申出大量的算法题，因此考生务必要熟练掌握二叉树的遍历算法。

# 08.【解答】

删除以元素值  $\mathbf{x}$  为根的子树，只要能删除其左、右子树，就可以释放值为  $\mathbf{x}$  的根结点，因此宜采用后序遍历。算法思想：删除值为  $\mathbf{x}$  的结点，意味着应将其父结点的左（右）子女指针置空，用层次遍历易于找到某结点的父结点。本题要求删除树中每个元素值为  $\mathbf{x}$  的结点的子树，因此要遍历完整棵二叉树。算法实现如下：

```javascript
void DeleteXTree(BiTree &bt) { //删除以bt为根的子树 if (bt) {
```

```c
DeleteXTree(bt->lchild); DeleteXTree(bt->rchild); //删除bt的左子树、右子树 free(bt); //释放被删结点所占的存储空间 }   
}   
//在二叉树上查找所有以  $\mathbf{x}$  为元素值的结点，并删除以其为根的子树   
void Search(BiTree bt,ElemType x){ BiTree Q[]; //Q是存放二叉树结点指针的队列，容量足够大 if(bt){ if(bt->data==x){ //若根结点值为  $\mathbf{x}$  ，则删除整棵树 exit(0); 1 InitQueue(Q); EnQueue(Q,bt); while(!IsEmpty(Q)){ DeQueue(Q,p); if(p->lchild) //若左子女非空 if(p->lchild->data==x){ //左子树符合则删除左子树 DeleteXTree(p->lchild); p->lchild=NULL; } //父结点的左子女置空 else EnQueue(Q,p->lchild); //左子树入队列 if(p->rchild) //若右子女非空 if(p->rchild->data==x){ //右子女符合则删除右子树 DeleteXTree(p->rchild); p->rchild=NULL; } //父结点的右子女置空 else EnQueue(Q,p->rchild); //右子女入队列 } }
```

# 09.【解答】

算法思想：采用非递归后序遍历，最后访问根结点，访问到值为  $x$  的结点时，栈中所有元素均为该结点的祖先，依次出栈打印即可。算法实现如下：

```c
typedef struct{ BiTree t; int tag; }stack; //tag  $= 0$  表示左子女被访问，tag  $= 1$  表示右子女被访问 void Search(BiTree bt,ElemType x){ //在二叉树bt中，查找值为  $\mathbf{x}$  的结点，并打印其所有祖先 stacks[]; //栈容量足够大 top  $= 0$  while  $(\mathtt{bt}! = \mathtt{NULL}||\mathtt{top} > 0)$  { while  $(\mathtt{bt}! = \mathtt{NULL}&&\mathtt{bt}->\mathtt{data}! = \mathtt{x})$  { //结点入栈 s[++top].t=bt; s[top].tag  $= 0$  . bt=bt->lchild; //沿左分支向下 } if  $(\mathtt{bt}! = \mathtt{NULL}&&\mathtt{bt}->\mathtt{data} == \mathtt{x})$  { printf("所查结点的所有祖先结点的值为：\\n"); //找到x for  $(\mathrm{i} = 1;\mathrm{i} <   = \mathrm{top};\mathrm{i} + + )$  printf("%d",s[i].t->data); //输出祖先值后结束
```

```txt
exit(1);   
}   
while(top!=0&&s[top].tag==1) top--; //退栈（空遍历） if(top!=0){ s[top].tag=1; bt=s[top].t->rchild; //沿右分支向下遍历 }//while(bt!=NULL||top>0)
```

因为查找的过程就是后序遍历的过程，所以使用的栈的深度不超过树的深度。

# 10.【解答】

后序遍历最后访问根结点，即在递归算法中，根是压在栈底的。本题要找  $p$  和  $q$  的最近公共祖先结点  $r$ ，不失一般性，设  $p$  在  $q$  的左边。算法思想：采用后序非递归算法，栈中存放二叉树结点的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。后序遍历必然先遍历到结点  $p$ ，栈中元素均为  $p$  的祖先。先将栈复制到另一辅助栈中。继续遍历到结点  $q$  时，将栈中元素从栈顶开始逐个到辅助栈中去匹配，第一个匹配（相等）的元素就是结点  $p$  和  $q$  的最近公共祖先。

算法实现如下：

```txt
typedef struct{BiTree t;int tag; //tag  $= 0$  表示左子女已被访问，tag  $= 1$  表示右子女已被访问}stack;stacks[]，s1[]； //栈，容量足够大BiTree Ancestor(BiTree ROOT,BiTNode \*p,BiTNode \*q){//本算法求二叉树中p和q指向结点的最近公共结点top  $= 0$  ;bt  $\equiv$  ROOT;while (bt!  $\equiv$  NULL||top>0）{while (bt！  $\equiv$  NULL）{s[++top].t  $\equiv$  bt;s[top].tag  $= 0$  bt  $\equiv$  bt->lchild;} //沿左分支向下while(top!  $= 0$  &&s[top].tag  $= = 1$  {//假定p在q的左侧，遇到p时，栈中元素均为p的祖先if(s[top].t  $= = p$  ）{for(i  $= 1$  ;i<=top;i++)s1[i]  $\equiv$  s[i];topl  $\equiv$  top;} //将栈s的元素转入辅助栈s1保存if(s[top].t  $= = q$  //找到q结点for(i  $\equiv$  top;i>0;i--）{//将栈中元素的树结点到s1中去匹配for(j  $\equiv$  top1;j>0;j--）if(s1[j].t  $= = s$  [i].t)return s[i].t; //p和q的最近公共祖先已找到}top--; //退栈} //whileif(top!  $= 0$  ）{s[top].tag  $= 1$  bt=s[top].t->rchild;} //沿右分支向下遍历} //whilereturn NULL; //p和q无公共祖先}
```

# 11.【解答】

采用层次遍历的方法求出所有结点的层次，并将所有结点和对应的层次放在一个队列中。然后通过扫描队列求出各层的结点总数，最大的层结点总数即二叉树的宽度。算法实现如下：

```txt
typedef struct{ BiTree data[MaxSize]; //保存队列中的结点指针 int level[MaxSize]； //保存data中相同下标结点的层次 int front,rear; }Qu; int BTWidth(BiTree b){ BiTree p; int k,max,i,n; Qu.front  $=$  Qu.rear  $\coloneqq -1$  ； //队列为空 Qu.rear++; Qu.data[Qu.rear]=b; //根结点指针入队 Qu.level[Qu.rear]=1; //根结点层次为1 while (Qu.front<Qu.rear){ Qu.front++; //出队 p=Qu.data[Qu.front]； //出队结点 k=Qu.level[Qu.front]； //出队结点的层次 if(p->lchild!=NULL){ //左孩子入队 Qu.rear++; Qu.data[Qu.rear]=p->lchild; Qu.level[Qu.rear]=k+1; } if(p->rchild!=NULL){ //右孩子入队 Qu.rear++; Qu.data[Qu.rear]=p->rchild; Qu.level[Qu.rear]=k+1; } }//while max=0;i=0; //max保存同一层最多的结点个数 k=1; //k表示从第一层开始查找 while(i<=Qu.rear){ //扫描队中所有元素 n=0; //n统计第k层的结点个数 while(i<=Qu.rear&&Qu.level[i]=k){ n++; i++; } k=Qu.level[i]; if(n>max) max=n; //保存最大的n } return max; }
```

# 注意

本题队列中的结点，在出队后仍需要保留在队列中，以便求二叉树的宽度，所以设置的队列采用非环形队列，否则在出队后可能被其他结点覆盖，无法再求二叉树的宽度。

# 12.【解答】

对一般二叉树，仅根据先序或后序序列，不能确定另一个遍历序列。但对满二叉树，任意一个结点的左、右子树均含有相等的结点数，同时，先序序列的第一个结点作为后序序列的最后一个结点，由此得到将先序序列 pre[l1..h1]转换为后序序列 post[l2..h2] 的递归模型如下：

f(pre,11,h1,post,l2,h2)=不做任何事情 h1<11时

```javascript
f(pre,l1,h1,post,l2,h2)=post[h2]=pre[l1] 其他情况取中间位置  $\mathrm{half} = (\mathrm{h}1 - 11) / 2$  将pre[11+1，11+half]左子树转换为post[12，12+half-1]，即f(pre,l1+1,l1+half,post,l2,l2+half-1);将pre[11+half+1,h1]右子树转换为post[12+half,h2-1]，即f(pre,l1+half+1,h1,post,l2+half,h2-1)。
```

其中，post[h2] = pre[11]表示后序序列的最后一个结点（根结点）等于先序序列的第一个结点（根结点）。相应的算法实现如下：

```javascript
void PreToPost(ElemType pre[],int l1,int h1,ElemType post[],int l2,int h2){ int half; if  $(\mathrm{h}1> = 11)$  { post[h2]=pre[l1]; half=(h1-l1)/2; PreToPost(pre,l1+1,l1+half,post,l2,l2+half-1); //转换左子树 PreToPost(pre,l1+half+1,h1,post,l2+half,h2-1); //转换右子树 }
```

例如，有以下代码：

```txt
ElemType \*pre="ABCDEFG";   
ElemType post[MaxSize];   
PreToPost(pre,0,6，post,0,6); printf("后序序列：");   
for(int  $i = 0$  ;i  $<   = 6$  ;i++) printf("%c",post[i]);   
printf("\n");
```

执行结果如下：

后序序列：CDBFGEA

# 13.【解答】

通常使用的先序、中序和后序遍历对于叶结点的访问顺序都是从左到右，这里选择中序递归遍历。算法思想：设置前驱结点指针 pre，初始为空。第一个叶结点由指针 head 指向，遍历到叶结点时，就将它前驱的 rchild 指针指向它，最后一个叶结点的 rchild 为空。算法实现如下：

```c
LinkedList head, pre=NULL; //全局变量  
LinkedList InOrder(BiTree bt) {  
if (bt) {  
    InOrder(bt->lchild); //中序遍历左子树  
if (bt->lchild==NULL&&bt->rchild==NULL) //叶结点  
if (pre==NULL) {  
    head=bt;  
    pre=bt;  
} //处理第一个叶结点  
else {  
    pre->rchild=bt;  
    pre=bt;  
} //将叶结点链入链表  
InOrder(bt->rchild); //中序遍历右子树  
pre->rchild=NULL; //设置链表尾  
}  
return head;
```

上述算法的时间复杂度为  $O(n)$  ，辅助变量使用head和pre，栈空间复杂度为  $O(n)$  。

# 14.【解答】

本题采用递归的思想求解，若  $T_{1}$  和  $T_{2}$  都是空树，则相似；若有一个为空另一个不空，则必然不相似；否则递归地比较它们的左、右子树是否相似。递归函数的定义如下：

1）  $f(T1, T2) = 1$ ；若  $T1 == T2 == NULL$ 。

2）f(T1,T2)  $= 0$  ；若T1和T2之一为NULL，另一个不为NULL。

3)  $f(T1, T2) = f(T1->lchild, T2->lchild) \& \& f(T1->rchild, T2->rchild)$ ; 若  $T1$  和  $T2$  均不为 NULL。

因此，算法实现如下：

```c
int similar(BiTree T1,BiTree T2){ //采用递归的算法判断两棵二叉树是否相似 int leftS,rightS; if  $(\mathrm{T}1 = =\mathrm{NULL}\& \& \mathrm{T}2 = =\mathrm{NULL})$  //两棵树皆空 return 1; else if  $(\mathrm{T}1 = =\mathrm{NULL}||\mathrm{T}2 = =\mathrm{NULL})$  //只有一棵树为空 return 0; else{ //递归判断 leftS=similar(T1->lchild,T2->lchild); rightS=similar(T1->rchild,T2->rchild); return leftS&&rightS; }
```

# 15.【解答】

二叉树的带权路径长度有两种常见的计算方法：①根据二叉树的带权路径长度的定义，二叉树的WPL值  $=$  树中全部叶结点的带权路径长度之和。②根据带权二叉树的性质，二叉树的WPL值  $=$  树中所有非叶结点的权值之和（记住该结论即可，不要求证明）。根据两种常见的计算方法，本题不难写出下列两种解法。

1）算法的基本设计思想。

$①$  本问题可采用递归算法实现。根据定义：

```txt
二叉树的WPL值  $=$  树中全部叶结点的带权路径长度之和 $=$  根结点左子树中全部叶结点的带权路径长度之和  $+$  根结点右子树中全部叶结点的带权路径长度之和
```

叶结点的带权路径长度  $=$  该结点的weight域的值  $\times$  该结点的深度设根结点的深度为0，若某结点的深度为  $d$  时，则其孩子结点的深度为  $d + 1$

在递归遍历二叉树结点的过程中，若遍历到叶结点，则返回该结点的带权路径长度，否则返回其左右子树的带权路径长度之和。

② 若借用非叶结点的 weight 域保存其孩子结点中 weight 域值的和，则树的 WPL 等于树中所有非叶结点 weight 域值之和。

采用后序遍历策略，在遍历二叉树  $T$  时递归计算每个非叶结点的weight域的值，则树  $T$  的WPL等于根结点左子树的WPL加上右子树的WPL，再加上根结点中weight域的值。在递归遍历二叉树结点的过程中，若遍历到叶结点，则return0并且退出递归，否则递归计算其左右子树的WPL和自身结点的权值。

2）二叉树结点的数据类型定义如下。

```txt
typedef struct node{ int weight; struct node \*left,\*right; }BTree;
```

3）算法的代码如下。

① 基于方法1的算法实现：

```c
int WPL(BTree *root) //根据WPL的定义采用递归算法实现  
{ return WPL1(root,0);  
}  
int WPL1(BTree *root,int d) //d为结点深度  
{ if(root->left==NULL&&root->right==NULL) return (root->weight*d); else return (WPL1(root->left,d+1)+WPL1(root->right,d+1));  
}
```

②基于方法2的算法实现：

```c
int WPL(BTree *root) //基于递归的后序遍历算法实现  
{ int w_l, w_r; if(root->left == NULL && root->right == NULL) return 0; else { w_l = WPL(root->left); //计算左子树的WPL w_r = WPL(root->right); //计算右子树的WPL root->weight = root->left->weight + root->right->weight; //填写非叶结点的weight域 return (w_l + w_r + root->weight); //返回WPL值 }
```

# 注意

上述两种算法为官方标准答案，当遍历到度为1的结点时，会传入空指针，导致空指针异常。但是，作为408考试的算法题，不要求考虑特殊的边界条件，只要算法思想正确，代码逻辑正确，即可得满分。因此，在复习过程中，无须花过多的时间抠代码的各种边界条件。

# 16.【解答】

1）算法的基本设计思想。

表达式树的中序序列加上必要的括号即等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。

表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定。为得到正确的中缀表达式，需要在生成遍历序列的同时，在适当位置增加必要的括号。显然，表达式的最外层（对应根结点）和操作数（对应叶结点）不需要添加括号。

2）算法实现。

将二叉树的中序遍历递归算法稍加改造即可得本题的答案。除根结点和叶结点外，遍历到其他结点时在遍历其左子树之前加上左括号，遍历完右子树后加上右括号。

```c
void BtreeToE(BTree \*root){ BtreeToExp(root,1); //根的高度为1   
}   
void BtreeToExp(BTree \*root,int deep){ if(root  $= =$  NULL) return; //空结点返回 else if(root->left  $= =$  NULL&&root->right  $= =$  NULL）//若为叶结点 printf("%s", root->data); //输出操作数，不加括号 else{ if(deep>1) printf("(); //若有子表达式则加一层括号
```

```c
BtreeToExp(root->left, deep+1);
printf("%s", root->data); //输出操作符
BtreeToExp(root->right, deep+1);
if (deep>1) printf(""); //若有子表达式则加一层括号
```

# 17.【解答1】

1）算法的基本设计思想。

对于采用顺序存储方式保存的二叉树，根结点保存在 SqBiTreeNode[0]中；当某结点保存在 SqBiTreeNode[i]中时，若有左孩子，则其值保存在 SqBiTreeNode[2i+1]中；若有右孩子，则其值保存在 SqBiTreeNode[2i+2]中；若有双亲结点，则其值保存在 SqBiTreeNode[(i-1)/2]中。

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。中序遍历二叉搜索树得到一个升序序列。

使用整型变量 val 记录中序遍历过程中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于或等于 val，则算法返回 false，否则，将 val 的值更新为当前结点的值。

2）算法实现。

```m4
define false 0
#define true 1
typedef int bool;
bool judgeInOrderBST(SqBiTree bt, int k, int *val) { //初始调用时k的值是0
if (k < bt.ElemNum && bt.SqBiTreeNode[k] != -1) {
    if (!judgeInOrderBST(bt, 2*k + 1, val)) return false;
    if (bt.SqBiTreeNode[k] <= *val) return false;
    *val = bt.SqBiTreeNode[k];
    if (!judgeInOrderBST(bt, 2*k + 2, val)) return false;
}
return true;
}
```

# 【解答2】

1）算法的基本设计思想。

对于采用顺序存储方式保存的二叉树，根结点保存在 SqBiTreeNode[0]中；当某结点保存在 SqBiTreeNode[i]中时，若有左孩子，则其值保存在 SqBiTreeNode[2i+1]中；若有右孩子，则其值保存在 SqBiTreeNode[2i+2]中；若有双亲结点，则其值保存在 SqBiTreeNode[(i-1)/2]中。

二叉搜索树需要满足的条件是：任意一个结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。设置两个数组 pmax 和 Tmin。根据二叉搜索树的定义，SqBiTNode[i] 中的值应该大于以 SqBiTNode[2i+1] 为根的子树中的最大值（保存在 pmax[2i+1] 中），小于以 SqBiTNode[2i+2] 为根的子树中的最小值（保存在 Tmin[2i+1] 中）。初始时，用数组 SqBiTNode 中前 ElemNum 个元素的值对数组 pmax 和 Tmin 初始化。

在数组 SqBiTreeNode 中从后向前扫描，扫描过程中逐一验证结点与子树之间是否满足上述的大小关系。

2）算法实现。

```c
define false 0  
#define true 1  
typedef int bool;  
bool judgeBST(SqBiTree bt) {  
    int k, m, *pmin, *pmax;  
    pmin = (int *) malloc(sizeof(int) * (bt.Num);  
    pmax = (int *) malloc(sizeof(int) * (bt.Num);  
    for (k = 0; k < bt.Num; k++) //辅助数组初始化
```

```javascript
pmin[k]=pmax[k]=bt.SqBiTNode[k];  
for(k=bt.ElemNum-1;k>0;k--){ //从最后一个叶结点向根遍历if(bt.SqBiTNode[k]！=-1){m=(k-1)/2; //双亲if  $(\mathrm{k}\% 2 = = 1\& \&$  bt.SqBiTNode[m]>pmax[k]) //其为左孩子pmin[m]=pmin[k];else if  $(\mathrm{k}\% 2 = = 0\& \&$  bt.SqBiTNode[m]<pmin[k]) //其为右孩子pmax[m]=pmax[k];else return false;1}1return true;
```

# 5.4 树、森林

# 5.4.1 树的存储结构

树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。

# 1. 双亲表示法

这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。如图5.20所示，根结点下标为0，其伪指针域为-1。

双亲表示法的存储结构描述如下：

```c
define MAX_tree_SIZE 100 //树中最多结点数  
typedef struct{ //树的结点定义ElemType data; //数据元素int parent; //双亲位置域}PTNode;  
typedef struct{ //树的类型定义PTNode nodes[MAX_tree_SIZE]; //双亲表示int n; //结点数}PTree;
```

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/786342e161e82aded6f0a9259052c610cdfa20f4efc19fd687a486b4cdc7ca2f.jpg)



(a)一棵树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/18cc8c818cd43ee1d491a604d276d36913e41503fb9bee79d06b58fcef8cda4f.jpg)



(b) 双亲表示


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b3559ba647ca7d78736637976072ee202df23641e58eb7f5ebbcd832a8a2cd36.jpg)



(c) 双亲指针图示



图5.20 树的双亲表示法


双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。

# 注意

区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。

# 2. 孩子表示法

孩子表示法是将每个结点的孩子结点视为一个线性表，且以单链表作为存储结构，则  $n$  个结点就有  $n$  个孩子链表（叶结点的孩子链表为空表）。而  $n$  个头指针又组成一个线性表，为便于查找，可采用顺序存储结构。图5.21(a)是图5.20(a)中的树的孩子表示法。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d67a603d52f7bbeae5b492d3874df0e331717d995942d271f0bb3023de282f80.jpg)



(a) 孩子表示法


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3b88d0b64bdf5128a59f41bbb3dbbaf7917696f7b9a91f88b4c8f9ea94fd6bbb.jpg)



(b）孩子兄弟表示法



图5.21 树的孩子表示法和孩子兄弟表示法


与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历  $n$  个结点中孩子链表指针域所指向的  $n$  个孩子链表。

# 3. 孩子兄弟表示法

孩子兄弟表示法也称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点），如图5.21(b)所示。

孩子兄弟表示法的存储结构描述如下：

```txt
typedef struct CSNode{ElemType data; //数据域struct CSNode \*firstchild,\*nextsibling; //第一个孩子和右兄弟指针}CSNode, \*CSTree;
```

孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。

# 5.4.2 树、森林与二叉树的转换

二叉树和树都可以用二叉链表作为存储结构。从物理结构上看，树的孩子兄弟表示法与二叉树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。

# 1. 树转换为二叉树

# 命题追踪 树和二叉树的转换及相关性质的推理（2009、2011）

树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则也称左孩子右兄弟。根结点没有兄弟，因此树转换得到的二叉树没有右子树，如图5.22所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/208eae8c85a610a114c566e94d76748b8e4a33149291e0a09a019d01a4abb75f.jpg)



图5.22 树与二叉树的对应关系


树转换为二叉树的画法：

1）在兄弟结点之间加一连线；

2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；

3）以树根为轴心，顺时针旋转  $45^{\circ}$

# 2. 森林转换为二叉树

# 命题追踪 森林和二叉树的转换及相关性质的推理（2014）

将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，森林中各棵树的根也可视为兄弟关系，将第二棵树对应的二叉树当作第一棵二叉树根的右子树……以此类推，就可以将森林转换为二叉树。

森林转换为二叉树的画法：

1）将森林中的每棵树转换成相应的二叉树；

2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；

3）以第一棵树的根为轴心顺时针旋转  $45^{\circ}$ 。

或者先在森林中每棵树的根之间加一根连线，然后再采用树转换为二叉树的方法。

# 3. 二叉树转换为森林

# 命题追踪 由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换

成树，就得到了原森林，如图5.23所示。二叉树转换为树或森林是唯一的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0380ca1a371e6a27ad2bd437e5e5c50e76825c4fab773c80fc1ab8cbdd0b3e0f.jpg)



图5.23 森林与二叉树的对应关系


# 5.4.3 树和森林的遍历

# 1. 树的遍历

# 命题追踪

# 树与二叉树遍历方法的对应关系（2019）

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式：

1）先根遍历。若树非空，则按如下规则遍历：

- 先访问根结点。

- 再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。

其遍历序列与这棵树相应二叉树的先序序列相同。

2）后根遍历。若树非空，则按如下规则遍历：

- 先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则。

- 再访问根结点。

其遍历序列与这棵树相应二叉树的中序序列相同。

图5.22的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。

另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。

# 2. 森林的遍历

按照森林和树相互递归的定义，可得到森林的两种遍历方法。

1）先序遍历森林。若森林为非空，则按如下规则遍历：

- 访问森林中第一棵树的根结点。

- 先序遍历第一棵树中根结点的子树森林。

- 先序遍历除去第一棵树之后剩余的树构成的森林。

2）中序遍历森林。森林为非空时，按如下规则遍历：

- 中序遍历森林中第一棵树的根结点的子树森林。

- 访问第一棵树的根结点。

- 中序遍历除去第一棵树之后剩余的树构成的森林。

图5.23的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。

# 命题追踪

# 森林与二叉树遍历方法的对应关系（2020）

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，

可知森林的先序和中序遍历即其对应二叉树的先序和中序遍历。

树和森林的遍历与二叉树的遍历关系见表5.1。


表 5.1 树和森林的遍历与二叉树遍历的对应关系


<table><tr><td>树</td><td>森林</td><td>二叉树</td></tr><tr><td>先根遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr><td>后根遍历</td><td>中序遍历</td><td>中序遍历</td></tr></table>

# 注意

森林的遍历方法的命名按照严蔚敏老师的经典教材。有些教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问。

# 5.4.4 本节试题精选

# 一、单项选择题

01. 下列关于树的说法中，正确的是（）。

I. 对于有  $n$  个结点的二叉树，其高度为  $\log_2 n$

II. 完全二叉树中，若一个结点没有左孩子，则它必是叶结点

III. 高度为  $h(h > 0)$  的完全二叉树对应的森林所含的树的个数一定是  $h$

IV.一棵树中的叶子数一定等于与其对应的二叉树的叶子数

A. I 和 III

B. IV

C. I 和 II

D. II

02. 利用二叉链表存储森林时，根结点的右指针是（）。

A. 指向最左兄弟

B. 指向最右兄弟

C. 一定为空

D. 不一定为空

03. 设森林  $F$  中有 3 棵树，第 1、2、3 棵树的结点个数分别为  $M_{1}, M_{2}$  和  $M_{3}$ ，与森林  $F$  对应的二叉树根结点的右子树上的结点个数是（）。

A.  $M_{1}$

B.  $M_{1} + M_{2}$

C.  $M_{3}$

D.  $M_{2} + M_{3}$

04. 设森林  $F$  中有 4 棵树，第 1、2、3、4 棵树的结点数分别为  $a$ 、 $b$ 、 $c$  和  $d$ ，与森林  $F$  对应的二叉树的根结点的左子树上的结点数是（）。

A.  $a$

B.  $b + c + d$

C.  $a - 1$

D.  $a + b + c$

05. 设森林  $F$  对应的二叉树为  $B$ , 它有  $m$  个结点,  $B$  的根为  $p$ ,  $p$  的右子树结点数为  $n$ , 森林  $F$  中第一棵树的结点数是 ( )。

A.  $m - n$

B.  $m - n - 1$

C.  $n + 1$

D. 条件不足，无法确定

06. 设森林  $F$  对应的二叉树是一棵具有 16 个结点的完全二叉树，则森林  $F$  中树的数目和结点最多的树的结点数分别是（）。

A. 2和8

B. 2和9

C. 4和8

D. 4和9

07. 森林  $T = (T_{1}, T_{2}, \dots, T_{m})$  转化为二叉树BT的过程为：若  $m = 0$ ，则BT为空，若  $m \neq 0$ ，则（）。

A. 将中间子树  $T_{\mathrm{mid}}$  （  $\mathrm{mid} = (1 + m) / 2$  ）的根作为BT的根；将  $(T_{1}, T_{2}, \dots, T_{\mathrm{mid}-1})$  转换为BT的左子树；将  $(T_{\mathrm{mid}+1}, \dots, T_{m})$  转换为BT的右子树

B. 将子树  $T_{1}$  的根作为BT的根; 将  $T_{1}$  的子树森林转换成BT的左子树; 将  $(T_{2}, T_{3}, \dots, T_{m})$  转换成BT的右子树

C. 将子树  $T_{1}$  的根作为 BT 的根；将  $T_{1}$  的左子树森林转换成 BT 的左子树；将  $T_{1}$  的右子树森林转换为 BT 的右子树；其他以此类推

D. 将森林  $T$  的根作为 BT 的根；将  $(T_{1}, T_{2}, \dots, T_{m})$  转化为该根下的结点，得到一棵树，然后将这棵树再转化为二叉树 BT

08. 设  $F$  是一个森林， $B$  是由  $F$  变换来的二叉树。若  $F$  中有  $n$  个非终端结点，则  $B$  中右指针域为空的结点有（）个。

A.  $n - 1$

B.  $n$

C.  $n + 1$

D.  $n + 2$

09. 设某树的孩子兄弟链表示中共有 6 个空的左指针域、7 个空的右指针域，包括 5 个结点的左、右指针域都为空，则该树中叶结点的个数是（）。

A. 7

B. 6

C. 5

D. 不能确定

10. 若  $T_{1}$  是由有序树  $T$  转换而来的二叉树，则  $T$  中结点的后根序列就是  $T_{1}$  中结点的（）序列。

A. 先序

B. 中序

C. 后序

D. 层序

11. 某二叉树结点的中序序列为  $BDAECF$ ，后序序列为  $DBEFCA$ ，则该二叉树对应的森林包括（）棵树。

A. 1

B. 2

C. 3

D. 4

12. 设  $X$  是树  $T$  中的一个非根结点， $B$  是  $T$  所对应的二叉树。在  $B$  中， $X$  是其双亲结点的右孩子，下列结论中正确的是（）。

A. 在树  $T$  中,  $X$  是其双亲结点的第一个孩子

B. 在树  $T$  中,  $X$  一定无右边兄弟

C. 在树  $T$  中,  $X$  一定是叶结点

D. 在树  $T$  中,  $X$  一定有左边兄弟

13. 下图是一棵逻辑上的树  $T$  ，则在关于该树的存储结构的叙述中，错误的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fff34f9027c48f81386df75221b6523a9685663b119896ad3021326d8d6fccdf.jpg)


A. 若  $T$  采用双亲表示法，则有9个指向双亲的指针

B. 若  $T$  采用孩子表示法, 则在  $T$  中查找某个结点的孩子比双亲表示法更方便

C. 若  $T$  采用孩子兄弟表示法，则在  $T$  中查找某个结点的双亲的时间复杂度为  $O(1)$

D. 双亲表示法是顺序存储结构，孩子表示法和孩子兄弟表示法是链式存储结构

14. 在森林的二叉树表示中，结点  $M$  和结点  $N$  是同一父结点的左儿子和右儿子，则在该森林中（）。

A.  $M$  和  $N$  有同一双亲

B.  $M$  和  $N$  可能无公共祖先

C.  $M$  是  $N$  的儿子

D.  $M$  是  $N$  的左兄弟

15.【2009统考真题】将森林转换为对应的二叉树，若在二叉树中，结点  $u$  是结点  $v$  的父结点的父结点，则在原来的森林中， $u$  和  $v$  可能具有的关系是（）。

I. 父子关系 II. 兄弟关系 III.  $u$  的父结点与  $\nu$  的父结点是兄弟关系

A. 只有 II

B. I和II

C. I 和 III

D. I、II 和 III

16.【2011统考真题】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是（）。

A. 115

B. 116

C. 1895

D. 1896

17.【2014统考真题】将森林  $F$  转换为对应的二叉树  $T$  ，  $F$  中叶结点的个数等于（）。

A.  $T$  中叶结点的个数

B.  $T$  中度为 1 的结点个数

C.  $T$  中左孩子指针为空的结点个数

D.  $T$  中右孩子指针为空的结点个数

18.【2019统考真题】若将一棵树  $T$  转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与  $T$  的后根遍历序列相同的是（）。

A. 先序遍历

B. 中序遍历

C. 后序遍历

D. 按层遍历

19.【2020统考真题】已知森林  $F$  及与之对应的二叉树  $T$  ，若  $F$  的先根遍历序列是  $a,b,c,d,e,f$  ，后根遍历序列是  $b,a,d,f,e,c$  ，则  $T$  的后序遍历序列是（）。

A.  $b, a, d, f, e, c$

B.  $b, d, f, e, c, a$

C.  $b, f, e, d, c, a$

D.  $f, e, d, c, b, a$

20.【2021统考真题】某森林  $F$  对应的二叉树为  $T$  ，若  $T$  的先序遍历序列是  $a, b, d, c, e, g, f,$  中序遍历序列是  $b, d, a, e, g, c, f$  ，则  $F$  中树的棵数是（）。

A. 1

B. 2

C. 3

D. 4

# 二、综合应用题

01. 给定一棵树的先根遍历序列和后根遍历序列，能否唯一确定一棵树？若能，请举例说明；若不能，请给出反例。

02. 将下面一个由3棵树组成的森林转换为二叉树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/be56cf7bce7b4996195c1779b84a09379bde18eaad8a5cec53f9166c7c521ecb.jpg)


03. 已知某二叉树的先序序列和中序序列分别为ABDEHCFIMGJKL和DBHEAIMFCGKLJ，请画出这棵二叉树，并画出二叉树对应的森林。

04. 编程求以孩子兄弟表示法存储的森林的叶结点数。

05. 以孩子兄弟链表为存储结构，请设计递归算法求树的深度。

# 5.4.5 答案与解析

# 一、单项选择题

01. D

若  $n$  个结点的二叉树是一棵单支树，则其高度为  $n$  。完全二叉树中最多存在一个度为1的结点且只有左孩子，若不存在左孩子，则一定也不存在右孩子，因此必是叶结点，选项II正确。只有满二叉树才具有性质III，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e17c5f779ffab37fdf19bf1c0baf036aab2a9d1f038797f3bb37f6fb036969c9.jpg)



(a) 满二叉树转化为对应的森林


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/147645593426432d4c1ddc71a808d6962afd00e7740e7357011c3a9ce8b855ac.jpg)



(b) 非满二叉树转化为对应的森林


在树转换为二叉树时，若有几个叶结点具有共同的双亲，则转换成二叉树后只有一个叶结点（最右边的叶结点），如下图所示，选项IV错误。注意，若树中的任意两个叶结点都不存在相同

的双亲，则树中的叶子数才有可能与其对应的二叉树中的叶子数相等。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8f30018364650ee14fc33c48950e27e7b0e6861dcbfc362d2bcc7eb97ebed316.jpg)


02. D

森林与二叉树具有对应关系，因此，我们存储森林时应先将森林转换成二叉树，转换的方法就是“左孩子右兄弟”，与树不同的是，若存在第二棵树，则二叉链表的根结点的右指针指向的是森林中的第二棵树的根结点。若此森林只有一棵树，则根结点的右指针为空。因此，右指针可能为空也可能不为空。

03. D

与树转换为二叉树不同，森林中的每棵树是独立的，因此先要将每棵树的根结点全部视为兄弟结点的关系。森林转换为二叉树后，树2作为树1的根结点的右子树，树3作为树2的根结点的右子树，因此森林  $F$  对应的二叉树根结点的右子树上的结点个数是  $M_2 + M_3$

04.C

森林转换为二叉树后，二叉树的根结点为第1棵树的根结点，二叉树的根结点的左子树包含第1棵树的所有孩子，因此森林  $F$  对应的二叉树的根结点的左子树上的结点数是  $a - 1$ 。

05. A

森林转换成二叉树时采用孩子兄弟表示法，根结点及其左子树为森林中的第一棵树。右子树为其他剩余的树。所以，第一棵树的结点个数为  $m - n$  。

06. D

森林转换为二叉树后，二叉树的根结点及其左子树由第1棵树转换得到，二叉树的根结点的右子树由剩余的森林转换得到，以此类推，可以划分出第2,3,…棵树的结点。具有16个结点的完全二叉树的形态如下图所示，沿二叉树的根结点往右下遍历，共有4个结点，可知森林中有4棵树，其中第1棵树的结点数最多，有9个。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d3a271943fc548b8af12501a7bc4108199f630f4fafab971b713893ab404fb13.jpg)


07. B

将森林中每棵树的根结点视为兄弟结点的关系，再按照“左孩子右兄弟”的规则来进行转化。

08.C

根据森林与二叉树转换规则“左孩子右兄弟”。二叉树  $B$  中右指针域为空代表该结点没有兄弟结点。森林中每棵树的根结点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根结点的右指针为空。另外，每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空，所以树  $B$  中右指针域为空的结点有  $n + 1$  个。

09.B

在树的孩子兄弟表示法中，若一个结点没有孩子（叶结点），则表现为该结点的左指针域为

空，因此本题答案为“6”。至于“5个结点的左、右指针域都为空”，表示树中有5个结点既没有孩子又没有右兄弟，约束条件比题中的“求叶结点的个数”要求更严格。

# 10. B

有序树  $T$  转换成二叉树  $T_{1}$  时， $T$  的后根序列是对应  $T_{1}$  的中序序列还是后序序列呢（显然树的后根序列不可能对应二叉树的先序序列和层序序列）？看下图所示的例子，在树  $T$  中，叶结点  $B$  应最先访问，在  $T_{1}$  中， $B$  的右兄弟  $C$  转换为它的右孩子，若对应  $T_{1}$  的后序序列，则  $C$  应在  $B$  的前面访问，所以  $T$  的后根序列不可能对应  $T_{1}$  的后序序列。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6a7776f80bd23cb7de791a3be53fe5ef14476b25e3f19251e8fb5351508635a0.jpg)


# 11. C

根据二叉树的前序序列和中序序列可以确定一棵二叉树。根据后序序列， $A$  是二叉树的根结点。根据中序序列，二叉树的形态如下图(a)所示。对于  $A$  的左子树，根据后序序列， $B$  比  $D$  后被访问，因此  $B$  必为  $D$  的父结点，又根据中序序列， $D$  是  $B$  的右儿子。对于  $A$  的右子树，同理可确定结点  $E$ 、 $C$ 、 $F$  的关系。此二叉树的形态如下图(b)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2bb901e6e800c593c8488cb64b8d41d995e08f23635ca2d93e68aebdd1cb6c51.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/480f76ae26bc1231dcab473d4a4047f5d4f4c8cbb2fdd987b9b4db278907a6d5.jpg)



(b)


再根据二叉树与森林的对应关系，森林中树的棵数即其对应二叉树（向右上旋转  $45^{\circ}$  后）的根结点  $A$  及其右兄弟数，或解释为：对应二叉树从根结点  $A$  开始不断往右孩子访问，所访问到的结点数。可知此森林中有3棵树，根结点分别为  $A, C$  和  $F$ 。

# 12. D

在二叉树  $B$  中， $X$  是其双亲的右孩子，因此在树  $T$  中， $X$  必是其双亲结点的右兄弟，换句话说， $X$  在树中必有左兄弟。

# 13. C

若  $T$  采用双亲表示法存储，则除根结点外，其余每个结点都有指向其双亲的指针， $T$  共有10个结点，于是有9个指向双亲的指针，选项A正确。若  $T$  采用孩子表示法存储，则每个结点的孩子被视为一个线性表，且以单链表作为存储结构，只要遍历该单链表，就能找到某个结点的所有孩子，而双亲表示法要寻找某个结点的孩子，就必须遍历整棵树，选项B正确。若  $T$  采用孩子兄弟表示法，则在  $T$  中查找某个结点的双亲也必须遍历整棵树，时间复杂度为  $O(n)$ ，选项C错误。选项D显然正确。

# 14. B

在森林的二叉树表示中，当  $M$  和  $N$  的父结点是二叉树根结点时， $M$  和  $N$  在不同的树上。因此  $M$  和  $N$  可能无公共祖先。

# 15. B

森林与二叉树的转换规则为“左孩子右兄弟”。在最后生成的二叉树中，父子关系在对应森林关系中可能是兄弟关系或者原本就是父子关系。

情形I：若结点  $v$  是结点  $u$  的第二个孩子结点，转换时，结点  $v$  就变成结点  $u$  第一个孩子的右孩子，符合要求。情形II：结点  $u$  和  $v$  是兄弟结点的关系，但二者之中还有一个兄弟结点  $k$ ，则转换后结点  $v$  就变为结点  $k$  的右孩子，而结点  $k$  则是结点  $u$  的右孩子，符合要求。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/55ecc0e45761a1df5fa3a1ee1d3bffd7c7de914c1d66fe77827b9da74daa6ffd.jpg)



图I


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4a81c069f024b9541fa6da8b58fc716d38546489adf134df8718103ec0f07a62.jpg)



图Ⅱ


情形III：若结点  $u$  的父结点与  $v$  的父结点是兄弟关系，则转换后，结点  $u$  和  $v$  分别在两者最左父结点的两棵子树中，不可能出现在同一条路径中。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8dd113a753005565ddb4d389411c3781a117d89003907e31f28cc00fbda6af78.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ea094605e8876ea2921bd58417ee396ebbd1560e5c36914e757d02e809092fb6.jpg)



图Ⅲ


【另解】由题意可知  $u$  是  $\nu$  的父结点的父结点，如下图所示，有四种情况：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/00a21c00706e48464ca5167c87c4915d05244324928b670dbda26a72bb5c58d3.jpg)



(1)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d4649d8191fd040f648e8865a653c7ed46f0a3a11c3549804947dca44ebcd6b3.jpg)



(2)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1bebc2b8bec5570003368fa512d4929604966c153dd0881b61265baf2e4467e5.jpg)



(3)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b88a33098a977d05c74131cbd218c8553224599f3bf365000db73183883d6227.jpg)



(4)


根据树与二叉树的转换规则，将这四种情况转换成树中结点的关系。（1）在原来的树中  $u$  是  $v$  的父结点的父结点；（2）在树中  $u$  是  $v$  的父结点；（3）在树中  $u$  是  $v$  的父结点的兄弟；（4）在树中  $u$  与  $v$  是兄弟关系。由此可知选项I和II正确。

# 16. D

树转换为二叉树时，树的每个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数  $=$  分支结点数  $+1 = 2011 - 116 + 1 = 1896$

通常本题应采用特殊法求解，设题意中的树是如下图所示的结构，则对应的二叉树中仅有前115个叶结点有右孩子，所以无右孩子的结点个数  $= 2011 - 115 = 1896$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1a43cf12d7a666a21b5563273c2be66ae39ea267d9b5416294ab02c2d9a29d5f.jpg)


# 17. C

将森林转化为二叉树相当于用孩子兄弟表示法来表示森林。在变化过程中，原森林某结点的第一个孩子结点作为它的左子树，它的兄弟作为它的右子树。森林中的叶结点没有孩子结点，转化为二叉树时，该结点就没有左结点，因此  $F$  中叶结点的个数等于  $T$  中左孩子指针为空的结点个数。此题还可通过一些特例来排除选项A、B和D。

# 18. B

后根遍历树可分为两步：①从左到右访问双亲结点的每个孩子（转化为二叉树后，先访问根结点，再访问右子树）；②访问完所有孩子后再访问它们的双亲结点（转化为二叉树后，先访问左子树，再访问根结点），因此树的后根遍历序列与其相应二叉树的中序遍历序列相同。对于此类题，采用特殊值法求解通常会更便捷，左下图树  $T$  转换为二叉树BT的过程如下图所示，树的后序遍历序列显然和其相应二叉树的中序遍历序列相同，均为5,6,7,2,3,4,1。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3a597e973378e5a06b89793989572b782ecc0f32b806c066541a555e48765849.jpg)


# 19. C

森林  $F$  的先根遍历序列对应于其二叉树  $T$  的先序遍历序列，森林  $F$  的后根遍历序列对应于其二叉树  $T$  的中序遍历序列。即  $T$  的先序遍历序列为  $a, b, c, d, e, f$  ，中序遍历序列为  $b, a, d, f, e, c$  。根据二叉树  $T$  的先序序列和中序序列可以唯一确定它的结构，构造过程如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e18060631982516d12039a1b484fa51b2fc8ec7e1d88436467c1dd611cb08c19.jpg)


可以得到二叉树  $T$  的后序序列为  $b, f, e, d, c, a$ 。

# 20. C

由二叉树  $T$  的先序序列和中序序列可以构造出  $T$  ，如下图所示。由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以  $T$  中的结点  $a$  、  $c$  、  $f$  为  $F$  中树的根结点，森林  $F$  中有3棵树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/107a7815dbab59503a893d464cb6abd622c9dfb6db0443a07de61bafc8b0824b.jpg)


# 二、综合应用题

# 01.【解答】

一棵树的先根遍历结果与其对应二叉树的先序遍历结果相同，树的后根遍历结果与其对应二叉树表示的中序遍历结果相同。二叉树的先序序列和中序序列能够唯一地确定这棵二叉树，因此，根据题目给出的条件，利用树的先根遍历序列和后根遍历序列能够唯一地确定这棵树。例如，对于下图所示的树，对应二叉树的先序序列为1,2,3,4,5,6,8,7，中序序列为3,4,8,6,7,5,2,1。原树的先根遍历序列为1,2,3,4,5,6,8,7，后根遍历序列为3,4,8,6,7,5,2,1。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b6124d1803f229dc41e3bb90d4d06847cb02b26940df2bd0744ab763cc81307f.jpg)


# 注意

树的先根遍历、后根遍历与对应二叉树的前序遍历、中序遍历对应。

# 02.【解答】

根据树与二叉树“左孩子右兄弟”的转换规则，将森林转换为二叉树的过程如下：①将每棵树的根结点也视为兄弟关系，在兄弟结点之间加一连线。②对每个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉。③以树根为轴心，顺时针旋转  $45^{\circ}$  。结果如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6dafaaad323fadda802d6177f788aa648fb082086977335c989df1cefa5774df.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a0f91b02379898d856fe56d2d6e6bdf1d5a6f184164f661e07f5800a94881251.jpg)


# 03.【解答】

知道二叉树的先序和中序遍历后，可以唯一确定这棵树的结构。然后把二叉树转换到树和森林的方式是，若结点  $x$  是双亲  $y$  的左孩子，则把  $x$  的右孩子、右孩子的右孩子……都与  $y$  用连线连起来，最后去掉所有双亲到右孩子的连线。

最后得到的二叉树及对应的森林如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/32ff0b46ed174fbf0891d82163335e4e63f0693be8619cfe6dc6a6132299505c.jpg)


# 04.【解答】

当森林（树）以孩子兄弟表示法存储时，若结点没有孩子（fch=NULL），则它必是叶子，总的叶结点个数是孩子子树（fch）上的叶子数和兄弟子树（nsib）上的叶结点个数之和。

算法代码如下：

```c
typedef struct node  
{ElemType data; //数据域struct node \*fch,\*nsib; //孩子与兄弟域\*Tree;int Leaves(Tree t){//计算以孩子兄弟表示法存储的森林的叶子数if(t==NULL)return 0; //树空返回0if(t->fch==NULL) //若结点无孩子，则该结点必是叶子return 1+Leaves(t->nsib); //返回叶结点和其兄弟子树中的叶结点数else //孩子子树和兄弟子树中叶子数之和return Leaves(t->fch)+Leaves(t->nsib);  
}
```

# 05.【解答】

由孩子兄弟链表表示的树，求高度的算法思想：采用递归算法，若树为空，高度为零；否则，高度为第一子女树高度加1和兄弟子树高度的大者。其非递归算法使用队列，逐层遍历树，取得树的高度。算法代码如下：

```c
int Height(CSTree bt){  
//递归求以孩子兄弟链表示的树的深度  
int hc,hs;  
if (bt==NULL)  
return 0;  
else{//否则，高度取子女高度+1和兄弟子树高度的大者  
hc=Height(bt->firstchild); //第一子女树高  
hs=Height(bt->nextSibling); //兄弟树高  
if (hc+1>hs)  
return hc+1;  
else  
return hs;  
}
```

# 5.5 树与二叉树的应用

# 5.5.1 哈夫曼树和哈夫曼编码

# 1. 哈夫曼树的定义

在介绍哈夫曼树之前，先介绍几个相关的概念：

在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。

从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。

树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为

$$
\mathrm {W P L} = \sum_ {i = 1} ^ {n} w _ {i} l _ {i}
$$

式中，  $w_{i}$  是第  $i$  个叶结点所带的权值，  $l_{i}$  是该叶结点到根结点的路径长度。

在含有  $n$  个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树。例如，图5.24中的3棵二叉树都有4个叶结点  $a, b, c, d$  ，分别带权7,5,2,4，它们的带权路径长度分别为

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ea2642f0b0e19073df7da19f9f6377f804e5b89a9ceb578c2b31d17826c71fa6.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/12b4e01c577534989d309cc0da2e4d639ad862f59980089496e93729d3caf2c3.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dba3d4aa65d36ffce9c70350f8990c7e56106135da2d5915f536f2a60dced51d.jpg)



(c)



图5.24 具有不同带权长度的二叉树


(a)  $\mathrm{WPL} = 7\times 2 + 5\times 2 + 2\times 2 + 4\times 2 = 36$

(b)  $\mathrm{WPL} = 4\times 2 + 7\times 3 + 5\times 3 + 2\times 1 = 46$

(c)  $\mathrm{WPL} = 7\times 1 + 5\times 2 + 2\times 3 + 4\times 3 = 35$

其中，图5.24(c)树的WPL最小。可以验证，它恰好为哈夫曼树。

# 2. 哈夫曼树的构造

给定  $n$  个权值分别为  $w_{1}, w_{2}, \dots, w_{n}$  的结点，构造哈夫曼树的算法描述如下：

1）将这  $n$  个结点分别作为  $n$  棵仅含一个结点的二叉树，构成森林  $F$ 。

# 命题追踪 分析哈夫曼树的路径上权值序列的合法性（2010）

2）构造一个新结点，从  $F$  中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。公众号：小兔网盘 免费分享无水印PDF

3）从  $F$  中删除刚才选出的两棵树，同时将新得到的树加入  $F$  中。

4）重复步骤2）和3)，直至  $F$  中只剩下一棵树为止。

# 命题追踪 哈夫曼树的性质（2010、2019）

从上述构造过程中可以看出哈夫曼树具有如下特点：

1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。

2）构造过程中共新建了  $n - 1$  个结点（双分支结点），因此哈夫曼树的结点总数为  $2n - 1$  。

3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。例如，权值{7,5,2,4}的哈夫曼树的构造过程如图5.25所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4287f31acd886ab88512041416ad285222deaf84f89c32ddb5843314076d21d5.jpg)



(a)



(b)



(c)



(d)



图5.25 哈夫曼树的构造过程


# 3. 哈夫曼编码

在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。

# 命题追踪 根据哈夫曼编码对编码序列进行译码（2017）

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B和C对应的编码0,10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码串执行同样的解码操作。例如，码串0010110可被唯一地翻译为A,A,B和C。另举反例：若再将字符D的编码设计为11，此时11是110的前缀，则上述码串的后三位就无法唯一翻译。

# 命题追踪 哈夫曼树的构造及相关的分析（2012、2018、2021、2023）

# 命题追踪 前缀编码的分析及应用（2014、2020）

可以利用二叉树来设计二进制前缀编码。假设为A,B,C,D四个字符设计前缀编码，可以用图5.26所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到的必为前缀编码。由图5.26得到字符A,B,C,D的前缀编码分别为0,10,110,111。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4cd68541de0d1be246c1ea9a59b11c633f147e4276aacd856de51a27c9132118.jpg)



图5.26 前缀编码示例


# 命题追踪 哈夫曼编码和定长编码的差异（2022）

哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.27所示为一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/55d2bd1edb5f491ff186989c114d0b46b370a861399fb89fe218fea468e20915.jpg)



图5.27 由哈夫曼树构造哈夫曼编码


这棵哈夫曼树的WPL为

$$
\mathrm {W P L} = 1 \times 4 5 + 3 \times (1 3 + 1 2 + 1 6) + 4 \times (5 + 9) = 2 2 4
$$

此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位，因此哈夫曼编码共压缩了  $25\%$  的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。

# 注意

左分支和右分支究竟是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。

# 5.5.2 井查集

# 1. 并查集的概念

并查集是一种简单的集合表示，它支持以下3种操作：

1）Initial(S)：将集合S中的每个元素都初始化为只有一个单元素的子集合。

2）Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并。

3）Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的根结点。

# 2. 并查集的存储结构

通常用树的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。

例如，若设有一个全集合为  $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ ，初始化时每个元素自成一个单元素子集合，每个子集合的数组值为-1，如图5.28所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9232d9bda3fcd88a9c6df75cda56ce5a6875559de63c75c50753d8295f79a81e.jpg)



(a) 全集合  $S$  初始化时形成一个森林


$$
\begin{array}{c c c c c c c c c c} 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\ | - 1 & | - 1 & | - 1 & | - 1 & | - 1 & | - 1 & | - 1 & | - 1 & | - 1 \end{array}
$$


(b) 初始化时形成的(森林)双亲表示



图5.28 并查集的初始化


经过一段时间的计算后，这些子集合合并为3个更大的子集合，即  $S_{1} = \{0,6,7,8\}$  ，  $S_{2} = \{1,4,9\}$ $S_{3} = \{2,3,5\}$  ，此时并查集的树形和存储结构如图5.29所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dd7d89993e33151b65c03b8b757bb2c0ca4219693e839a9f6ba96c37bd927705.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6fea838e1d8bcd1c28cb80167d40bad561ed3beff894288f36ad6870853b4bbf.jpg)



(a) 集合的树形表示


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/232f3ae6c3334857a9dace8044edc5b43046464d9f450c62bb8a17b32d602336.jpg)


$$
\begin{array}{c c c c c c c c c c c} 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\ \vert - 4 & \vert - 3 & \vert - 3 & \vert 2 & \vert 1 & \vert 2 & \vert 0 & \vert 0 & \vert 0 & \vert 1 \end{array}
$$


(b) 集合  $S_{1}$  、  $S_{2}$  和  $S_{3}$  的(森林)双亲表示



图5.29 用树表示并查集


为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。因此，  $S_{1} \cup S_{2}$  可以具有如图5.30所示的表示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6536de2ed4588513d7a17ad2229220e5a118b11e7482b2e12b2a10682bae0bca.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/20de3dcbed6ad957c9e3cb5bfc43ac33bcea604712e92b896275c244dde8c38c.jpg)



图5.30  $S_{1} \cup S_{2}$  可能的表示方法


在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。其中SIZE是最大元素的个数。

# 3. 并查集的基本实现

并查集的结构定义如下：

```txt
define SIZE 100 int UFSets[SIZE]; //集合元素数组（双亲指针数组）
```

下面是并查集主要运算的实现。

（1）并查集的初始化操作

```txt
void Initial(int S[]) { //s即并查集for(int  $\mathrm{i} = 0$  ;i<SIZE;i++) //每个自成单元素集合S[i]=-1;  
}
```

（2）并查集的Find操作

在并查集S中查找并返回包含元素  $\mathbf{x}$  的树的根。

```c
int Find(int S[], int x) {
    while (S[x] >= 0)
        x = S[x];
    return x;
}
```

判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。

（3）并查集的 Union 操作

求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个元素的根，再令一棵子集树的根指向另一棵子集树的根。

```txt
void Union(int S[],int Root1,int Root2){if(Root1  $\equiv$  =Root2) return; //要求Root1与Root2是不同的集合S[Root2]  $=$  Root1; //将根Root2连接到另一根Root1下面}
```

Find 操作和 Union 操作的时间复杂度分别为  $O(d)$  和  $O(1)$ ，其中  $d$  为树的深度。

# 4. 并查集实现的优化

在极端情况下， $n$  个元素构成的集合树的深度为  $n$ ，则 Find 操作的最坏时间复杂度为  $O(n)$ 。改进的办法是：在做 Union 操作之前，首先判别子集中的成员数量，然后令成员少的根指向成员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。

（1）改进的 Union 操作

```txt
void Union(int S[],int Root1,int Root2){if(Root1  $\equiv$  Root2) return;if(S[Root2]  $\rightharpoondown$  S[Root1]) { //Root2结点数更少S[Root1]  $+ = \mathrm{S}$  [Root2]; //累加集合树的结点总数S[Root2]=Root1; //小树合并到大树}else{ //Root1结点数更少S[Root2]  $+ = \mathrm{S}$  [Root1]; //累加结点总数S[Root1]=Root2; //小树合并到大树}
```

采用这种方法构造得到的集合树，其深度不超过  $\lfloor \log_2n\rfloor +1$

随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还可进一步对上述Find操作进行优化，当所查元素  $x$  不在树的第二层时，在算法中增加一个压缩

路径的功能，即将从根到元素  $\times$  路径上的所有元素都变成根的孩子。

（2）改进的Find操作

```txt
int Find(int S[],int x){ int root=x; while(s[root]  $\rightharpoondown$  0) //循环找到根 root=s[root]; while(x!  $=$  root）{//压缩路径 int t=S[x]; //t指向x的父结点 S[x]=root; //x直接挂到根结点下面 x=t; } return root; //返回根结点编号
```

通过 Find 操作的压缩路径优化后，可使集合树的深度不超过  $O(\alpha(n))$ ，其中  $\alpha(n)$  是一个增长极其缓慢的函数，对于常见的正整数  $n$ ，通常  $\alpha(n) \leqslant 4$ 。

并查集应用的相关举例见本书配套课程。

# 5.5.3 本节试题精选

# 一、单项选择题

01. 在有  $n$  个叶结点的哈夫曼树中，非叶结点的总数是（）。

A.  $n - 1$

B.  $n$

C.  ${2n} - 1$

D.  $2 n$

02. 给定整数集合  $\{3, 5, 6, 9, 12\}$ ，与之对应的哈夫曼树是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/44bd20ae9ac1878ce33022712f5f58ca551a4b55122def109f5ad7f4549a1194.jpg)



A.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/49fa205ee172855d7543c2b66f2bab409b3b3e01cabb3e0a3a70646b79fcb0bc.jpg)



B.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f193aae4b8ad96ddbb38a6710676fba61107a245813631332382a2c04ebf1c22.jpg)



C.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a34f1e5997cdabc748628f86fce2e3fecf3304ed476845e8c299a603d330df3e.jpg)



D.


03. 下列编码中，（）不是前缀码。

A.  $\{00, 01, 10, 11\}$

B.  $\{0,1,00,11\}$

C.  $\{0, 10, 110, 111\}$

D.  $\{10, 110, 1110, 1111\}$

04. 设哈夫曼编码的长度不超过 4，若已对两个字符编码为 1 和 01，则还最多可对（）个字符编码。

A. 2

B. 3

C. 4

D. 5

05.一棵哈夫曼树共有215个结点，对其进行哈夫曼编码，共能得到（）个不同的码字。

A. 107

B. 108

C. 214

D. 215

06. 设某哈夫曼树有 5 个叶结点，则该哈夫曼树的高度最高可以是（）。

A. 3

B. 4

C. 5

D. 6

07. 以下对于哈夫曼树的说法中，错误的是（）

A. 用一组权值构造出的哈夫曼树可能不唯一, 但带权路径长度唯一

B. 哈夫曼树具有最小的带权路径长度

C. 哈夫曼树中没有度为 1 的结点

D. 哈夫曼树中除了度为 1 的结点, 还有度为 2 的结点和叶结点

08. 下列关于哈夫曼树的说法中，错误的是（）。

I. 哈夫曼树的总结点数不能是偶数

II. 哈夫曼树中度为 1 的结点数等于度为 2 和 0 的结点数之差

III. 哈夫曼树的带权路径长度等于其所有分支结点的权值之和

A. 仅III

B. I 和 II

C. 仅 II

D. I、II 和 III

09. 若度为  $m$  的哈夫曼树中，叶结点个数为  $n$ ，则非叶结点的个数为（）。

A.  $n - 1$

B.  $\lfloor n / m\rfloor -1$

C.  $\lceil (n - 1) / (m - 1)\rceil$

D.  $\lceil n / (m - 1)\rceil -1$

10. 并查集的结构是一种（）。

A. 二叉链表存储的二叉树

B. 双亲表示法存储的树

C. 顺序存储的二叉树

D. 孩子表示法存储的树

11. 并查集中最核心的两个操作是：①查找，查找两个元素是否属于同一个集合；②合并，若两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假设初始长度为  $10(0\sim 9)$  的并查集，按1-2、3-4、5-6、7-8、8-9、1-8、0-5、1-9的顺序进行查找和合并操作，最终并查集共有（）个集合。

A. 1

B. 2

C. 3

D. 4

12. 下列关于并查集的说法中，正确的是（）（注，本题涉及图的考点）。

A. 并查集不能检测图中是否存在环路的问题

B. 通过路径优化后的并查集在最坏情况下的高度仍是  $O(n)$

C. Find操作返回集合中元素个数的相反数，它用来作为某个集合的标志

D. Union 操作时可根据当前集合的规模，将小集合合并到大集合中

13. 下列关于并查集的叙述中，（）是错误的（注，本题涉及图的考点）。

A. 并查集是用双亲表示法存储的树

B. 并查集可用于实现克鲁斯卡尔算法

C. 并查集可用于判断无向图的连通性

D. 在长度为  $n$  的并查集中进行查找操作的时间复杂度为  $O(\log_2 n)$

14.【2010统考真题】  $n$  （  $n\geqslant 2$  ）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（）。

A. 该树一定是一棵完全二叉树

B. 树中一定没有度为 1 的结点

C. 树中两个权值最小的结点一定是兄弟结点

D. 树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值

15.【2014统考真题】5个字符有如下4种编码方案，不是前缀编码的是（）。

A. 01,0000,0001,001,1

B. 011,000,001,010,1

C. 000,001,010,011,100

D. 0,100,110,1110,1100

16.【2015统考真题】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是（）。

A. 24, 10, 5 和 24, 10, 7

B. 24,10,5和24,12,7

C. 24, 10, 10 和 24, 14, 11

D. 24, 10, 5 和 24, 14, 6

17.【2017统考真题】已知字符集{a,b,c,d,e,f,g,h},若各字符的哈夫曼编码依次是0100,10,0000,0101,001,011,11,0001，则编码序列0100011001001011110101的译码结果是（）。

A. acgabfh

B. a d b a g b b

C. afbeagd

D. afeefgd

18.【2018统考真题】已知字符集  $\{\mathrm{a,b,c,d,e,f}\}$  ，若各字符出现的次数分别为6,3,8,2,10,4，

则对应字符集中各字符的哈夫曼编码可能是（）。

A. 00, 1011, 01, 1010, 11, 100

B. 00, 100, 110, 000, 0010, 01

C. 10, 1011, 11, 0011, 00, 010

D. 0011, 10, 11, 0010, 01, 000

19.【2019统考真题】对  $n$  个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115个结点，则  $n$  的值是（）。

A. 56

B. 57

C. 58

D. 60

20.【2021统考真题】若某二叉树有5个叶结点，其权值分别为10,12,16,21,30，则其最小的带权路径长度（WPL）是（）。

A. 89

B. 200

C. 208

D. 289

21.【2022统考真题】对任意给定的含  $n(n > 2)$  个字符的有限集  $S$  ，用二叉树表示  $S$  的哈夫曼编码集和定长编码集，分别得到二叉树  $T_{1}$  和  $T_{2}$  。下列叙述中，正确的是（）。

A.  $T_{1}$  与  $T_{2}$  的结点数相同

B.  $T_{1}$  的高度大于  $T_{2}$  的高度

C. 出现频次不同的字符在  $T_{1}$  中处于不同的层

D. 出现频次不同的字符在  $T_{2}$  中处于相同的层

22.【2023统考真题】在由6个字符组成的字符集  $S$  中，各字符出现的频次分别为3,4,5,6,8,10，为  $S$  构造的哈夫曼编码的加权平均长度为（）。

A. 2.4

B. 2.5

C. 2.67

D. 2.75

# 二、综合应用题

01. 设给定权集  $w = \{5, 7, 2, 3, 6, 8, 9\}$ ，试构造关于  $w$  的一棵哈夫曼树，并求其加权路径长度 WPL。

02.【2012统考真题】设有6个有序表A,B,C,D,E,F，分别含有10,35,40,50,60和200个数据元素，各表中的元素按升序排列。要求通过5次两两合并，将6个表最终合并为1个升序表，并使最坏情况下比较的总次数达到最小。请回答下列问题：

1）给出完整的合并过程，并求出最坏情况下比较的总次数。

2）根据你的合并过程，描述  $n$  （  $n\geq 2$  ）个不等长升序表的合并策略，并说明理由。

03.【2020统考真题】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集（字符个数  $\geq 2$ ）的不等长编码，每个字符的编码均为二进制的0、1序列，最长为  $L$  位，且具有前缀特性。请回答下列问题：

1）哪种数据结构适宜保存上述具有前缀特性的不等长编码？

2）基于你所设计的数据结构，简述从0/1串到字符串的译码过程。

3）简述判定某字符集的不等长编码是否具有前缀特性的过程。

# 5.5.4 答案与解析

# 一、单项选择题

01. A

由哈夫曼树的构造过程可知，哈夫曼树中只有度为0和2的结点。在非空二叉树中，有  $n_0 = n_2 + 1$ ，所以  $n_2 = n - 1$ 。

【另解】  $n$  个结点构造哈夫曼树需要  $n - 1$  次合并过程，每次合并新建一个分支结点，所以选择选项A。

02.C

首先，3和5构造为一棵子树，其根权值为8，然后该子树与6构造为一棵新子树，根权值为14，再后9与12构造为一棵子树，最后两棵子树共同构造为一棵哈夫曼树。

# 03. B

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。在选项B中，0是00的前缀，1是11的前缀。

# 04. C

在哈夫曼编码中，一个编码不能是任何其他编码的前缀。3位编码可能是001，对应的4位编码只能是0000和0001。3位编码也可能是000，对应的4位编码只能是0010和0011。若全采用4位编码，则可以为0000,0001,0010和0011。题中问的是最多，所以选择选项C。

【另解】若哈夫曼编码的长度只允许小于或等于4，则哈夫曼树的高度最高是5，已知一个字符编码为1，另一个字符编码是01，这说明第二层和第三层各有一个叶结点，为使得该树从第3层起能够对尽可能多的字符编码，余下的二叉树应该是满二叉树，如下图所示，底层可以有4个叶结点，最多可以再对4个字符编码。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b80062671cda8c3060bd48f13a33a71aedd7e23a0608457f9ef7f61645494d31.jpg)


# 05.B

根据上题的结论，叶结点数为  $(215 + 1) / 2 = 108$  ，所以共有108个不同的码字。

【另解】在哈夫曼树中只有度为0和2的结点，结点总数  $n = n_0 + n_2$ ，且  $n_0 = n_2 + 1$ ，由题知  $n = 215$ ， $n_0 = 108$ 。

# 06.C

在哈夫曼树的构造中，每个初始结点最终都成为叶结点，5个初始结点构造的哈夫曼树共新建4个双分支结点，4个双分支结点所构成的高度最高的哈夫曼树如下图所示，其高度是5。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/296b9e4ff7ae26ac65a102c6edf97f2457f4a2b57e55857e27bb62e590aef2f3.jpg)


# 07. D

在哈夫曼树的构造过程中，每次选根的权值最小的两棵树，一棵作为左子树，一棵作为右子树，生成新的二叉树，新的二叉树根的权值应为其左右两棵子树根结点权值的和。至于谁做左子树，谁做右子树，没有限制，所以构造的哈夫曼树是不唯一的，但其带权路径长度是最小的和唯一的。哈夫曼树只有度为0和2的结点，度为0的结点是外结点，带有权值，没有度为1的结点。

# 08. C

$n$  个初始结点构造的哈夫曼树共新建  $n - 1$  个双分支结点，因此哈夫曼树的结点总数是  $2n - 1$  是个奇数，选项I正确。哈夫曼树中没有度为1的结点，选项II错误。哈夫曼的带权路径长度有两种计算方法：①所有叶结点的带权路径长度之和；②所有分支结点的权值之和，选项III正确。

# 09.C

一棵度为  $m$  的哈夫曼树应只有度为0和  $m$  的结点，设度为  $m$  的结点有  $n_m$  个，度为0的结点有 $n_0$  个，又设结点总数为  $N$  ，  $N = n_{0} + n_{m}$  。因有  $N$  个结点的哈夫曼树有  $N - 1$  条分支，则  $mn_{m} = N - 1 =$ $n_m + n_0 - 1$  ，整理得  $(m - 1)n_{m} = n_{0} - 1$  ，  $n_m = (n_0 - 1) / (m - 1)$

# 10. B

并查集的存储结构是用双亲表示法存储的树，主要是为了方便两个重要的操作。

# 11. C

初始时， $0\sim 9$  各自成一个集合。查找1-2时，合并{1}和{2}；查找3-4时，合并{3}和{4}；查找5-6时，合并{5}和{6}；查找7-8时，合并{7}和{8}；查找8-9时，合并{7,8}和{9}；查找1-8时，合并{1,2}和{7,8,9}；查找0-5时，合并{0}和{5,6}；查找1-9时，它们属于同一个集合。最终的集合为{0,5,6}、{1,2,7,8,9}和{3,4}，因此答案选择选项C。

# 12. D

依次探测图的各条边，用并查集检查该边依附的两个顶点是否已属于同一集合（两个顶点的根结点是否相同）。若是，则说明图中存在环路，选项A错误。经过路径优化后，并查集在最坏情况下的高度远小于  $O(n)$ ，选项B错误。Find操作总返回当前根结点作为集合的标志，选项C错误。

# 13. D

在用并查集实现Kruskal算法求图的最小生成树时：判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合（判断加入这条边之后是否形成回路)，若形成回路，则继续判断下一条边；若不形成回路，则将该边和边对应的顶点加入最小生成树  $T$  ，并继续判断下一条边，直到所有顶点都已加入最小生成树  $T$  。选项B正确。用并查集判断无向图连通性的方法：遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中，处理完所有边后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中。选项C正确。未做路径优化的并查集在最坏情况下的高度为  $n$  ，此时查找操作的时间复杂度为  $O(n)$  ，时间复杂度通常指最坏情况下的时间复杂度。选项D错误。

# 14. A

哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，选项B正确。构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，选项C正确。哈夫曼树中任意一个非叶结点的权值为其左、右子树根结点的权值之和，可知，哈夫曼树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值。

# 15. D

前缀编码的定义是在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。选项D中的编码110是编码1100的前缀，违反了前缀编码的规则，所以选项D不是前缀编码。

# 16. D

在哈夫曼树中，左右孩子权值之和为父结点权值。仅以分析选项A为例：若两个10分别属于两棵不同的子树，则根的权值不等于其孩子的权值和，不符；若两个10属同棵子树，则其权值不等于其两个孩子（叶结点）的权值和，不符。选项B、C选项的排除方法相同。

# 17. D

哈夫曼编码是前缀编码，各个编码的前缀不同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为0100011001001011110101，译码结果是afeefgd。选项D正确。

# 18. A

根据各字符出现的次数构造的哈夫曼树如下图所示。由图可知，a、c和e的编码长度应该相同；a和c的第1个编码应该相同，且与e的第1个编码不同；b和d的前3个编码应该相同。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/76bc628de92b27d68dfac74a416d6a784cf6f5f07d611ae0f89d5f83f03a5908.jpg)


# 19. C

$n$  个符号构造成哈夫曼树的过程中，共新建了  $n - 1$  个结点（双分支结点），因此哈夫曼树的结点总数为  $2n - 1 = 115$  ，  $n$  的值为58。

# 20. B

对于带权值的结点，构造出哈夫曼树的带权路径长度（WPL）最小，哈夫曼树的构造过程如下图所示。求得其  $\mathrm{WPL} = (10 + 12)\times 3 + (30 + 16 + 21)\times 2 = 200$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/94cde6ef75ac79f6d17994bb628f821e7839bb0838852c60ae681a65a6c98f08.jpg)



第一步


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/41366c96461e23d95cbd7118b65f0a39b6bb58b305b21f90e0bb92b8d8847174.jpg)



第二步


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0a64992adc138f5132ac389cb5c9eddd4cedbb20054adb1e9d0f69dfdcb0de39.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0c0208ad885d483dbaba0d4581588fc1c62b3422c6117e7f382b79b4cc8c0c18.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bd866e75357307148b937172b9ca62ddd357de91af56a295b56e01943561b178.jpg)



第三步


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/52da6ce4240981089d82af3b3ffc8d331e724fe553d6506cd2e7c5e976c94717.jpg)



第四步


# 21. D

可以画一个简单的特例来证明。图1是满足条件的二叉树  $T_{1}$ ，图2是满足条件的二叉树  $T_{2}$ ，结点中有值表示这个结点是编码字符。 $T_{1}$  和  $T_{2}$  的结点数不同，选项A错误。 $T_{1}$  的高度等于  $T_{2}$  的高度，选项B错误。出现频次不同的字符在  $T_{1}$  中也可能处于相同的层，选项C错误。对于定长编码集，所有字符一定都在  $T_{2}$  中处于相同的层，而且都是叶结点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4d1857e36479a5fc9893d38ab50d84951927bd8575861426a6abed595a4aa106.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3dd893a0f0b035125335f600cb148727f8fb73a3c0972dfd09f472c0f565c1ed.jpg)



图2


# 22. B

构建哈夫曼树的过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/470cabf954d239152348a29b5352bb785307932adec76ff344b053e114476034.jpg)


对叶结点的哈夫曼编码，共有4个长度为3的叶结点、2个长度为2的叶结点，编码的加权平均长度为  $[(3 + 4 + 5 + 6)\times 3 + (8 + 10)\times 2] / (3 + 4 + 5 + 6 + 8 + 10) = 2.5$  。

# 二、综合应用题

# 01.【解答】

根据哈夫曼树的构造方法，每次从森林中选取两个根结点值最小的树合并成一棵树，将原先的两棵树作为左、右子树，且新根结点的值为左、右孩子关键字之和。构造过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/85ca47e5950e0dc558c932ed08266ee28d95cda75a6014e27c2f30d5f4cae72e.jpg)


由构造出的哈夫曼树可得  $\mathrm{WPL} = (2 + 3)\times 4 + (5 + 6 + 7)\times 3 + (8 + 9)\times 2 = 108$

# 注意

哈夫曼树并不唯一，但带权路径长度一定是相同的。

# 02.【解答】

1）最先合并的表中的元素在后续的每次合并中都会再次参与比较，因此求最小合并次数类似于求最小带权路径长度，此时可立即想到哈夫曼树。根据哈夫曼树的构造过程，每次选择表集合中长度最小的两个表进行合并。6个表的合并顺序如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bdfa1c7e04e1ce4ae480d09bf6269c93b8d1e86b24026ede21a607ccffac7f45.jpg)


根据图中的哈夫曼树，6个序列的合并过程如下：

① 在表集合  $\{10,35,40,50,60,200\}$  中，选择表A与表B合并，生成含45个元素的表AB。

② 在表集合{40, 45, 50, 60, 200}中，将表AB与表C合并，生成含85个元素的表ABC。

③ 在表集合  $\{50,60,85,200\}$  中，表D与表E合并，生成含110个元素的表DE。

④ 在表集合{85,110,200}中，表ABC与表DE合并，生成含195个元素的表ABCDE。

⑤ 当前表集合为{195,200}, 表ABCDE与表F合并, 生成含395个元素的表ABCDEF。因为合并两个长度分别为  $m$  和  $n$  的有序表, 最坏情况下需要比较  $m + n - 1$  次, 所以最坏情况下比较的总次数计算如下:

第1次合并：最多比较次数  $= 10 + 35 - 1 = 44$

第2次合并：最多比较次数  $= 40 + 45 - 1 = 84$

第3次合并：最多比较次数  $= 50 + 60 - 1 = 109$

第4次合并：最多比较次数  $= 85 + 110 - 1 = 194$

第5次合并：最多比较次数  $= 195 + 200 - 1 = 394$

比较的总次数最多为  $44 + 84 + 109 + 194 + 394 = 825$

2）各表的合并策略是：对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借助于哈夫曼树的构造思想，依次选择最短的两个表进行合并，此时可以获得最坏情况下的最佳合并效率。

# 03.【解答】

1）使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符。

2）从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。

3）二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。

依次读入每个编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下：

对每个编码，从左至右扫描C的各位，根据C的当前位（0或1）沿结点的指针（左子指针或右子指针）向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿指针移动的过程中，可能遇到三种情况：

① 若遇到了叶结点（非根），则表明不具有前缀特性，返回。

② 若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。

③ 若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。

若所有编码均通过验证，则编码具有前缀特性。

# 归纳总结

本章的内容较多，其中二叉树是极其重要的考查点。关于二叉树的有关操作，在2014年的统考中首次出现了线性表以外的算法设计题，需要引起读者的注意。

遍历是二叉树的各种操作的基础，统考时会考查遍历过程中对结点的各种其他操作，而且容易结合递归算法和利用栈或队列的非递归算法。读者需重点掌握各种遍历方法的代码书写，并学会在遍历的基础上，进行一些其他的相关操作。其中递归算法短小精悍，出现的概率较大，请读者不要掉以轻心，要做到对几种遍历方式的程序模板烂熟于心，并结合一定数量的习题，才可以在考试中快速地写出漂亮的代码。

二叉树遍历算法的递归程序：

```txt
void Track(BiTree \*p){ if(p!=NULL){ //（1） Track(p->lchild); //（2） Track(p->rchild); //（3） 1
```

访问函数visit()位于(1)、(2)、(3)的位置，分别对应于先序、中序、后序遍历。但对于具体题目来说，设计算法时要灵活应用。请读者认真练习下面的例题。

例题：设二叉树的存储结构为二叉链表，编写有关二叉树的递归算法。

1）统计二叉树中度为1的结点个数。

2）统计二叉树中度为2的结点个数。

3）统计二叉树中度为0的结点个数。

4）统计二叉树的高度。

5）统计二叉树的宽度。

6）从二叉树中删去所有叶结点。

7）计算指定结点\*p所在的层次。

8）计算二叉树中各结点中的最大元素的值。

9）交换二叉树中每个结点的两个子女。

10）以先序次序输出一颗二叉树中所有结点的数据值及结点所在的层次。

# 思维拓展

输入一个整数 data 和一棵二元树。从树的根结点开始往下访问一直到叶结点，所经过的所有结点形成一条路径。打印出路径及与 data 相等的所有路径。例如，输入整数 22 和下图所示的二元树，则打印出两条路径 10, 12 和 10, 5, 7。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/75fbff7a1e7e4717f0d8c3feaf75847be6e836548bee281b4d77b93a24ad389c.jpg)


# 注意

使用数组或栈保存访问的路径，并记录当前路径上所有元素的和sum。若当前结点为叶结点，且当前结点值与sum的和等于data，则满足条件，打印当前路径。然后递归返回到父结点，注意在递归返回之前要先减去当前结点元素的值。使用前序遍历操作的递归算法模板可以简化程序。

# 【考纲内容】

（一）图的基本概念

（二）图的存储及基本操作

邻接矩阵；邻接表；邻接多重表；十字链表

（三）图的遍历

深度优先搜索；广度优先搜索

（四）图的基本应用

最小（代价）生成树；最短路径；拓扑排序；关键路径

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ecb871f1680f66d456c212992c913f3a177c12125fbbd3758b2951a06c4b12d8.jpg)



扫·扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a4cfbb08f3af332aa212970a5f5c1f67145d1db00a2b8c7e13066bae3e29b3ef.jpg)



视频讲解


# 【复习提示】

图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。掌握图的基本概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及特性、存储结构之间的转化、基于存储结构上的各种遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。图的相关算法较多，通常只需掌握其基本思想和实现步骤，而实现代码不是重点。

# 6.1 图的基本概念

# 6.1.1 图的定义

图  $G$  由顶点集  $V$  和边集  $E$  组成，记为  $G = (V, E)$ ，其中  $V(G)$  表示图  $G$  中顶点的有限非空集； $E(G)$  表示图  $G$  中顶点之间的关系（边）集合。若  $V = \{\nu_1, \nu_2, \dots, \nu_n\}$ ，则用  $|V|$  表示图  $G$  中顶点的个数， $E = \{(u, v) | u \in V, v \in V\}$ ，用  $|E|$  表示图  $G$  中边的条数。

# 注意

线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图的顶点集  $V$  一定非空，但边集  $E$  可以为空，此时图中只有顶点而没有边。

下面是图的一些基本概念及术语。

# 1. 有向图

若  $E$  是有向边（也称弧）的有限集合，则图  $G$  为有向图。弧是顶点的有序对，记为  $\langle v, w \rangle$ ，其中  $v, w$  是顶点， $v$  称为弧尾， $w$  称为弧头， $\langle v, w \rangle$  称为从  $v$  到  $w$  的弧，也称  $v$  邻接到  $w$ 。

图6.1(a)所示的有向图  $G_{1}$  可表示为

$$
G _ {1} = \left(V _ {1}, E _ {1}\right)
$$

$$
V _ {1} = \{1, 2, 3 \}
$$

$$
E _ {1} = \{<   1, 2 >, <   2, 1 >, <   2, 3 > \}
$$

# 2. 无向图

若  $E$  是无向边（简称边）的有限集合，则图  $G$  为无向图。边是顶点的无序对，记为  $(\nu, \mathcal{W})$  或  $(\mathcal{W}, \mathcal{V})$  。可以说  $\mathcal{W}$  和  $\mathcal{V}$  互为邻接点。边  $(\nu, \mathcal{W})$  依附于  $\mathcal{W}$  和  $\mathcal{V}$ ，或称边  $(\nu, \mathcal{W})$  和  $\nu, \mathcal{W}$  相关联。

图6.1(b)所示的无向图  $G_{2}$  可表示为

$$
G _ {2} = \left(V _ {2}, E _ {2}\right)
$$

$$
V _ {2} = \{1, 2, 3, 4 \}
$$

$$
E _ {2} = \{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4) \}
$$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/09e43d05d3c969636e0ce85046c65d881c54714902460e85fc3b27ec6d643d84.jpg)



(a) 有向图  $G_{1}$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8a3206e8f47031ba932af239385edb06ed60681b4838bd4662f772c40ce1266c.jpg)



(b) 无向图  $G_{2}$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/375275695b5cacb08601cf155283c9b39d61295e07f7159cdce42af1efdc308d.jpg)



(c) 有向完全图  $G_{3}$



图6.1 图的示例


# 3. 简单图、多重图

一个图  $G$  若满足：①不存在重复边；②不存在顶点到自身的边，则称图  $G$  为简单图。图6.1中  $G_{1}$  和  $G_{2}$  均为简单图。若图  $G$  中某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身关联，则称图  $G$  为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。

# 4. 顶点的度、入度和出度

# 命题追踪 无向图中顶点和边的关系（2009、2017）

在无向图中，顶点  $v$  的度是指依附于顶点  $v$  的边的条数，记为  $\mathrm{TD}(v)$  。在图6.1(b)中，每个顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。

在有向图中，顶点  $v$  的度分为入度和出度，入度是以顶点  $v$  为终点的有向边的数目，记为  $\mathrm{ID}(v)$ ；而出度是以顶点  $v$  为起点的有向边的数目，记为  $\mathrm{OD}(v)$ 。在图6.1(a)中，顶点2的出度为2、入度为1。顶点  $v$  的度等于其入度与出度之和，即  $\mathrm{TD}(v) = \mathrm{ID}(v) + \mathrm{OD}(v)$ 。有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。

# 5. 路径、路径长度和回路

顶点  $v_{p}$  到顶点  $v_{q}$  之间的一条路径是指顶点序列  $v_{p}, v_{i_{1}}, v_{i_{2}}, \dots, v_{i_{m}}, v_{q}$ ，当然关联的边也可理解为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有  $n$  个顶点，且有大于  $n - 1$  条边，则此图一定有环。

# 6. 简单路径、简单回路

命题追踪 路径、回路、简单路径、简单回路的定义（2011）

在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

# 7. 距离

从顶点  $u$  出发到顶点  $v$  的最短路径若存在，则此路径的长度称为从  $u$  到  $v$  的距离。若从  $u$  到  $v$  根本不存在路径，则记该距离为无穷  $(\infty)$ 。

# 8. 子图

设有两个图  $G = (V,E)$  和  $G^{\prime} = (V^{\prime},E^{\prime})$  ，若  $V^{\prime}$  是  $V$  的子集，且  $E^{\prime}$  是  $E$  的子集，则称  $G^{\prime}$  是  $G$  的子图。若有满足  $V(G^{\prime}) = V(G)$  的子图  $G^{\prime}$  ，则称其为  $G$  的生成子图。图6.1中  $G_{3}$  为  $G_{1}$  的子图。

# 注意

并非  $V$  和  $E$  的任何子集都能构成  $G$  的子图，因为这样的子集可能不是图，即  $E$  的子集中的某些边关联的顶点可能不在这个  $V$  的子集中。

# 9. 连通、连通图和连通分量

命题追踪 图的连通性与边和顶点的关系（2010、2022）

在无向图中，若从顶点  $v$  到顶点  $w$  有路径存在，则称  $v$  和  $w$  是连通的。若图  $G$  中任意两个顶点都是连通的，则称图  $G$  为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，在图6.2(a)中，图  $G_{4}$  有3个连通分量如图6.2(b)所示。假设一个图有  $n$  个顶点，若边数小于  $n - 1$ ，则此图必是非连通图；思考，若该图是非连通图，则最多可以有多少条边？①

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/998795b69b0f3a5d3ecda522d1595a1047abb9c497a0addbbdaa600a5dff42e4.jpg)



(a) 无向图  $G_{4}$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/63418cd5c908c8aaca101a6183ea32ed39372f29875371374d7301154f6de516.jpg)



(b)  $G_{4}$  的三个连通分量


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0c6521364fca284b85b200a5de22a05f123745f4652c1ffb671e5aa563c5617d.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5ec0bb26ccc5beedfe931019af7b66f54eb8dcf072c729f1d121bec55f30cfaa.jpg)



图6.2 无向图及其连通分量


# 10. 强连通图、强连通分量

在有向图中，若有一对顶点  $v$  和  $w$  ，从  $v$  到  $w$  和从  $w$  到  $v$  之间都有路径，则称这两个顶点

是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，图  $G_{1}$  的强连通分量如图6.3所示。思考，假设一个有向图有  $n$  个顶点，若该图是强连通图，则最少需要有多少条边？①

# 注意

在无向图中讨论连通性，在有向图中讨论强连通性。

# 11. 生成树、生成森林

连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为  $n$ ，则它的生成树含有  $n - 1$  条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图  $G_{2}$  的一个生成树如图6.4所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8de3a5f90721514c3f9b599de440fa00e58002046ff703db69c084213a157206.jpg)



图6.3 图  $G_{1}$  的强连通分量


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/94153e77379caf2578fd2f04f4c72127d255c91d225cc63d6972fd0c34181e31.jpg)



图6.4 图  $G_{2}$  的一个生成树


# 注意

区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和边；极小连通子图是既要保持子图连通又要使得边数最少的子图。

# 12. 边的权、网和带权路径长度

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。路径上所有边的权值之和，称为该路径的带权路径长度。

# 13. 完全图（也称简单完全图）

对于无向图，  $|E|$  的取值范围为0到  $n(n - 1) / 2$  ，有  $n(n - 1) / 2$  条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图，  $|E|$  的取值范围为0到  $n(n - 1)$  ，有  $n(n - 1)$  条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1中  $G_{2}$  为无向完全图，而  $G_{3}$  为有向完全图。

# 14．稠密图、稀疏图

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图  $G$  满足  $|E| < |V|\log_2|V|$  时，可以将  $G$  视为稀疏图。

# 15. 有向树

一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。

# 6.1.2 本节试题精选

# 一、单项选择题

01. 图中有关路径的定义是（）。

A. 由顶点和相邻顶点序偶构成的边所形成的序列

B. 由不同顶点所形成的序列

C. 由不同边所形成的序列

D. 上述定义都不是

02. 一个有  $n$  个顶点和  $n$  条边的无向图一定是（）。

A. 连通的

B. 不连通的

C. 无环的

D. 有环的

03. 若从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是（）。

A. 强连通图

B. 连通图

C. 有回路

D. 一棵树

04. 以下关于图的叙述中，正确的是（）。

A. 图与树的区别在于图的边数大于或等于顶点数

B. 假设有图  $G = \{V, \{E\}\}$ ，顶点集  $V' \subseteq V$ ， $E' \subseteq E$ ，则  $V'$  和  $\{E'\}$  构成  $G$  的子图

C. 无向图的连通分量是指无向图中的极大连通子图

D. 图的遍历就是从图中某一顶点出发访遍图中其余顶点

05. 以下关于图的叙述中，正确的是（）。

A. 强连通有向图的任何顶点到其他所有顶点都有弧

B. 图的任意顶点的入度等于出度

C. 有向完全图一定是强连通有向图

D. 有向图的边集的子集和顶点集的子集都构成原有向图的子图

06. 一个有28条边的非连通无向图至少有（）个顶点。

A. 7

B. 8

C. 9

D. 10

07. 对于一个有  $n$  个顶点的图：若是连通无向图，其边的个数至少为（）；若是强连通有向图，则其边的个数至少为（）。

A.  $n - 1, n$

B.  $n - 1, n(n - 1)$

C.  $n, n$

D.  $n, n(n - 1)$

08. 无向图  $G$  有23条边，度为4的顶点有5个，度为3的顶点有4个，其余都是度为2的顶点，则图  $G$  有（）个顶点。

A. 11

B. 12

C. 15

D. 16

09. 在有  $n$  个顶点的有向图中，顶点的度最大可达（）。

A.  $n$

B.  $n - 1$

C.  ${2n}$

D.  ${2n} - 2$

10. 具有6个顶点的无向图，当有（）条边时能确保是一个连通图。

A. 8

B. 9

C. 10

D. 11

11. 设有无向图  $G = (V, E)$  和  $G' = (V', E')$ ，若  $G'$  是  $G$  的生成树，则下列不正确的是（）。

I.  $G^{\prime}$  为  $G$  的连通分量

II.  $G^{\prime}$  为  $G$  的无环子图

III.  $G'$  为  $G$  的极小连通子图且  $V' = V$

A. I、II

B. 只有 III

C. II、III

D. 只有 I

12. 具有 51 个顶点和 21 条边的无向图的连通分量最多为 (   )。

A. 33

B. 34

C. 45

D. 32

13. 在如下图所示的有向图中，共有（）个强连通分量。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8085f905ab395776ea5cfebb6c62bb7238e3d811884226d4fce9c40bcf1a7f52.jpg)


A. 1

B. 2

C. 3

D. 4

14. 若具有  $n$  个顶点的图是一个环，则它有（）棵生成树。

A.  $n^{2}$

B.  $n$

C.  $n - 1$

D. 1

15. 若一个具有  $n$  个顶点、  $e$  条边的无向图是一个森林，则该森林中必有（）棵树。

A.  $n$

B.  $e$

C.  $n - e$

D. 1

16.【2009统考真题】下列关于无向连通图特性的叙述中，正确的是（）。

I. 所有顶点的度之和为偶数

II. 边数大于顶点个数减 1

III. 至少有一个顶点的度为 1

A. 只有 I

B. 只有 II

C. I和II

D. I 和 III

17.【2010统考真题】若无向图  $G = (V,E)$  中含有7个顶点，要保证图  $G$  在任何情况下都是连通的，则需要的边数最少是（）。

A. 6

B. 15

C. 16

D. 21

18.【2017统考真题】已知无向图  $G$  含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图  $G$  所含的顶点个数至少是（）。

A. 10

B. 11

C. 13

D. 15

19.【2022统考真题】对于无向图  $G = (V,E)$  ，下列选项中，正确的是（）。

A. 当  $|V| > |E|$  时， $G$  一定是连通的

B. 当  $|V| < |E|$  时,  $G$  一定是连通的

C. 当  $|V| = |E| - 1$  时,  $G$  一定是不连通的

D. 当  $|V| > |E| + 1$  时,  $G$  一定是不连通的

# 二、综合应用题

01. 图  $G$  是一个非连通无向图，共有28条边，该图至少有多少个顶点？

# 6.1.3 答案与解析

# 一、单项选择题

01. A

本题是北京交通大学考研真题，不同教材对路径的定义可能略有不同，顶点之间关联的边也可理解为路径的构成要素。对于选项B，路径的定义中并没有要求是不同顶点，比如简单回路的第一个顶点和最后一个顶点是可以相同的，此外选项B也没有说明这些顶点之间有边相联。

02. D

若一个无向图有  $n$  个顶点和  $n - 1$  条边，可以使它连通但没有环（生成树），但若再加一条边，在不考虑重边的情形下，则必然会构成环。

03. B

强连通图是有向图，与题意矛盾，选项A错误；对无向连通图做一次深度优先搜索，可以访问到该连通图的所有顶点，选项B正确；有回路的无向图不一定是连通图，因为回路不一定

包含图的所有结点，选项C错误；连通图可能是树，也可能存在环，选项D错误。

# 04.C

图与树的区别是逻辑上的区别，而不是边数的区别，图的边数也可能小于树的边数，选项A错误；若  $E^{\prime}$  中的边对应的顶点不是  $V$  的元素，  $V^{\prime}$  和  $\{E^{\prime}\}$  无法构成图，选项B错误；无向图的极大连通子图称为连通分量，选项C正确；图的遍历要求每个结点只能被访问一次，且若图非连通，则从某一顶点出发无法访问到其他全部顶点，选项D的说法不准确。

# 05. C

强连通有向图的任何顶点到其他所有顶点都有路径，但未必有弧；无向图任意顶点的入度等于出度，但有向图未必满足；若边集中的某条边对应的某个顶点不在对应的顶点集中，则有向图的边集的子集和顶点集的子集无法构成子图。

# 06. C

考查至少有多少个顶点的情形，我们考虑该非连通图最极端的情况，即它由一个完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图。在  $28 = n(n - 1) / 2 = 8 \times 7 / 2$  条边的完全无向图中，总共有8个顶点，再加上1个不连通的顶点，共9个顶点。

# 07. A

对于连通无向图，边最少即构成一棵树的情形；对于强连通有向图，边最少即构成一个有向环的情形。

# 08. D

因为在具有  $n$  个顶点、 $e$  条边的无向图中，有  $\sum_{i=1}^{n} \mathrm{TD}(v_i) = 2e$ ，所以求得度为 2 的顶点数为 7，从而共有 16 个顶点。

# 09. D

在有向图中，顶点的度等于入度与出度之和。  $n$  个顶点的有向图中，任意一个顶点最多还可以与其他  $n - 1$  个顶点有一对指向相反的边相连。注意，数据结构中仅讨论简单图。

# 10. D

5个顶点构成一个完全无向图，需要  $n(n - 1) / 2 = 10$  条边；再加上1条边后，能保证第6个顶点必然与此完全无向图构成一个连通图，所以共需11条边。

# 11. D

一个连通图的生成树是一个极小连通子图，显然它是无环的，因此选项Ⅱ、Ⅲ正确。极大连通子图称为连通分量， $G'$  连通但非连通分量。这里再补充一下“极大连通子图”：若图本来就是连通的，且每个子部分包含其本身的所有顶点和边，则它就是极大连通子图。

# 12. C

初始考虑只有51个顶点的无向图  $G$  ，此时  $G$  中每个顶点都是连通分量，问题转化为向  $G$  中添加21条边，如何添加这21条边使得连通分量数目最多。若向两个不同的连通分量之间添加边，则连通分量数目会减1，所以应尽可能地将这21条边加入同一个连通分量且让其接近完全图，含有7个顶点的完全图有21条边，所以用7个顶点构成一个含有21条边的连通分量，剩下 $51 - 7 = 44$  个顶点对应44个连通分量，共有45个连通分量。

# 13. B

强连通分量是极大强连通子图，任意两个顶点之间有方向相反的两条路径。由定义不难得出，若一个顶点只有出边或入边，则该顶点必定单独构成一个连通分量。图中，顶点  $B$  只有出边，其他所有顶点都不可能有到顶点  $B$  的路径，所以顶点  $B$  单独构成一个强连通分量。在顶点  $A$  、  $C$  、  $D$  、  $E$  中，任意两个顶点之间都有方向相反的两条路径，所以可构成一个强连通分量。

# 14. B

$n$  个顶点的生成树是具有  $n - 1$  条边的极小连通子图，因为  $n$  个顶点构成的环共有  $n$  条边，去掉任意一条边就是一棵生成树，所以共有  $n$  种情况，所以可以有  $n$  棵不同的生成树。

# 15. C

$n$  个结点的树有  $n - 1$  条边，假设森林中有  $x$  棵树，将每棵树的根连到一个添加的结点，则成为一棵树，结点数是  $n + 1$  ，边数是  $e + x$  ，从而可知  $x = n - e$  。

【另解】设森林中有  $x$  棵树，则再用  $x - 1$  条边就可将所有的树连接成一棵树，此时边数  $+1 =$  顶点数，即  $e + (x - 1) + 1 = n$  ，所以  $x = n - e$  。

# 16. A

每条边都连接了两个顶点，在计算顶点的度之和时每条边都被计算了两次，所以所有顶点的度之和偶数。无向连通图对应的生成树也是无向连通图，但此时边数等于顶点数减1，选项II错误。考虑2个或以上的顶点恰好构成一个环的情况，此时每个顶点的度都是2，选项III错误。

# 17. C

题干要求无论如何分配边，都能使7个顶点连通，这不同于只要6条边两两相连就能构成一个连通图的情形。考虑最极端的情形，即图  $G$  的某6个顶点构成一个完全无向图，此时若再添加一条边，则都将连通第7个顶点，使该图变成一个连通图。所以最少边数  $= 6 \times 5 / 2 + 1 = 16$  。若边数  $n$  小于或等于15，可以使这  $n$  条边仅连接图  $G$  中的某6个顶点，从而导致第7个顶点无法与这6个顶点构成连通图（不满足“在任何情况下”）。

为简单起见，以5个顶点为例，左边4个顶点和  $4 \times 3 / 2 = 6$  条边构成一个完全图，此时若再添加一条边（可以是虚线中的任意一条），则能保证这5个顶点在任何情况下都是连通的，如下图所示。若边数小于7，则不能保证5个顶点在任何情况下都是连通的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/22a69873b248e80d41e722ba241b512ab15cb44ad583fa880e123aa395aa1dc4.jpg)


# 18. B

无向图边数的2倍等于各顶点度数的总和。要求至少的顶点数，应使每个顶点的度取最大，而其他顶点的度均小于3，因此可设它们的度都为2，并设它们的数量是  $x$  ，列出方程  $4 \times 3 + 3 \times 4 + 2x = 16 \times 2$  ，解得  $x = 4$  。因此至少包含  $4 + 4 + 3 = 11$  个顶点。

# 19. D

对于此类分析图的边数、顶点数与连通性问题，思路是寻找临界情况，在临界情况下任意增加或减少一条边，都会改变图的连通性。第一种临界情况如图1所示，此时若减少任意一条边，图就由连通变为不连通，即无向图连通的最小边数是  $|V| - 1$ ，因此，当  $|E| < |V| - 1$  时，图一定不连通，选项C错误，选项D正确。第二种临界情况如图2所示，此时若增加任意一条边，则图就由不连通变为连通，即无向图不连通的最大边数是  $(|V| - 1)(|V| - 2) / 2$  （此时  $|V| - 1$  个顶点构成一个完全图），因此，仅当  $|E| \geqslant (|V| - 1)(|V| - 2) / 2 + 1$  时才能保证无向图一定连通，选项A、B错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f29334bfc1d1dae0c8596be8e8eaf913af472e60aa20b467b58433e7020b1166.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/13b9c17361966996623fdb203f9f575cb340d09d5eafbd47c555d09041b5053d.jpg)



图2


# 二、综合应用题

# 01.【解答】

图  $G$  是一个非连通无向图，当边数固定时，顶点数最少的情况是该图由两个连通子图构

成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全图的边数为  $n(n - 1) / 2 = 28$ ，得  $n = 8$  。所以该图至少有  $1 + 8 = 9$  个顶点。

# 6.2 图的存储及基本操作

图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于待求解的问题。

# 6.2.1 邻接矩阵法

所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。

顶点数为  $n$  的图  $G = (V,E)$  的邻接矩阵  $\mathbf{A}$  是  $n\times n$  的，将  $G$  的顶点编号为  $\nu_{1},\nu_{2},\dots ,\nu_{n}$  ，则

$$
A [ i ] [ j ] = \left\{ \begin{array}{l l} 1, & \left(\mathrm {v} _ {i}, \mathrm {v} _ {j}\right) \text {或} \langle \mathrm {v} _ {i}, \mathrm {v} _ {j} \rangle \text {是} E (G) \text {中 的 边} \\ 0, & \left(\mathrm {v} _ {i}, \mathrm {v} _ {j}\right) \text {或} \langle \mathrm {v} _ {i}, \mathrm {v} _ {j} \rangle \text {不 是} E (G) \text {中 的 边} \end{array} \right.
$$

# 命题追踪 图的邻接矩阵存储及相互转换（2011、2015、2018）

对带权图而言，若顶点  $\nu_{i}$  和  $\nu_{j}$  之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点  $V_{i}$  和  $V_{j}$  不相连，则通常用0或  $\infty$  来代表这两个顶点之间不存在边：

$$
A [ i ] [ j ] = \left\{ \begin{array}{l l} w _ {i j}, & (v _ {i}, v _ {j}) \text {或} \langle v _ {i}, v _ {j} \rangle \text {是} E (G) \text {中 的 边} \\ 0 \text {或} \infty , & (v _ {i}, v _ {j}) \text {或} \langle v _ {i}, v _ {j} \rangle \text {不 是} E (G) \text {中 的 边} \end{array} \right.
$$

有向图、无向图和网对应的邻接矩阵示例如图6.5所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c9dde44fb494e5d011d7a4569fcf3ef3fd4652f5bf7de03472974feae0dc3c3e.jpg)



(a) 有向图  $G_{1}$  及其邻接矩阵


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f991d9d608a154457fca99f08fab77bef0bc9cbedf94f6fcee0c19920920077f.jpg)



(b) 无向图  $G_{2}$  及其邻接矩阵


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2f8fa8b78f8ba993503862791bcfb79f2efc3dd7d25fcfb079dcdf0b339f03b3.jpg)



(c)网及其邻接矩阵（对角线元素也经常用0表示）


$$
A _ {3} = \left[ \begin{array}{l l l l l l} \infty & 5 & \infty & \infty & \infty & \infty \\ \infty & \infty & 4 & \infty & \infty & \infty \\ 8 & \infty & \infty & \infty & \infty & 9 \\ \infty & \infty & 5 & \infty & \infty & 6 \\ \infty & \infty & \infty & 5 & \infty & \infty \\ 3 & \infty & \infty & \infty & 1 & \infty \end{array} \right]
$$


图6.5 有向图、无向图及网的邻接矩阵


# 命题追踪 （算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）

图的邻接矩阵存储结构定义如下：

```txt
define MaxVertexNum 100 //顶点数目的最大值  
typedef char VertexType; //顶点对应的数据类型  
typedef int EdgeType; //边对应的数据类型  
typedef struct{  
    VertexType vex[MaxVertexNum]; //顶点表  
    EdgeType edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表
```

```c
int vexnum,arcnum;   
}MGraph;
```

//图的当前顶点数和边数

# 注意

① 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。

② 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。

③ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。

④ 邻接矩阵表示法的空间复杂度为  $O(n^{2})$  ，其中  $n$  为图的顶点数  $|V|$  。

# 命题追踪 邻接矩阵的遍历的时间复杂度（2021）

图的邻接矩阵存储表示法具有以下特点：

① 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。

# 命题追踪 基于邻接矩阵的顶点的度的计算（2013、2021、2023）

② 对于无向图，邻接矩阵的第  $i$  行（或第  $i$  列）非零元素（或非  $\infty$  元素）的个数正好是顶点  $i$  的度  $\mathrm{TD}(\nu_i)$ 。

③ 对于有向图，邻接矩阵的第  $i$  行非零元素（或非  $\infty$  元素）的个数正好是顶点  $i$  的出度  $\mathrm{OD}(\mathfrak{v}_i)$  ；第  $i$  列非零元素（或非  $\infty$  元素）的个数正好是顶点  $i$  的入度  $\mathrm{ID}(\mathfrak{v}_i)$  。

④ 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。

⑤ 稠密图（边数较多的图）适合采用邻接矩阵的存储表示。

# 命题追踪 计算  $A^2$  并说明  $A^n [i][j]$  的含义（2015）

⑥ 设图  $G$  的邻接矩阵为  $A$ ， $A^n$  的元素  $A^n[i][j]$  等于由顶点  $i$  到顶点  $j$  的长度为  $n$  的路径的数目。该结论了解即可，证明方法可参考离散数学教材。

# 6.2.2 邻接表法

当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。

所谓邻接表，是指对图  $G$  中的每个顶点  $\nu_{i}$  建立一个单链表，第  $i$  个单链表中的结点表示依附于顶点  $\nu_{i}$  的边（对于有向图则是以顶点  $\nu_{i}$  为尾的弧），这个单链表就称为顶点  $\nu_{i}$  的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9fe5c3f751bad2db4f3f441389662dae3247eb18c9a64a6810c6a83a34243bd6.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6b8f961e539fe59ffc9aa7b80b55e3a996045191f1fe2ca2277cc41f778df3b7.jpg)



图6.6 顶点表和边表结点结构


顶点表结点由两个域组成：顶点域（data）存储顶点  $\nu_{i}$  的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存储与头结点顶点  $\nu_{i}$  邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。

# 命题追踪 图的邻接表存储的应用（2014）

无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d8ecd8645da633b847abf16cbb1fc464e902ddd1a7375c1f34b9bac44a49b92e.jpg)



(a)无向图  $G$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/617bf69db4a2cedde853f9fcfb8cab09b464ff0cfd78bd6324c05bf149f8d007.jpg)



(b) 无向图G的邻接表的表示



图6.7 无向图邻接表表示法实例


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/36d39964ea3f88fb7d5d26b15410a3423af4f04c91da3f7c0b388b6ed4ea4b58.jpg)



(a)有向图  $G$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f732b9addebdb2336b4715c983100bec616d149fca98de39105f1951d94c36b1.jpg)



(b)有向图  $G$  的邻接表的表示



图6.8 有向图邻接表表示法实例


图的邻接表存储结构定义如下：

```txt
define MaxVertexNum 100 //图中顶点数目的最大值  
typedef struct ArcNode{ //边表结点  
int adjvex; //该弧所指向的顶点的位置  
struct ArcNode *nextarc; //指向下一条弧的指针  
//InfoType info; //网的边权值  
}ArcNode;  
typedef struct VNode{ //顶点表结点  
VertexType data; //顶点信息  
ArcNode *firstarc; //指向第一条依附该顶点的弧的指针  
}VNode,AdjList [MaxVertexNum];  
typedef struct{  
AdjList vertices; //邻接表  
int vexnum,arcnum; //图的顶点数和弧数  
}ALGraph; //ALGraph是以邻接表存储的图类型
```

图的邻接表存储方法具有以下特点：

① 若  $G$  为无向图，则所需的存储空间为  $O(|V| + 2|E|)$ ；若  $G$  为有向图，则所需的存储空间为  $O(|V| + |E|)$ 。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。

# 命题追踪 邻接矩阵法和邻接表法的适用性差异（2011）

② 对于稀疏图（边数较少的图），采用邻接表表示将极大地节省存储空间。

③ 在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为  $O(n)$  。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。

④ 在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点  $x$  的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为  $x$  的边表结点个数。

⑤ 图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。

# 6.2.3 十字链表

十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b78a660184811c564bdbd3824ea8999e0d1ed3ddb92f88fec7c1ee72893ce0b2.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/198af3d7354855e59e4dc65a036c7a86aad79887fbff646f407edc168437acea.jpg)


弧结点中有5个域：tailvex域和headvex域分别存放弧尾和弧头这两个顶点的编号；头链域hlink指向弧头相同的下一条弧；尾链域tlink指向弧尾相同的下一条弧；info域存放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。

顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以该顶点为弧头的第一条弧；firstout域指向以该顶点为弧尾的第一条弧。

图6.9为有向图的十字链表表示法。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a476f614eeec7e088b3b361f8a2a14e03421377269f7c9836433d4cb5d577bd6.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6dc4787f65d7423bbd06e621cb14d2fccec67b992617b561b7ae5d4f3e141b05.jpg)



(b)



图6.9 有向图的十字链表表示（弧结点省略info域）


注意，顶点结点之间是顺序存储的，弧结点省略了 info 域。

在十字链表中，既容易找到  $V_{i}$  为尾的弧，也容易找到  $V_{i}$  为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。

# 6.2.4 邻接多重表

邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但求两个顶点之间是否存在边而执行删除边等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。

<table><tr><td>ivex</td><td>ilink</td><td>jvex</td><td>jlink</td><td>(info)</td></tr></table>

其中，ivex域和jvex域存放该边依附的两个顶点的编号；ilink域指向依附于顶点ivex的下一条边；jlink域指向依附于顶点jvex的下一条边，info域存放该边的相关信息。

每个顶点也用一个结点表示，它由如下所示的两个域组成。

<table><tr><td>data</td><td>firstedge</td></tr></table>

其中，data 域存放该顶点的相关信息，firstedge 域指向依附于该顶点的第一条边。

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。

# 命题追踪 图的邻接多重表表示的分析（2024）

图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/329933fe78248866569c7802ce3b89e00fba7d1dcdd4ba40f46ce4496116a358.jpg)



图6.10 无向图的邻接多重表表示（边结点省略info域）


图的四种存储方式的总结如表6.1所示。


表 6.1 图的四种存储方式的总结


<table><tr><td></td><td>邻接矩阵</td><td>邻接表</td><td>十字链表</td><td>邻接多重表</td></tr><tr><td>空间复杂度</td><td>O(|V|^2)</td><td>无向图: O(|V|+2|E|)
有向图: O(|V|+|E|)</td><td>O(|V|+|E|)</td><td>O(|V|+|E|)</td></tr><tr><td>找相邻边</td><td>遍历对应行或列的时间复杂度为 O(|V|)</td><td>找有向图的入度必须遍历整个邻接表</td><td>很方便</td><td>很方便</td></tr><tr><td>删除边或顶点</td><td>删除边很方便, 删除顶点需要大量移动数据</td><td>无向图中删除边或顶点都不方便</td><td>很方便</td><td>很方便</td></tr><tr><td>适用于</td><td>稠密图</td><td>稀疏图和其他</td><td>只能存有向图</td><td>只能存无向图</td></tr><tr><td>表示方式</td><td>唯一</td><td>不唯一</td><td>不唯一</td><td>不唯一</td></tr></table>

# 6.2.5 图的基本操作

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。

图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：

- Adjacent  $(G, x, y)$  ：判断图  $G$  是否存在边  $<x, y>$  或  $(x, y)$  。

- Neighbors  $(G, x)$  ：列出图  $G$  中与结点  $x$  邻接的边。

- InsertVertex(G, x): 在图 G 中插入顶点 x。

- DeleteVertex(G, x): 从图 G 中删除顶点 x。

- AddEdge  $(G, x, y)$  ：若无向边  $(x, y)$  或有向边  $<x, y>$  不存在，则向图  $G$  中添加该边。

- RemoveEdge  $(G, x, y)$  ：若无向边  $(x, y)$  或有向边  $<x, y>$  存在，则从图 G 中删除该边。

- FirstNeighbor(G,x): 求图 G 中顶点 x 的第一个邻接点, 若有则返回顶点号。若 x 没有邻接点或图中不存在 x, 则返回 -1。

- NextNeighbor  $(G, x, y)$ ：假设图  $G$  中顶点  $y$  是顶点  $x$  的一个邻接点，返回除  $y$  外顶点  $x$  的下一个邻接点的顶点号，若  $y$  是  $x$  的最后一个邻接点，则返回 -1。

- Get_edge_value(G, x, y): 获取图 G 中边 (x, y) 或  $<x, y>$  对应的权值。

- Set_edge_value(G, x, y, v): 设置图 G 中边 (x, y) 或  $<x, y>$  对应的权值为 v。

此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历，具体见下一节的内容。

# 6.2.6 本节试题精选

# 一、单项选择题

01. 下列关于图的存储结构的说法中，错误的是（）。

A. 使用邻接矩阵存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中的顶点数有关，与边数无关

B. 邻接表只用于有向图的存储，邻接矩阵适用于有向图和无向图

C. 若一个有向图的邻接矩阵的对角线以下的元素为 0 , 则该图的拓扑序列必定存在

D. 存储无向图的邻接矩阵是对称的, 所以只需存储邻接矩阵的下 (或上) 三角部分

02. 若图的邻接矩阵中主对角线上的元素皆为 0 ,其余元素全为 1 ,则该图一定 (   )。

A. 是无向图

B. 是有向图

C. 是完全图

D. 不是带权图

03. 在含有  $n$  个顶点和  $e$  条边的无向图的邻接矩阵中，零元素的个数为（）。

A.  $e$

B.  ${2e}$

C.  $n^{2} - e$

D.  $n^{2} - 2e$

04. 带权有向图  $G$  用邻接矩阵存储，则  $\nu_{i}$  的入度等于邻接矩阵中（）。

A. 第  $i$  行非  $\infty$  的元素个数

B. 第  $i$  列非  $\infty$  的元素个数

C. 第  $i$  行非  $\infty$  且非 0 的元素个数

D. 第  $i$  列非  $\infty$  且非0的元素个数

05. 一个有  $n$  个顶点的图用邻接矩阵  $A$  表示，若图为有向图，顶点  $v_{i}$  的入度是（）；若图为无向图，顶点  $v_{i}$  的度是（）。

A.  $\sum_{i=1}^{n} A[i][j]$

B.  $\sum_{j=1}^{n} A[j][i]$

C.  $\sum_{i=1}^{n} A[j][i]$

D.  $\sum_{j=1}^{n} A[j][i]$  或  $\sum_{j=1}^{n} A[i][j]$

06. 从邻接矩阵  $A = \begin{bmatrix} 0 & 1 & 0 \\ 1 & 0 & 1 \\ 0 & 1 & 0 \end{bmatrix}$  可以看出，该图共有（①）个顶点；若是有向图，则该图共有（②）条弧；若是无向图，则共有（③）条边。

$①$  A.9

B. 3

C. 6

D. 1

E. 以上答案均不正确

$②$  A.5

B. 4

C. 3

D. 2

E. 以上答案均不正确

$③$  A.5

B. 4

C. 3

D. 2

E. 以上答案均不正确

07. 以下关于图的存储结构的叙述中，正确的是（）。

A. 一个图的邻接矩阵表示唯一，邻接表表示唯一

B. 一个图的邻接矩阵表示唯一，邻接表表示不唯一

C. 一个图的邻接矩阵表示不唯一, 邻接表表示唯一

D. 一个图的邻接矩阵表示不唯一, 邻接表表示不唯一

08. 矩阵  $\mathbf{A}$  是有向图  $G$  的邻接矩阵，若矩阵  $A^2$  的某元素  $a_{t,j}^2 = 3$  ，则说明（）。

A. 从顶点  $i$  到  $j$  存在 3 条长度为 2 的路径

B. 从顶点  $i$  到  $j$  存在3条长度不超过2的路径

C. 从顶点  $i$  到  $j$  存在 2 条长度为 3 的路径

D. 从顶点  $i$  到  $j$  存在 2 条长度不超过 3 的路径

09. 用邻接表法存储图所用的空间大小（）。

A. 与图的顶点数和边数有关

B. 只与图的边数有关

C. 只与图的顶点数有关

D. 与边数的平方有关

10. 若邻接表中有奇数个边表结点，则（）。

A. 图中有奇数个结点

B. 图中有偶数个结点

C. 图为无向图

D. 图为有向图

11. 在有向图的邻接表存储结构中，顶点  $v$  在边表中出现的次数是（）。

A. 顶点  $v$  的度

B. 顶点  $v$  的出度

C. 顶点  $v$  的入度

D. 依附于顶点  $v$  的边数

12.  $n$  个顶点的无向图的邻接表最多有（）个边表结点。

A.  $n^{2}$

B.  $n(n - 1)$

C.  $n(n + 1)$

D.  $n(n - 1) / 2$

13. 设某无向图中有  $n$  个顶点和  $e$  条边，则建立该图的邻接表的时间复杂度是（）。

A.  $O(n + e)$

B.  $O(n^{2})$

C.  $O(n e)$

D.  $O\left(n^{3}\right)$

14. 假设有  $n$  个顶点、  $e$  条边的有向图用邻接表表示，则删除与某个顶点  $v$  相关的所有边的时间复杂度为（）。

A.  $O(n)$

B.  $O(e)$

C.  $O(n + e)$

D.  $O(ne)$

15. 设  $n$  个顶点、  $e$  条边的有向图用邻接表表示，则某个顶点  $v$  的入度的时间复杂度为（）。

$O(n)$

B.  $O(e)$

C.  $O(n + e)$

D.  $O(ne)$

16. 对邻接表的叙述中，（）是正确的。

A. 无向图的邻接表中, 第  $i$  个顶点的度为第  $i$  个链表中结点数的两倍

B.邻接表比邻接矩阵的操作更简便

C. 邻接矩阵比邻接表的操作更简便

D. 求有向图结点的度, 必须遍历整个邻接表

17. 邻接多重表是（）的存储结构。

A. 无向图

B. 有向图

C. 无向图和有向图

D. 都不是

18. 十字链表是（）的存储结构。

A. 无向图

B. 有向图

C. 无向图和有向图

D. 都不是

19.【2013统考真题】设图的邻接矩阵  $A$  如下所示，各顶点的度依次是（）。

$$
\boldsymbol {A} = \left[ \begin{array}{l l l l} 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \end{array} \right]
$$

A.  $1,2,1,2$

B. 2, 2, 1, 1

C. 3,4,2,3

D. 4, 4, 2, 2

20.【2024统考真题】若无向图  $G = (V,E)$  的邻接多重表如下图所示，则  $G$  中顶点  $b$  与  $d$  的度分别是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8473ec2627ea482ff042a560ed53f1150df10b47dc10fac164b1da6cc1600fe7.jpg)


A. 0, 2

B. 2, 4

C. 2, 5

D. 3, 4

# 二、综合应用题

01. 已知带权有向图  $G$  的邻接矩阵如下图所示，请画出该带权有向图  $G$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6d894948fb73e10f6e6e4dbf39a3dd6e4191e25afea22cc047e143654636e87b.jpg)


02. 设图  $G = (V, E)$  以邻接表存储，如下图所示。画出其邻接矩阵存储及图  $G$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6d7ddb9a347cf921355e9f088c81e72d8c63d1996f7fd34eaf5ffdabce2692da.jpg)


03. 对  $n$  个顶点的无向图和有向图，分别采用邻接矩阵和邻接表表示时，试问：

1）如何判别图中有多少条边？

2）如何判别任意两个顶点  $i$  和  $j$  是否有边相连？

3）任意一个顶点的度是多少？

04. 如何对无环有向图中的顶点重新编号，使得该图的邻接矩阵中所有的1都集中到对角线以上？

05. 写出从图的邻接表表示转换成邻接矩阵表示的算法。

06.【2015统考真题】已知含有5个顶点的图  $G$  如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0df2abd717e3e8fa9a9f49a40dbd7e0e21d604f3b1ed89a7a2a22e3fb256bd6c.jpg)


请回答下列问题：

1）写出图  $G$  的邻接矩阵  $\mathbf{A}$  （行、列下标从0开始）。

2）求  $A^2$  ，矩阵  $A^2$  中位于0行3列元素值的含义是什么？

3）若已知具有  $n$  （ $n \geq 2$ ）个顶点的图的邻接矩阵为  $\pmb{B}$ ，则  $\pmb{B}^{m}$ （ $2 \leq m \leq n$ ）中非零元素的含义是什么？

07.【2021统考真题】已知无向连通图  $G$  由顶点集  $V$  和边集  $E$  组成，  $|E| > 0$  ，当  $G$  中度为奇数的顶点个数为不大于2的偶数时，  $G$  存在包含所有边且长度为  $|E|$  的路径（称为EL路径）。设图  $G$  采用邻接矩阵存储，类型定义如下：

```txt
typedef struct{ //图的定义int numVertices,numEdges; //图中实际的顶点数和边数char VerticesList[MAXV]; //顶点表。MAXV为已定义常量int Edge[MAXV][MAXV]; //邻接矩阵}MGraph;
```

请设计算法 int IsExistEL(MGraph G)，判断 G 是否存在 EL 路径，若存在，则返回 1，否则返回 0。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度和空间复杂度。

08.【2023统考真题】已知有向图  $G$  采用邻接矩阵存储，类型定义如下：

```txt
typedef struct{ //图的类型定义int numVertices,numEdges; //图的顶点数和有向边数char VerticesList[MAXV]; //顶点表，MAXV为已定义常量int Edge[MAXV][MAXV]; //邻接矩阵}MGraph;
```

将图中出度大于入度的顶点称为K顶点。例如，在下图中，顶点  $a$  和  $b$  为K顶点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9dfc89c7e1009d0a12e4d5251996d403b0eef06e3a0e76f6ef78beda4839e745.jpg)


请设计算法 int printVertices (MGraph G)，对给定的任意非空有向图 G，输出 G 中所有的 K 顶点，并返回 K 顶点的个数。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

# 6.2.7 答案与解析

# 一、单项选择题

01. B

$n$  个顶点的图，若采用邻接矩阵表示，不考虑压缩存储，则存储空间大小为  $O(n^{2})$  ，选项A正确。邻接表可用于存储无向图，只是把每条边都视为两条方向相反的有向边，因此需要存储两次，选项B错误。因为邻接矩阵中对角线以下的元素全为0，所以若存在  $\langle i,j\rangle$  ，则必有  $i < j$  由传递性可知图中路径的顶点编号是依次递增的，假设存在环  $k\to \dots \to j\to k$  ，由题设可知  $k < j < k$  ，矛盾，所以不存在环，拓扑序列必定存在，选项C正确。选项D显然正确。

# 注意

若邻接矩阵对角线以下（或以上）的元素全为0，则图中必然不存在环，即拓扑序列一定存在，但这并不能说明拓扑序列是唯一的。

02. C

除主对角线上的元素外，其余元素全为1，说明任意两个顶点之间都有边相连，因此该图一

定是完全图。

# 03. D

在无向图的邻接矩阵中，矩阵大小为  $n^2$ ，非零元素的个数为  $2e$ ，所以零元素的个数为  $n^2 - 2e$ 。读者应掌握此题的变体，即当无向图变为有向图时，能够求出零的个数和非零的个数。

# 04. D

带权有向图的邻接矩阵中，0和  $\infty$  表示的都不是有向边，而入度是由邻接矩阵的列中元素计算出来的；出度是由邻接矩阵的行中元素计算出来的。

# 05. B、D

有向图的入度是其第  $i$  列的非0元素之和，无向图的度是第  $i$  行或第  $i$  列的非0元素之和。

# 06. B、B、D

邻接矩阵的顶点数等于矩阵的行（列）数，有向图的边数等于矩阵中非零元素的个数，无向图的边数等于矩阵中非零元素个数的一半。

# 注意

本题中所给的矩阵为对称矩阵，若不是对称矩阵，则必然不可能是无向图。

# 07. B

邻接矩阵表示唯一是因为图中边的信息在矩阵中有确定的位置，邻接表不唯一是因为邻接表的建立取决于读入边的顺序和边表中的插入算法。

# 08. A

设图  $G$  的邻接矩阵为  $\mathbf{A}$ ， $\mathbf{A}^n$  的元素  $a_{i,j}^n$  等于从顶点  $i$  到  $j$  的长度为  $n$  的路径的数目，因此  $a_{i,j}^2 = 3$  表示从顶点  $i$  到  $j$  存在 3 条长度为 2 的路径。该结论记住即可。

# 09. A

邻接表存储时，顶点数  $n$  决定了顶点表的大小，边数  $e$  决定了边表结点的个数，且无向图的每条边存储两次，总存储空间为  $O(n + 2e)$  。而邻接矩阵只与图的顶点数有关，为  $O(n^2)$  。

# 10. D

无向图采用邻接表表示时，每条边存储两次，所以其边表结点的个数为偶数。题中边表结点为奇数个，所以必然是有向图，且有奇数条边。

# 11. C

题中的边表是不包括顶点表的。因为任何顶点  $u$  对应的边表中存放的都是以  $u$  为起点的边所对应的另一个顶点  $\nu$  。从而  $\nu$  在边表中出现的次数也就是它的入度。

# 12. B

最多有  $n(n - 1) / 2$  条边，每条边在邻接表中存储两次，因此边表结点最多为  $n(n - 1)$  个。

# 13. A

建立图的邻接表需要遍历所有的顶点和边，每个顶点有一个顶点表结点，每条边需要创建一个边表结点并插入到相应的链表中。因此，共需  $n + 2e$  次操作，时间复杂度为  $O(n + e)$  。

# 14. C

与顶点  $\nu$  相关的边包括出边和入边，对于出边，只需遍历  $\nu$  的顶点表结点和其指向的边表；对于入边，则需遍历整个边表。先删除出边：删除  $\nu$  的顶点表结点的单链表，出边数最多为  $n - 1$ ，时间复杂度为  $O(n)$ ；再删除入边：扫描整个边表（扫描剩余全部顶点表结点及其指向的边表），删除所有的顶点  $\nu$  的入边，时间复杂度为  $O(n + e)$ 。因此总时间复杂度为  $O(n + e)$ 。

15. C

为了求顶点  $\nu$  的入度，只需要遍历邻接表中的所有边表，检查每条边是否指向顶点  $\nu$ ，这相当于遍历整个邻接表，因此算法的时间复杂度为  $O(n + e)$ 。

16. D

无向图的邻接表中，第  $i$  个顶点的度为第  $i$  个链表中的结点数，所以选项A错。邻接表和邻接矩阵对于不同的操作各有优势，选项B和C都不准确。有向图结点的度包括出度和入度，对于出度，需要遍历顶点表结点所对应的边表；对于入度，则需要遍历剩下的全部边表。

17. A

邻接多重表是无向图的存储结构。

18. B

十字链表是有向图的存储结构。

19. C

邻接矩阵  $A$  为非对称矩阵，说明图是有向图，度为入度与出度之和。各顶点的度是矩阵中此结点对应的行（对应出度）和列（对应入度）的非零元素之和。

20. B

在邻接多重表中，统计一个结点的入度、出度或度数（入度  $+$  出度）时，只需考虑所有的边结点。下图是邻接多重表的边结点的结构：

<table><tr><td>ivex</td><td>ilink</td><td>jvex</td><td>jlink</td><td>info</td></tr></table>

其中，ivex表示弧头的编号，ilink域指向下一个弧头相同的边结点，jvex表示弧尾的编号，jlink域指向下一个弧尾相同的边结点。根据定义可知：求  $x$  号结点的入度时，只需统计jvex域等于  $x$  的边结点个数；求  $x$  号结点的出度时，只需统计ivex域等于  $x$  的边结点个数； $x$  号结点的度数为入度和出度之和。顶点  $b$  的编号为1，统计可知：入度为1，出度为1，度数为2。顶点  $d$  的编号为3，统计可知：入度为1，出度为3，度数为4。

# 二、综合应用题

01.【解答】

带权有向图  $G$  如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c690e8e65f3f294f460f36c13afd33dc0a9e4142b91748102d9f80ac1768dd27.jpg)


02.【解答】

其邻接矩阵存储如下所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d15b83d13db9931d9683b8e520a8a1ed23d2cdf836e9244be1a64bae8ef54878.jpg)


在邻接表中，每条边存储了2次，在没有特殊说明时，通常默认其为无向图（当然，无向

图也可视为具有对边的有向图)。该邻接表对应的图  $G$  如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/220e1b52c5e8bce23d708efc35dd721c170969614ec982fb29c6f844a7c6061b.jpg)


# 03.【解答】

1）对于邻接矩阵表示的无向图，边数等于矩阵中1的个数除以2；对于邻接表表示的无向图，边数等于边结点的个数除以2。对于邻接矩阵表示的有向图，边数等于矩阵中1的个数；对于邻接表表示的有向图，边数等于边结点的个数。

2）在邻接矩阵表示的无向图或有向图中，对于任意两个顶点  $i$  和  $j$  ，邻接矩阵中  $\operatorname{arcs}[i][j]$  或  $\operatorname{arcs}[j][i]$  为1表示有边相连，否则表示无边相连。在邻接表表示的无向图或有向图中，对于任意两个顶点  $i$  和  $j$  ，若从顶点表结点  $i$  出发找到编号为  $j$  的边表结点或从顶点表结点  $j$  出发找到编号为  $i$  的边表结点，表示有边相连；否则为无边相连。

3）对于邻接矩阵表示的无向图，顶点  $i$  的度等于第  $i$  行中1的个数；对于邻接矩阵表示的有向图，顶点  $i$  的出度等于第  $i$  行中1的个数；入度等于第  $i$  列中1的个数；度数等于它们的和。对于邻接表表示的无向图，顶点  $i$  的度等于顶点表结点  $i$  的单链表中边表结点的个数；对于邻接表表示的有向图，顶点  $i$  的出度等于顶点表结点  $i$  的单链表中边表结点的个数，顶点  $i$  的入度等于邻接表中所有编号为  $i$  的边表结点数；度数等于入度与出度之和。

# 04.【解答】

按各顶点的出度进行排序。  $n$  个顶点的有向图，其顶点的最大出度是  $n - 1$  ，最小出度为0。这样排序后，出度最大的顶点编号为1，出度最小的顶点编号为  $n$  。之后，进行调整，即只要存在弧  $\langle i,j\rangle$  ，就不管顶点  $j$  的出度是否大于顶点  $i$  的出度，都把  $i$  编号在顶点  $j$  的编号之前，因为只有  $i\leqslant j$  ，弧  $\langle i,j\rangle$  对应的1才能出现在邻接矩阵的上三角。

通过后面小节的学习，会发现采用拓扑排序并依次编号是一种更为简便的方法。

# 05.【解答】

算法思想：设图的顶点分别存储在数组  $\mathsf{v}[\mathsf{n}]$  中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点  $\mathsf{v}[\mathsf{i}]$  的边链表时，修改邻接矩阵的第  $\mathsf{i}$  行的元素值。若链表边结点的值为  $\mathsf{j}$ ，则置  $\operatorname{arcs}[i][j] = 1$  。遍历完邻接表时，整个转换过程结束。此算法对于无向图、有向图均适用。

算法的实现如下：

```cpp
void Convert(ALGraph &G, int arcs[M][N]) {
//此算法将邻接表方式表示的图G转换为邻接矩阵 arcs
for (i = 0; i < n; i++) {
    p = (G->v[i]).firstarc; //依次遍历各顶点表结点为头的边链表
    while (p != NULL) {
        arcs[i][p->adjvex] = 1;
        p = p->nextarc; //取下一条出边
    }
}
```

# 06.【解答】

考查图的邻接矩阵的性质。

1）图  $G$  的邻接矩阵  $\mathbf{A}$  如下：

$$
\boldsymbol {A} = \left[ \begin{array}{c c c c c} 0 & 1 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 & 1 \\ 1 & 0 & 0 & 1 & 0 \\ 0 & 1 & 1 & 0 & 1 \\ 1 & 1 & 0 & 1 & 0 \end{array} \right]
$$

2）  $A^2$  如下：

$$
\boldsymbol {A} ^ {2} = \left[ \begin{array}{c c c c c} 3 & 1 & 0 & 3 & 1 \\ 1 & 3 & 2 & 1 & 2 \\ 0 & 2 & 2 & 0 & 2 \\ 3 & 1 & 0 & 3 & 1 \\ 1 & 2 & 2 & 1 & 3 \end{array} \right]
$$

0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条。

3）  $B^{m}$  （  $2\leqslant m\leqslant n$  ）中位于  $i$  行  $j$  列（  $0\leqslant i,j\leqslant n - 1$  ）的非零元素的含义是，图中从顶点  $i$  到顶点  $j$  的长度为  $m$  的路径条数。

# 07.【解答】

# 1）算法的基本设计思想：

本算法题属于送分题，题干已经告诉我们算法的思想。对于采用邻接矩阵存储的无向图，在邻接矩阵的每一行（列）中，非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图  $G$  中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。

2）算法实现

```javascript
int IsExistEL(MGraph G) { //采用邻接矩阵存储，判断图是否存在EL路径 int degree,i,j,count  $= 0$  · for  $(\mathrm{i} = 0;\mathrm{i} <   \mathrm{G}.$  numVertices;i++) { degree  $= 0$  · for  $(j = 0;j <   G$  .numVertices;j++) degree  $+ = G$  .Edge[i][j]； //依次计算各个顶点的度 if (degree%2!=0) count++; //对度为奇数的顶点计数 } if(count  $= = 0||$  count  $= = 2$  1 return 1; //存在EL路径，返回1 else return 0; //不存在EL路径，返回0   
1
```

# 3）时间复杂度和空间复杂度

算法需要遍历整个邻接矩阵，所以时间复杂度是  $O(n^{2})$  ，空间复杂度是  $O(1)$  。

# 08.【解答】

# 1）算法的基本设计思想：

采用邻接矩阵表示有向图时，一行中1的个数为该行对应顶点的出度，一列中1的个数为该列对应顶点的入度。使用一个初值为零的计数器记录K顶点的个数。对图G的每个顶点，根据邻接矩阵计算其出度outdegree和入度 indegree。若outdegree-indegree  $>0$  ，则输出该顶点且计数器加1。最后返回计数器的值。

# 2）用C语言描述的算法：

```c
int printVertices(MGraph G) {  
//采用邻接矩阵存储，输出K顶点，返回个数  
int indegree, outdegree, k, m, count = 0;  
for (k = 0; k < G.numVertices; k++) {
```

```c
indegree = outdegree = 0;
for (m = 0; m < G.numVertices; m++) //计算顶点的出度
outdegree += G.Eddge[k][m];
for (m = 0; m < G.numVertices; m++) //计算顶点的入度
indegree += G.Eddge[m][k];
if (outdegree > indegree) {
printf("%c", G.VerticesList[k]);
count++;
}
}
return count; //返回K顶点的个数
```

# 6.3 图的遍历

图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次，且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

图的遍历比树的遍历要复杂得多，因为图的任意一个顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 visited[] 来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。

# 6.3.1 广度优先搜索

广度优先搜索（Breadth-First-Search, BFS）类似于树的层序遍历。基本思想是：首先访问起始顶点  $\mathbf{v}$ ，接着由  $\mathbf{v}$  出发，依次访问  $\mathbf{v}$  的各个未访问过的邻接顶点  $w_{1}, w_{2}, \dots, w_{i}$ ，然后依次访问  $w_{1}, w_{2}, \dots, w_{i}$  的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra单源最短路径算法和 Prim 最小生成树算法也应用了类似的思想。

换句话说，广度优先搜索遍历图的过程是以  $\nu$  为起始点，由近至远依次访问和  $\nu$  有路径相通且路径长度为  $1,2,\dots$  的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。

广度优先搜索算法的伪代码如下：

```c
bool visited [MAXVertexX_NUM]; //访问标记数组  
void BFSTraverse (Graph G) { //对图G进行广度优先遍历  
    for (i = 0; i < G.vexnum; ++i)  
        visited[i] = FALSE; //访问标记数组初始化  
    InitQueue(Q); //初始化辅助队列Q  
    for (i = 0; i < G.vexnum; ++i) //从0号顶点开始遍历  
        if (!visited[i]) //对每个连通分量调用一次BFS()  
            BFS(G, i); //若  $v_i$  未访问过，从  $v_i$  开始调用BFS()  
}
```

用邻接表实现广度优先搜索的算法如下：

```c
void BFS(ALGraph G, int i) {
```

```javascript
visit(i); //访问初始顶点i  
visited[i]  $\equiv$  TRUE; //对i做已访问标记  
EnQueue(Q,i); //顶点i入队  
while(!IsEmpty(Q)){DeQueue(Q,v); //队首顶点v出队for(p=G竖 vertices[v].firstarc;p:p->nextarc){//检测v的所有邻接点w=p->adjvex;if(visited[w] == FALSE) {visit(w); //w为v的尚未访问的邻接点，访问wvisited[w]=TRUE; //对w做已访问标记EnQueue(Q,w); //顶点w入队}11
```

用邻接矩阵实现广度优先搜索的算法如下：

```txt
void BFS(MGraph G, int i) {
    visit(i); //访问初始顶点i
    visited[i] = TRUE; //对i做已访问标记
    EnQueue(Q, i); //顶点i入队
    while (!isEmpty(Q)) {
        DeQueue(Q, v); //队首顶点v出队
        for (w = 0; w < G.vexnum; w++) //检测v的所有邻接点
            if (visited[w] == FALSE && G(edge[v][w] == 1) {
                visit(w); //w为v的尚未访问的邻接点，访问w
                visited[w] = TRUE; //对w做已访问标记
                EnQueue(Q, w); //顶点w入队
            }
        }
}
```

辅助数组 visited[] 标志顶点是否被访问过，其初始状态为 FALSE。在图的遍历过程中，一旦某个顶点  $v_{i}$  被访问，就立即置 visited[i] 为 TRUE，防止它被多次访问。

# 命题追踪 广度优先遍历的过程（2013）

下面通过实例演示广度优先搜索的过程，给定图  $G$  如图6.11所示。假设从顶点  $a$  开始访问， $a$  先入队。此时队列非空，取出队头元素  $a$ ，因为  $b, c$  与  $a$  邻接且未被访问过，于是依次访问  $b, c$ ，并将  $b, c$  依次入队。队列非空，取出队头元素  $b$ ，依次访问与  $b$  邻接且未被访问的顶点  $d, e$ ，并将  $d, e$  入队（注意： $a$  与  $b$  也邻接，但  $a$  已置访问标记，所以不再重复访问）。此时队列非空，取出队头元素  $c$ ，访问与  $c$  邻接且未被访问的顶点  $f, g$ ，并将  $f, g$  入队。此时，取出队头元素  $d$ ，但与  $d$  邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素  $e$ ，将  $h$  入队列……最终取出队头元素  $h$  后，队列为空，从而循环自动跳出。遍历结果为abcdefgh。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a63cbb16974fc4139cd011b3183fed923e16cc175322a80ade20dc76c33f9082.jpg)



图6.11 一个无向图  $G$


从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。

# 1. BFS算法的性能分析

无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列  $Q$  ， $n$  个顶点均需入队一次，在最坏的情况下，空间复杂度为  $O(|V|)$  。

# 命题追踪 基于邻接表存储的BFS的效率（2012）

遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为  $O(|V|)$ ，在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为  $O(|E|)$ ，总的时间复杂度为  $O(|V| + |E|)$ 。采用邻接矩阵存储时，查找每个顶点的邻接点所需的时间为  $O(|V|)$ ，总时间复杂度为  $O(|V|^2)$ 。

# 2. BFS算法求解单源最短路径问题

若图  $G = (V,E)$  为非带权图，定义从顶点  $\mathcal{U}$  到顶点  $\nu$  的最短路径  $d(u,v)$  为从  $\mathcal{U}$  到  $\nu$  的任何路径中最少的边数；若从  $\mathcal{U}$  到  $\nu$  没有通路，则  $d(u,\nu) = \infty$  。

使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。

BFS算法求解单源最短路径问题的算法如下：

```javascript
void BFS_MIN_Distance(Graph G,int u){ //d[i]表示从u到i结点的最短路径 for  $(\mathrm{i} = 0;\mathrm{i} <   \mathrm{G}.vexnum; + + \mathrm{i})$  d[i]  $= \infty$  //初始化路径长度 visited[u]=TRUE;d[u]=0; EnQueue(Q,u); while(!isEmpty(Q)){ //BFS算法主过程 DeQueue(Q,u); //队头元素u出队 for(w=FirstNeighbor(G,u)；w  $> = 0$  w=NextNeighbor(G,u,w)) if(!visited[w]){ //w为u的尚未访问的邻接顶点 visited[w]=TRUE; //设已访问标记 d[w]=d[u]+1; //路径长度加1 EnQueue(Q,w); //顶点w入队 } }
```

# 3. 广度优先生成树

在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6b9fecdce8dad7674c9e7e2ba05daeb46c0535a596e272691d95425162183a1f.jpg)



图6.12 图的广度优先生成树


# 6.3.2 深度优先搜索

与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。

它的基本思想如下：首先访问图中某一起始顶点  $v$ ，然后由  $v$  出发，访问与  $v$  邻接且未被访问的任意一个顶点  $w_{1}$ ，再访问与  $w_{1}$  邻接且未被访问的任意一个顶点  $w_{2}$ ……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。

一般情况下，其递归形式的算法十分简洁，算法过程如下：

```c
bool visited [MAXVERTEX_NUM]; //访问标记数组  
void DFStraverse (Graph G) { //对图G进行深度优先遍历  
for (i = 0; i < G.vexnum; i++)  
    visited[i] = FALSE; //初始化已访问标记数组  
for (i = 0; i < G.vexnum; i++)  
    if (!visited[i])  
        DFS(G, i);  
}
```

用邻接表实现深度优先搜索的算法如下：

```c
void DFS(ALGraph G,int i){ visit(i); //访问初始顶点i visited[i]  $\equiv$  TRUE; //对i做已访问标记 for(p=G竖 vertices[i].firstarc;p:p->nextarc）{//检测i的所有邻接点 j=p->adjvex; if(visited[j] == FALSE) DFS(G,j); //j为i的尚未访问的邻接点，递归访问j }
```

用邻接矩阵实现深度优先搜索的算法如下：

```javascript
void DFS(MGraph G,int i){ visit(i); //访问初始顶点i visited[i]  $\equiv$  TRUE; //对i做已访问标记 for  $(\mathrm{j} = 0;\mathrm{j} <   \mathrm{G}.vexnum;\mathrm{j} + + )$  { //检测i的所有邻接点 if(visited[j]  $\equiv$  FALSE&&G(edge[i][j]  $\equiv = 1$  DFS(G,j); //j为i的尚未访问的邻接点，递归访问j }
```

# 命题追踪 深度优先遍历的过程（2015、2016）

以图6.11的无向图为例，深度优先搜索的过程：首先访问  $a$  ，并置  $a$  访问标记；然后访问与  $a$  邻接且未被访问的顶点  $b$  ，置  $b$  访问标记；然后访问与  $b$  邻接且未被访问的顶点  $d$  ，置  $d$  访问标记。此时  $d$  已没有未被访问过的邻接点，所以返回上一个访问的顶点  $b$  ，访问与其邻接且未被访问的顶点  $e$  ，置  $e$  访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。

# 注意

图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得到的DFS序列和BFS序列是不唯一的。

# 1. DFS算法的性能分析

DFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为  $O(|V|)$ 。

遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为  $O(|V|^2)$  。采用邻接表存储时，总的时间复杂度为  $O(|V| + |E|)$  。

# 2. 深度优先的生成树和生成森林

与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/78101481c52762ffffe88fe8af69b754b187321561dc92258dbdc60cb1a36ba2.jpg)



图6.13 图的深度优先生成森林


# 6.3.3 图的遍历与图的连通性

图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。

因此，在BFSTraverse()或DFSTraverse()中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS(G,i)或DFS(G,i)的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G,i)或DFS(G,i)不一定能访问到该子图的所有顶点，如图6.14所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2cf921b1ef273317c5f66cca01239d0ef26386c94d9c057592e6477fb894e9d7.jpg)



图6.14 有向图的非强连通分量


# 6.3.4 本节试题精选

# 一、单项选择题

01. 下列关于广度优先算法的说法中，正确的是（）。

I. 当各边的权值相等时，广度优先算法可以解决单源最短路径问题

II. 当各边的权值不等时，广度优先算法可用来解决单源最短路径问题

III. 广度优先遍历算法类似于树中的后序遍历算法

IV. 实现图的广度优先算法时，使用的数据结构是队列

A. I、IV

B. II、III、IV

C. II、IV

D. I、III、IV

02. 下列关于图的说法中，错误的是（）。

I. 对一个无向图进行深度优先遍历时，得到的深度优先遍历序列是唯一的

II. 若有向图不存在回路，即使不用访问标志位，同一结点也不会被访问两次

III. 采用深度优先遍历或拓扑排序算法可以判断一个有向图中是否有环（回路）

IV. 对任何非强连通图必须 2 次或以上调用广度优先遍历算法才可访问所有的顶点

A. I、II、III

B. II、III

C. I、II

D. I、II、IV

03. 对于一个非连通无向图  $G$ ，采用深度优先遍历访问所有顶点，在DFSTraverse函数（见考点讲解DFS部分）中调用DFS的次数正好等于（）。

A. 顶点数

B. 边数

C. 连通分量数

D. 不确定

04. 对一个有  $n$  个顶点、  $e$  条边的图采用邻接表表示时，进行 DFS 遍历的时间复杂度为（），空间复杂度为（）；进行 BFS 遍历的时间复杂度为（），空间复杂度为（）。

A.  $O(n)$

B.  $O(e)$

C.  $O(n + e)$

D.  $O(1)$

05. 图的广度优先遍历算法中使用队列作为其辅助数据结构，那么在算法执行过程中，每个顶点的入队次数最多为（）。

A. 1

B. 2

C. 3

D. 4

06. 对有  $n$  个顶点、  $e$  条边的图采用邻接矩阵表示时，进行 DFS 遍历的时间复杂度为（），进行 BFS 遍历的时间复杂度为（）。

A.  $O(n^{2})$

B.  $O(e)$

C.  $O(n + e)$

D.  $O(e^{2})$

07. 无向图  $G = (V, E)$ ，其中  $V = \{a, b, c, d, e, f\}$ ， $E = \{(a, b), (a, e), (a, c), (b, e), (c, f), (f, d), (e, d)\}$ ，对该图从  $a$  开始进行深度优先遍历，得到的顶点序列正确的是（）。

A.  $a, b, e, c, d, f$

B.  $a, c, f, e, b, d$

C.  $a, e, b, c, f, d$

D.  $a, e, d, f, c, b$

08. 如下图所示，在下面的5个序列中，符合深度优先遍历的序列个数是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fadbaddd734c59869e7dfa4f0ba4fa16767554020d806e6956598f341690cee9.jpg)


1. aebfdc 2. acfdeb 3. aedfcb 4. aefdbc 5. aecfdb

A. 5

B. 4

C. 3

D. 2

09. 用邻接表存储的图的深度优先遍历算法类似于树的（），而其广度优先遍历算法类似于树的（）。

A. 中序遍历

B. 先序遍历

C. 后序遍历

D. 按层次遍历

10. 一个有向图  $G$  的邻接表存储如下图所示，从顶点1出发，对图  $G$  调用深度优先遍历所得顶点序列是（）；按广度优先遍历所得顶点序列是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f08bbdda1f8acd76b170d3a1d18c92e6228ee8d39185bcc9836d5b1c043032a1.jpg)


A. 125436

B. 124536

C. 124563

D. 362514

11. 无向图  $G = (V, E)$ ，其中  $V = \{a, b, c, d, e, f\}$ ， $E = \{(a, b), (a, e), (a, c), (b, e), (c, f), (f, d), (e, d)\}$ 。对该图进行深度优先遍历，不能得到的序列是（）。

A. acfdeb

B. aebdfc

C. aedfcb

D. abecdf

12. 判断有向图中是否存在回路，除拓扑排序外，还可以利用（）。（注：涉及下节内容）

A. 求关键路径的方法

B. 求最短路径的 Dijkstra 算法

C. 深度优先遍历算法

D. 广度优先遍历算法

13. 设无向图  $G = (V, E)$  和  $G' = (V', E')$ ，若  $G'$  是  $G$  的生成树，则下列说法错误的是（）。

A.  $G'$  为  $G$  的子图

B.  $G'$  为  $G$  的连通分量

C.  $G'$  为  $G$  的极小连通子图且  $V = V'$

D.  $G'$  是  $G$  的一个无环子图

14. 图的广度优先生成树的树高比深度优先生成树的树高（）。

A. 小或相等

B. 小

C. 大或相等

D. 大

15.【2012统考真题】对有  $n$  个顶点、  $e$  条边且使用邻接表存储的有向图进行广度优先遍历，其算法的时间复杂度是（）。

A.  $O(n)$

B.  $O(e)$

C.  $O(n + e)$

D.  $O(n e)$

16.【2013统考真题】下列选项中，不是如下无向图的广度优先遍历序列的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5f7db0203e4f6f8b6b90c20b45e85ebaf1dc262d3a3530af9c971236e3e0dcf6.jpg)


A.  $h, c, a, b, d, e, g, f$

B.  $e, a, f, g, b, h, c, d$

C.  $d, b, c, a, h, e, f, g$

D.  $a, b, c, d, h, e, f, g$

17.【2015统考真题】设有向图  $G = (V,E)$  ，顶点集  $V = \{V_0,V_1,V_2,V_3\}$  ，边集  $E = \{\langle v_0,v_1\rangle ,$ $\langle v_{0},v_{2}\rangle ,\langle v_{0},v_{3}\rangle ,\langle v_{1},v_{3}\rangle \}$  。若从顶点  $V_{0}$  开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是（）。

A. 2

B. 3

C. 4

D. 5

18.【2016统考真题】下列选项中，不是下图深度优先搜索序列的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4ca9499eda06396f2400f919ac68051558c2fccd9386d375efd90b289354c48a.jpg)


A.  $V_{1}, V_{5}, V_{4}, V_{3}, V_{2}$

B.  $V_{1}, V_{3}, V_{2}, V_{5}, V_{4}$

C.  $V_{1}, V_{2}, V_{5}, V_{4}, V_{3}$

D.  $V_{1}, V_{2}, V_{3}, V_{4}, V_{5}$

# 二、综合应用题

01. 图  $G = (V, E)$  以邻接表存储，如下图所示，试画出图  $G$  的深度优先生成树和广度优先生成树（假设从结点1开始遍历）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0df6e3bfa94799b3545f1278cd50b69d23942627ed38bef4f6bb14de961832b0.jpg)


02. 给定一个连通无向图，采用邻接表存储，将图的所有顶点分别染成红色或蓝色，若存在一种染色方法使图中每条边的两个顶点的颜色都不相同，则称这个图能被二分。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6b115893da8c0589b9fa51afdecdc62a7c8cd81236d3c8b7d772857c6bd37c50.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/77563aff0b560097dc38c938d119a33008c1da8eea761e6d89e05934c651dd97.jpg)


1）判断上面两个无向图是否能被二分，若能被二分，则请标出每个顶点的颜色。

2）请设计一种算法用来判断图是否能被二分，仅用语言描述算法的思想即可。

3）给出你设计的算法的时间复杂度和空间复杂度。

03. 试设计一个算法，判断一个无向图  $G$  是否为一棵树。若是一棵树，则算法返回 true，否则返回 false。

04. 分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表方式存储的有向图中是否存在由顶点  $v_{i}$  到顶点  $v_{j}$  的路径  $(i \neq j)$ 。注意，算法中涉及的图的基本操作必须在此存储结构上实现。

05. 假设图用邻接表表示，设计一个算法，输出从顶点  $V_{i}$  到顶点  $V_{j}$  的所有简单路径。

# 6.3.5 答案与解析

# 一、单项选择题

# 01. A

广度优先搜索以起始结点为中心，一层一层地向外层扩展遍历图的顶点，因此无法考虑到边权值，只适合求边权值相等的图的单源最短路径。广度优先搜索相当于树的层序遍历，选项III错误。广度优先搜索需要用到队列，深度优先搜索需要用到栈，选项IV正确。

# 02. D

图的深度优先遍历序列通常是不唯一的，选项I错误。图1是一个不存在回路的有向图，从顶点1开始执行广度优先遍历，若不设置访问标志位，则会重复访问顶点3，选项II错误。深度优先遍历（见本节后面习题的解析）或拓扑排序算法可以判断有向图中是否有环，选项III正确。图2是一个非强连通图，但从顶点1开始调用一次广度优先遍历算法就可访问所有顶点，选项IV错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3938f18f58bde943200d35e089b14318e563742be31648ba7a7c89aaac35c745.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a09983c0aaa8bced47de693e9f0a31eee3a8f756fd67673e930cf8c3821397e9.jpg)



图2


03. C

DFS（或BFS）可用来计算无向图的连通分量数，因为一次遍历必然会将一个连通图中的所有顶点都访问到，所以计算图的连通分量数正好是DFSTraverse()中DFS被调用的次数。

# 04. C、A、C、A

深度优先遍历时，每个顶点表结点和每个边表结点均查找一次，每个顶点递归调用一次，需要借助一个递归工作栈；而广度优先遍历时，也是每个顶点表结点和每个边表结点均查找一次，需要借助一个辅助队列。因此，时间复杂度都是  $O(n + e)$ ，空间复杂度都是  $O(n)$ 。

# 05. A

在图的广度优先遍历算法中，每个顶点被访问后立即做访问标记并入队。若队列不空，则队首顶点出队，若该顶点的邻接顶点未被访问，则访问之，做访问标记并入队；若被访问过，则跳过，如此反复，直至队空。因此，在广度优先遍历过程中，每个顶点最多入队一次。

# 06. A、A

采用邻接矩阵表示时，查找一个顶点所有出边的时间复杂度为  $O(n)$ ，共有  $n$  个顶点，所以时间复杂度均为  $O(n^{2})$ 。

# 07. D

画出草图后，此类题可以根据边的邻接关系快速排除错误选项。以选项A为例，在遍历到 $e$  之后，应该访问与  $e$  邻接但未被访问的结点，  $(e,c)$  显然不在边集中。

# 08. D

仅1和4正确。以2为例，遍历到  $c$  之后，与  $c$  邻接且未被访问的结点为空集，所以应为  $a$  的邻接点  $b$  或  $e$  入栈。以3为例，因为遍历要按栈退回，所以是先  $b$  后  $c$  ，而不能先  $c$  后  $b$  。

# 09. B、D

图的深度优先搜索类似于树的先根遍历，即先访问结点，再递归向外层结点遍历，都采用回溯算法。图的广度优先搜索类似于树的层序遍历，即一层一层向外层扩展遍历，都需要采用队列来辅助算法的实现。

# 10. A、B

DFS序列产生的路径为  $<1,2>, <2,5>, <5,4>, <3,6>$ ；BFS序列产生的路径为  $<1,2>, <1,4>, <2,5>, <3,6>$ 。

# 11. D

画出  $V$  和  $E$  对应的图  $G$  ，然后根据搜索算法求解。

# 注意

为什么本题序列是不唯一的，而上题序列却是唯一的呢？

因为上题给出了具体的存储结构，此时就必须按照算法的过程来执行，每个顶点的邻接点的顺序已固定，但本题中每个顶点的邻接点的顺序是非固定的。

# 12. C

利用深度优先遍历可以判断图  $G$  中是否存在回路。

对于无向图来说，若深度优先遍历过程中遇到了回边，则必定存在环；对于有向图来说，这条回边可能是指向深度优先森林中另一棵生成树上的顶点的弧；但是，从有向图的某个顶点  $v$  出发进行深度优先遍历时，若在 DFS(v) 结束之前出现一条从顶点  $u$  到顶点  $v$  的回边，且  $u$  在生成树上是  $v$  的子孙，则有向图必定存在包含顶点  $v$  和顶点  $u$  的环。

# 13. B

连通分量是无向图的极大连通子图，其中极大的含义是将依附于连通分量中顶点的所有边都加上，所以连通分量中可能存在回路，这样就不是生成树了。

# 注意

极大连通子图是无向图（不一定连通）的连通分量，极小连通子图是连通无向图的生成树。极小和极大是在满足连通的前提下，针对边的数目而言的。极大连通子图包含连通分量的全部边；极小连通子图（生成树）包含连通图的全部顶点，且使其连通的边数最少。

# 14. A

对于无向图的广度优先搜索生成树，起点到其他顶点的路径是图中对应的最短路径，即所有生成树中树高最小。此外，深度优先总是尽可能“深”地搜索图，因此其路径也尽可能长，所以深度优先生成树的树高总是大于或等于广度优先生成树的树高。

# 15. C

广度优先遍历需要借助队列实现。采用邻接表存储方式对图进行广度优先遍历时，每个顶点均需入队一次（顶点表遍历)，所以时间复杂度为  $O(n)$  ，在搜索所有顶点的邻接点的过程中，每条边至少访问一次（出边表遍历)，所以时间复杂度为  $O(e)$  ，算法总的时间复杂度为  $O(n + e)$  。

# 16. D

只要掌握DFS和BFS的遍历过程，便能轻易解决。逐个代入，手工模拟，选项D是深度优先遍历，而不是广度优先遍历。

# 17. D

画出该有向图，如下图所示。采用图的深度优先遍历，共有5种可能：  $\langle v_0,v_1,v_3,v_2\rangle ,\langle v_0,v_2,$

$$
v _ {3}, v _ {1} >, <   v _ {0}, v _ {2}, v _ {1}, v _ {3} >, <   v _ {0}, v _ {3}, v _ {2}, v _ {1} >, <   v _ {0}, v _ {3}, v _ {1}, v _ {2} > 。
$$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/47df249b4344615a562c044038724fefaaad51113b6dc0e55bbbfd096463d6f2.jpg)


# 18. D

按深度优先遍历的策略进行遍历。对于选项A：先访问  $V_{1}$ ，然后访问与  $V_{1}$  邻接且未被访问的任意一个顶点（满足的有  $V_{2}, V_{3}$  和  $V_{5}$ ），此时访问  $V_{5}$ ，然后从  $V_{5}$  出发，访问与  $V_{5}$  邻接且未被访问的任意一个顶点（满足的只有  $V_{4}$ ），然后从  $V_{4}$  出发，访问与  $V_{4}$  邻接且未被访问的任意一个顶点（满足的只有  $V_{3}$ ），然后从  $V_{3}$  出发，访问与  $V_{3}$  邻接且未被访问的任意一个顶点（满足的只有  $V_{2}$ ），结束遍历。选项B和C的分析方法与A相同。对于选项D，首先访问  $V_{1}$ ，然后从  $V_{1}$  出发，访问与  $V_{1}$  邻接且未被访问的任意一个顶点（满足的有  $V_{2}, V_{3}$  和  $V_{5}$ ），然后从  $V_{2}$  出发，访问与  $V_{2}$  邻接且未被访问的任意一个顶点（满足的只有  $V_{5}$ ），按规则本应该访问  $V_{5}$ ，但选项D却访问了  $V_{3}$ ，错误。

# 二、综合应用题

# 01.【解答】

根据  $G$  的邻接表不难画出图(a)。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/68e14cdc9a2f6f2e8ffced9857970605baadb613a5064be81899fd6bb19eb01c.jpg)



(a) 图  $G$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ba9a02bdf86c704ce421d5ff0d728946eea0d7995b72bc8721fde6d64445e91a.jpg)



(b) 深度优先生成树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b428e3a81413b14ba762a55c6aff33318a620ba8889f0210925af7bf39f1d8be.jpg)



(c)广度优先生成树


1）采用深度优先遍历。深度优先搜索总是尽可能“深”地搜索图，根据存储结构可知深度优先搜索的路径次序为(1,2),(2,3),(3,4),(4,5)，深度优先生成树如图(b)所示。需要注意的是，当存储结构固定时，生成树的树形也就固定了，比如不能先搜索(1,3)。

2）采用广度优先遍历。广度优先搜索总是尽可能“广”地搜索图，一层一层地向外扩展，根据存储结构可知广度优先搜索的路径次序为(1,2), (1,3), (1,4), (2,5)，广度优先生成树如图(c)所示。

# 02.【解答】

1）右图不能被二分，左图能被二分，染色情况如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cc0ea9450332a8257417c77dd90f759a3518da431770b3ee8d9835a3773dbebe.jpg)


2）从任意一个结点开始，将其染成红色，并从该结点开始对整个图进行遍历，在遍历过程中，若当前遍历的结点  $a$  有一条边指向  $b$  ，则可能出现三种情况：①  $b$  未被染色，将它染成与结点  $a$  不同的颜色，并且继续遍历与  $b$  相连的结点；②  $a$  与  $b$  的颜色相同，说明该图不能被二分，直接返回；③  $a$  与  $b$  的颜色不同，跳过  $b$  点。

3）上述遍历无论是使用深度优先还是使用广度优先，时间复杂度都为  $O(n + m)$ ，其中的  $n$  和  $m$  分别是顶点数和边数。需要一个数组来存储各结点的颜色及是否已访问，空间复杂度为  $O(n)$ 。

# 03. 【解答】

一个无向图  $G$  是一棵树的条件是， $G$  必须是无回路的连通图或有  $n - 1$  条边的连通图。这里采用后者作为判断条件。对连通的判定，可以用能否一次遍历全部顶点来实现。可以采用深度优先搜索算法在遍历图的过程中统计可能访问到的顶点个数和边的条数，若一次遍历就能访问到  $n$  个顶点和  $n - 1$  条边，则可断定此图是一棵树。算法实现如下：

```txt
bool isTree(Graph& G){ for  $(i = 1;i <   = G.$  vexnum;  $i + + )$  visited[i]  $\equiv$  FALSE; //访问标记visited[]初始化 int Vnum  $\equiv 0$  ，Enum  $\equiv 0$  //记录顶点数和边数 DFS(G,1,Vnum,Enum,visited); if(Vnum  $\equiv = G$  .vexnum&&Enum  $\equiv = 2^{\star}$  (G.vexnum-1)) return true; //符合树的条件 else return false; //不符合树的条件 } void DFS(Graph& G,int v,int& Vnum,int& Enum,int visited[]){ //深度优先遍历图G，统计访问过的顶点数和边数，通过Vnum和Enum返回 visited[v]  $\equiv$  TRUE;Vnum++; //作访问标记，顶点计数 int w=FirstNeighbor(G,v); //取  $\mathbf{v}$  的第一个邻接顶点 while(w!=-1){ //当邻接顶点存在 Enum++; //边存在，边计数 if(!visited[w]) //当该邻接顶点未访问过 DFS(G,w,Vnum,Enum,visited); w=NextNeighbor(G,v,w); }
```

# 04.【解答】

两个不同的遍历算法都采用从顶点  $\nu_{i}$  出发，依次遍历图中每个顶点，直到搜索到顶点  $\nu_{j}$ ，若能够搜索到  $\nu_{j}$ ，则说明存在由顶点  $\nu_{i}$  到顶点  $\nu_{j}$  的路径。

深度优先遍历算法的实现如下：

```c
int visited [MAXSIZE] = {0}; //访问标记数组
void DFS (ALGraph G, int i, int j, bool &can_reach) {
//深度优先判断有向图 G 中顶点  $v_{i}$  到顶点  $v_{j}$  是否有路径，用 can_reach 来标识
if (i == j) {
    can_reach = true;
    return; //i 就是 j
}
visited[i] = 1; //置访问标记
for (int p = FirstNeighbor(G, i); p == 0; p = NextNeighbor(G, i, p)) {
    if (!visited[p] && !can_reach) //递归检测邻接点
        DFS(G, p, j, can_reach);
}
```

广度优先遍历算法的实现如下：

```c
int visited [MAXSIZE] = {0}; //访问标记数组  
int BFS (ALGraph G, int i, int j) {  
//广度优先判断有向图 G 中顶点  $v_{i}$  到顶点  $v_{j}$  是否有路径，若是，则返回 1，否则返回 0;  
InitQueue(Q); EnQueue(Q, i); //顶点 i 入队  
while (!isEmpty(Q)) { //非空循环  
    DeQueue(Q, i); //队头顶点出队  
    visited[i] = 1; //置访问标记  
    if (i == j) return 1;  
    for (int p = FirstNeighbor(G, i); p; p = NextNeighbor(G, i, p)) { //检查所有邻接点  
        if (p == j) return 1;  
            if (!visited[p]) { //否则，顶点 p 入队  
                EnQueue(Q, p);  
                visited[p] = 1;  
        }  
    }  
return 0;
```

本题也可以这样解答：调用以  $i$  为参数的DFS(G,i)或BFS(G,i)，执行结束后判断visited[j]是否为TRUE，若是，则说明  $\nu_{j}$  已被遍历，图中必存在由  $\nu_{i}$  到  $\nu_{j}$  的路径。但此种解法每次都耗费最坏时间复杂度对应的时间，需要遍历与  $\nu_{i}$  连通的所有顶点。

# 05.【解答】

本题采用基于递归的深度优先遍历算法，从结点  $\mathbf{u}$  出发，递归深度优先遍历图中结点，若访问到结点  $\mathbf{v}$ ，则输出该搜索路径上的结点。为此，设置一个 path 数组来存放路径上的结点（初始为空），d 表示路径长度（初始为-1）。查找从顶点  $\mathbf{u}$  到  $\mathbf{v}$  的简单路径过程说明如下（假设查找函数名为 FindPath()）：

1）FindPath(G,u,v,path,d):d++;path[d]=u；若找到u的未访问过的相邻结点u1，则继续下去，否则置visited[u]=0并返回。

2）FindPath(G,u1,v,path,d):d++;path[d]=u1；若找到u1的未访问过的相邻结点u2，则继续下去，否则置visited[u1]=0。

3）以此类推，继续上述递归过程，直到  $ui = v$  ，输出path。

算法实现如下：

```txt
void FindPath(agraph *G, int u, int v, int path[], int d) {
```

```txt
int w;   
ArcNode \*p;   
 $\mathrm{d + + }$  //路径长度增1   
path[d]  $\equiv$  u; //将当前顶点添加到路径中   
visited[u]=1; //置已访问标记   
if(u==v) //找到一条路径则输出 print(path[]); //输出路径上的结点   
p=G->adjlist[u].firstarc; //p指向u的第一个相邻点 while(p!=NULL){  $\mathrm{w = p - > adjvex}$  //若顶点w未访问，递归访问它 if(visited[w] == 0) FindPath(G,w,v,path,d);  $\mathrm{p = p - > nextarc}$  //p指向u的下一个相邻点 } visited[u]=0; //恢复环境，使该顶点可重新使用
```

# 6.4 图的应用

本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性偏小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。

# 6.4.1 最小生成树

一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去一条边，则会使生成树变成非连通图；若增加一条边，则会在图中形成一条回路。

对于一个带权连通无向图  $G$  ，生成树不同，每棵树的权（树中所有边的权值之和）也可能不同。权值之和最小的那棵生成树称为  $G$  的最小生成树（Minimum-Spanning-Tree, MST）。

# 命题追踪

# 最小生成树的性质（2012、2017）

公众号：小兔网盘 免费分享无水印PDF

不难看出，最小生成树具有如下性质：

1）若图  $G$  中存在权值相同的边，则  $G$  的最小生成树可能不唯一，即最小生成树的树形不唯一。当图  $G$  中的各边权值互不相等时， $G$  的最小生成树是唯一的；若无向连通图  $G$  的边数比顶点数少1，即  $G$  本身是一棵树时，则  $G$  的最小生成树就是它本身。

2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。

3）最小生成树的边数为顶点数减1。

# 命题追踪

# 最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）

# 注意

最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所示，最小生成树中  $A$  到  $C$  的路径长度为5，但图中  $A$  到  $C$  的最短路径长度为4。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3409eff233e8e4679f833f922677089b60f1e5354c3cedb548c1671d5b183617.jpg)


构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设  $G = (V, E)$  是一个带权连通无向图， $U$  是顶点集  $V$  的一个非空子集。若  $(u, v)$  是一条具有最小权值的边，其中  $u \in U$ ， $v \in V - U$ ，则必存在一棵包含边  $(u, v)$  的最小生成树。

基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能动手模拟算法的实现步骤。

下面介绍一个通用的最小生成树算法：

```winregistry
GENERIC_MST(G){T=NULL;while T未形成一棵生成树；do找到一条最小代价边  $(\mathbf{u},\mathbf{v})$  并且加入T后不会产生回路； $\mathrm{T = T}\cup (\mathrm{u},\mathrm{v})$  ·  
1
```

通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。

# 1. Prim算法

Prim（普里姆）算法的执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）。

# 命题追踪 Prim算法构造最小生成树的实例（2015、2017、2018）

Prim 算法构造最小生成树的过程如图 6.15 所示。初始时从图中任取一顶点（如顶点 1）加入树  $T$ ，此时树中只含有一个顶点，之后选择一个与当前  $T$  中顶点集合距离最近的顶点，并将该顶点和相应的边加入  $T$ ，每次操作后  $T$  中的顶点数和边数都增 1。以此类推，直至图中所有的顶点都并入  $T$ ，得到的  $T$  就是最小生成树。此时  $T$  中必然有  $n - 1$  条边。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/40506ec9f62557aa84c3a50d1f7c79c29a0a38831c0ec2d14cd3732e77ffe2ce.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9a39b8eb95d3b41ab6b066bbb6b3e26e609f60ebd3822dbe1dcd3c60315f9cf0.jpg)



(d)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5c6a0c777d86d8fef8e782de09d032bafd98ab46637bc9c8f9a6f05f579eb061.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dee5437ee545bbc3bb53030b42dd07a010ebc1ea3f96a8493a17d82b85673884.jpg)



(c)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/db27066bedc392af4d0f2a8bc2958b58d2e24a816b12ac47aeb7a38fe4d7f72b.jpg)



(c)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8648fba9c5fe3849d944cd9a4231f808b93e4bb38055985e5378f44695571cbb.jpg)



(f)



图6.15 Prim算法构造最小生成树的过程


Prim算法的步骤如下：

假设  $G = \{V,E\}$  是连通图，其最小生成树  $T = (U,E_T)$ ， $E_{T}$  是最小生成树中边的集合。

初始化：向空树  $T = (U,E_T)$  中添加图  $G = (V,E)$  的任意一个顶点  $u_{0}$ ，使  $U = \{u_0\}$ ， $E_{T} = \varnothing$ 。

循环（重复下列操作直至  $U = V$ ）：从图  $G$  中选择满足  $\{(u, v) | u \in U, v \in V - U\}$  且具有最小权值的边  $(u, v)$ ，加入树  $T$ ，置  $U = U \cup \{v\}$ ， $E_T = E_T \cup \{(u, v)\}$ 。

Prim算法的简单实现如下：

void Prim(G,T){

T=0;

//初始化空树

$\mathrm{U} = \{\mathrm{w}\}$

//添加任意一个顶点w

```txt
while  $((\mathrm{V - U})! = \emptyset)$  //若树中不含全部顶点设  $(\mathbf{u},\mathbf{v})$  是使  $u\in U$  与  $\mathbf{v}\in (\mathbf{V} - \mathbf{U})$  ，且权值最小的边； $\mathrm{T = T\cup\{(u,v)\}}$  //边归入树 $\mathrm{U = U\cup\{v\}}$  //顶点归入树1
```

Prim算法的时间复杂度为  $O(|V|^2)$ ，不依赖于  $|E|$ ，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法能改进Prim算法的时间复杂度，但增加了实现的复杂性。

# 2. Kruskal算法

与 Prim 算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。

# 命题追踪 Kruskal 算法构造最小生成树的实例（2015、2018、2020）

Kruskal 算法构造最小生成树的过程如图 6.16 所示。初始时为只有  $n$  个顶点而无边的非连通图  $T = \{V, \{\}\}$ ，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在  $T$  中不同的连通分量上（使用并查集判断这两个顶点是否属于同一棵集合树），则将此边加入  $T$ ，否则舍弃此边而选择下一条权值最小的边。以此类推，直至  $T$  中所有顶点都在一个连通分量上。

Kruskal 算法的步骤如下：

假设  $G = (V,E)$  是连通图，其最小生成树  $T = (U,E_T)$ 。

初始化：  $U = V,E_{T} = \emptyset$  。即每个顶点构成一棵独立的树，  $T$  此时是一个仅含  $|V|$  个顶点的森林。

循环（重复直至  $T$  是一棵树）：按  $G$  的边的权值递增顺序依次从  $E - E_{T}$  中选择一条边，若这条边加入  $T$  后不构成回路，则将其加入  $E_{T}$ ，否则舍弃，直到  $E_{T}$  中含有  $n - 1$  条边。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/363e57b8208f1d7af26e880a5220405c3169cf3a35841c9f34bd5f5f4bf024f5.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a65ac9341994802239d719c8d652cafae789921a1de8806004f69b6a5286d526.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1d87e5326f3d3f183223bd594a707840a7a27335b27c1557ccdb466f471f8289.jpg)



图6.16 Kruskal算法构造最小生成树的过程


Kruskal 算法的简单实现如下：

```javascript
void Kruskal(V,T){T=V; //初始化树T，仅含顶点numS=n; //连通分量数while(numS>1){//若连通分量数大于1从E中取出权值最小的边(v,u)；if(v和u属于T中不同的连通分量){ $\mathrm{T} = \mathrm{T}\cup \{(v,u)\}$  ； //将此边加入生成树中numS--; //连通分量数减1
```

```txt
}
```

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。

在Kruskal算法中，最坏情况需要对  $|E|$  条边各扫描一次。通常采用堆（见第7章）来存放边的集合，每次选择最小权值的边需要  $O(\log_2|E|)$  的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为  $O(\alpha(|V|))$  ，  $\alpha(|V|)$  的增长极其缓慢，可视为常数。算法的总时间复杂度为  $O(|E|\log_2|E|)$  ，不依赖于  $|V|$  ，因此Kruskal算法适合于边稀疏而顶点较多的图。

# 6.4.2 最短路径

# 命题追踪 最短路径的分析与举例以及相关的算法（2009、2023）

6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点  $v_{0}$  到图中其余任意一个顶点  $v_{i}$  的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图  $G$  的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。

# 1. Dijkstra 算法求单源最短路径问题

Dijkstra算法设置一个集合  $S$  记录已求得的最短路径的顶点，初始时把源点  $\nu_{0}$  放入  $S$  ，集合 $S$  每并入一个新顶点  $\nu_{i}$  ，都要修改源点  $\nu_{0}$  到集合  $V - S$  中顶点当前的最短路径长度值（这里可能不太好理解？没关系，继续往下看，相信会逐步理解）。

在构造的过程中还设置了三个辅助数组：

- final[]：标记各顶点是否已找到最短路径，即是否归入集合  $S$ 。

- dist[]：记录从源点  $v_{0}$  到其他各顶点当前的最短路径长度，它的初始值为：若从  $v_{0}$  到  $v_{i}$  有弧，则dist[i]为弧上的权值；否则置dist[i]为∞。

- path[]：path[i]表示从源点到顶点  $i$  之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点  $\nu_{0}$  到顶点  $\nu_{i}$  的最短路径。

假设从顶点0出发，即  $\nu_{0} = 0$ ，集合  $S$  最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边  $< i,j>$  的权值，若不存在有向边  $< i,j>$ ，则arcs[i][j]为  $\infty$ 。

Dijkstra算法的步骤如下（不考虑对path[]的操作）：

1）初始化：集合  $S$  初始为  $\{0\}$  ，dist[]的初始值dist[i]=arcs[0][i],i=1,2,…,n-1。

2）从顶点集合  $V - S$  中选出  $\nu_{j}$  ，满足dist[j]=Min{dist[i]  $\mid \nu_{i}\in V - S\}$  ，  $\nu_{j}$  就是当前求得的一条从  $\nu_{0}$  出发的最短路径的终点，令  $S = S\cup \{j\}$  。

3）修改从  $\nu_{0}$  出发到集合  $V - S$  上任意一个顶点  $\nu_{k}$  可达的最短路径长度：若dist[j]  $+$  arcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]。

4）重复2）～3）操作共  $n - 1$  次，直到所有的顶点都包含在集合  $S$  中。

步骤3）也就是开头留下的疑问，每当一个顶点加入集合  $S$  后，可能需要修改源点  $\nu_{0}$  到集合  $V - S$  中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为  $\nu_{0}$ ，初始时  $S = \{\nu_{0}\}$ ， $\mathrm{dist}[1] = 3$ ， $\mathrm{dist}[2] = 7$ ，当将  $\nu_{1}$  并入集合  $S$  后， $\mathrm{dist}[2]$  需要更新为4。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/649ddd6874e1cfa000e388d86a9fc4680709e3ed0b36429f5deec875556e69ea.jpg)


思考：Dijkstra 算法与 Prim 算法有何异同之处？①

# 命题追踪 Dijkstra 算法求解最短路径的实例（2012、2014、2016、2021）

例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如表6.2所示。算法执行过程的说明如下。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c1970352d9b2aeac7cb577ff4d1394e6a46ebd6022d56c720b1d786015354fc5.jpg)


每轮得到的最短路径如下：

第1轮：  $1\to 5$  ，路径距离为5

第2轮：  $1\to 5\to 4$  ，路径距离为7

第3轮：  $1\to 5\to 2$  ，路径距离为8

第4轮：  $1\to 5\to 2\to 3$  ，路径距离为9


图6.17 应用Dijkstra算法图



表 6.2 从  $v_{1}$  到各终点的 dist 值和最短路径的求解过程


<table><tr><td>顶点</td><td>第1轮</td><td>第2轮</td><td>第3轮</td><td>第4轮</td></tr><tr><td>2</td><td>10v1→v2</td><td>8v1→v5→v2</td><td>8v1→v5→v2</td><td></td></tr><tr><td>3</td><td>∞</td><td>14v1→v5→v3</td><td>13v1→v5→v4→v3</td><td>9v1→v5→v2→v3</td></tr><tr><td>4</td><td>∞</td><td>7v1→v5→v4</td><td></td><td></td></tr><tr><td>5</td><td>5v1→v5</td><td></td><td></td><td></td></tr><tr><td>集合S</td><td>{1,5}</td><td>{1,5,4}</td><td>{1,5,4,2}</td><td>{1,5,4,2,3}</td></tr></table>

初始化：集合  $S$  初始为  $\{v_1\}$ ， $v_1$  可达  $v_2$  和  $v_3$ ， $v_1$  不可达  $v_3$  和  $v_4$ ，因此 dist[] 数组各元素的初始值依次设置为 dist[2] = 10，dist[3] = \infty，dist[4] = \infty，dist[5] = 5。

第1轮：选出最小值dist[5]，将顶点  $v_{5}$  并入集合  $S$ ，即此时已找到  $v_{1}$  到  $v_{5}$  的最短路径。当  $v_{5}$  加入  $S$  后，从  $v_{1}$  到集合  $V - S$  中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]数组。  $v_{5}$  可达  $v_{2}$ ，因  $v_{1} \rightarrow v_{5} \rightarrow v_{2}$  的距离8比dist[2]=10小，更新dist[2]=8；  $v_{5}$  可达  $v_{3}$ ， $v_{1} \rightarrow v_{5} \rightarrow v_{3}$  的距离14，更新dist[3]=14；  $v_{5}$  可达  $v_{4}$ ， $v_{1} \rightarrow v_{5} \rightarrow v_{4}$  的距离7，更新dist[4]=7。

第2轮：选出最小值dist[4]，将顶点  $\nu_{4}$  并入集合  $S$  。继续更新dist[]数组。 $\nu_{4}$  不可达 $\nu_{2}$ ，dist[2]不变； $\nu_{4}$  可达  $\nu_{3}$ ， $\nu_{1} \rightarrow \nu_{5} \rightarrow \nu_{4} \rightarrow \nu_{3}$  的距离13比dist[3]小，故更新dist[3]=13。

第3轮：选出最小值dist[2]，将顶点  $v_{2}$  并入集合  $S$  。继续更新dist[]数组。  $v_{2}$  可达  $v_{3}$ ，  $v_{1} \rightarrow v_{5} \rightarrow v_{2} \rightarrow v_{3}$  的距离9比dist[3]小，更新dist[3]=9。

第4轮：选出唯一最小值dist[3]，将顶点  $\nu_{3}$  并入集合  $S$  ，此时全部顶点都已包含在  $S$  中。

显然，Dijkstra算法也是基于贪心策略的。

使用邻接矩阵表示时，时间复杂度为  $O(|V|^2)$  。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但因为在dist[]中选择最小分量的时间不变，所以时间复杂度仍为  $O(|V|^2)$  。

人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为  $O(|V|^2)$ 。

注意，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与集合  $S$  （已求得最短路径的顶点集，归入  $S$  内的顶点的最短路径不再变更）内某顶点（记为  $a$  ）以负边相连的顶点（记为  $b$  ）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于  $a$  原先确定的最短路径长度，而此时  $a$  在Dijkstra算法下是无法更新的。例如，对于图6.18所示的带权有向图，利用Dijkstra算法不一定能得到正确的结果。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/595e6386c0b8fcb02b03f1597dae2bc684286cab41088ad70beb396051282049.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8d17e980a1131f63ef4423c841109ce08bfac34286140ed65cbc24bc9f5293b2.jpg)



(b)



图6.18 边上带有负权值的有向带权图


# 2. Floyd算法求各顶点之间最短路径问题

求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对任意两个顶点  $\mathsf{v}_i\neq \mathsf{v}_j$  ，要求求出  $\mathsf{v}_i$  与  $\mathsf{v}_j$  之间的最短路径和最短路径长度。

Floyd算法的基本思想是：递推产生一个  $n$  阶方阵序列  $A^{(-1)}, A^{(0)}, \dots, A^{(k)}, \dots, A^{(n-1)}$ ，其中  $A^{(k)}[i][j]$  表示从顶点  $v_{i}$  到顶点  $v_{j}$  的路径长度， $k$  表示绕行第  $k$  个顶点的运算步骤。初始时，对于任意两个顶点  $v_{i}$  和  $v_{j}$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以  $\infty$  作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点  $k$ （ $k = 0, 1, \dots, n-1$ ）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法描述如下：

定义一个  $n$  阶方阵序列  $A^{(-1)}, A^{(0)}, \dots, A^{(n-1)}$ ，其中，

$$
A ^ {(- 1)} [ i ] [ j ] = \operatorname {a r c s} [ i ] [ j ]
$$

$$
A ^ {(k)} [ i ] [ j ] = \operatorname {M i n} \left\{A ^ {(k - 1)} [ i ] [ j ], \quad A ^ {(k - 1)} [ i ] [ k ] + A ^ {(k - 1)} [ k ] [ j ] \right\}, k = 0, 1, \dots , n - 1
$$

式中，  $A^{(0)}[i][j]$  是从顶点  $\nu_{i}$  到  $\nu_{j}$  、中间顶点是  $\nu_{0}$  的最短路径的长度，  $A^{(k)}[i][j]$  是从顶点  $\nu_{i}$  到  $\nu_{j}$  、中间顶点的序号不大于  $k$  的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从  $\nu_{i}$  到  $\nu_{j}$  的最短路径上就多考虑了一个顶点；经过  $n$  次迭代后，所得到的  $A^{(n - 1)}[i][j]$  就是  $\nu_{i}$  到  $\nu_{j}$  的最短路径长度，即方阵  $A^{(n - 1)}$  中就保存了任意一对顶点之间的最短路径长度。

图6.19所示为带权有向图  $G$  及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长度的过程如表6.3所示。算法执行过程的说明如下。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/68dcad67921fbae33f03745d6f72a02b03dafe155098c810028f1bf53384358f.jpg)



(a) 有向图  $G$


$$
\left[ \begin{array}{c c c} 0 & 6 & 1 3 \\ 1 0 & 0 & 4 \\ 5 & \infty & 0 \end{array} \right]
$$


(b)  $G$  的邻接矩阵



图6.19 带权有向图  $G$  及其邻接矩阵


初始化：方阵  $A^{(-1)}[i][j] = \operatorname{arcs}[i][j]$ 。

第1轮：将  $\nu_{0}$  作为中间顶点，对于所有顶点对  $\{i,j\}$ ，若有  $A^{-1}[i][j] > A^{-1}[i][0] + A^{-1}[0][j]$ ，则将  $A^{-1}[i][j]$  更新为  $A^{-1}[i][0] + A^{-1}[0][j]$ 。有  $A^{-1}[2][1] > A^{-1}[2][0] + A^{-1}[0][1] = 11$ ，更新  $A^{-1}[2][1] = 11$ ，更新后的方阵标记为  $A^{0}$ 。

第2轮：将  $v_{1}$  作为中间顶点，继续检测全部顶点对  $\{i,j\}$  。有  $A^0 [0][2] > A^0 [0][1] + A^0 [1][2] = 10$ ，更新  $A^0 [0][2] = 10$ ，更新后的方阵标记为  $A^{1}$ 。

第3轮：将  $\nu_{2}$  作为中间顶点，继续检测全部顶点对  $\{i,j\}$  。有  $A^{1}[1][0] > A^{1}[1][2] + A^{1}[2][0] = 9$  更新  $A^{1}[1][0] = 9$  ，更新后的方阵标记为  $A^2$  。此时  $A^2$  中保存的就是任意顶点对的最短路径长度。


表 6.3 Floyd 算法的执行过程


<table><tr><td>A</td><td colspan="3">\( A^{(-1)} \)</td><td colspan="3">\( A^{(0)} \)</td><td colspan="3">\( A^{(1)} \)</td><td colspan="3">\( A^{(2)} \)</td></tr><tr><td></td><td>\( V_0 \)</td><td>\( V_1 \)</td><td>\( V_2 \)</td><td>\( V_0 \)</td><td>\( V_1 \)</td><td>\( V_2 \)</td><td>\( V_0 \)</td><td>\( V_1 \)</td><td>\( V_2 \)</td><td>\( V_0 \)</td><td>\( V_1 \)</td><td>\( V_2 \)</td></tr><tr><td>\( V_0 \)</td><td>0</td><td>6</td><td>13</td><td>0</td><td>6</td><td>13</td><td>0</td><td>6</td><td>10</td><td>0</td><td>6</td><td>10</td></tr><tr><td>\( V_1 \)</td><td>10</td><td>0</td><td>4</td><td>10</td><td>0</td><td>4</td><td>10</td><td>0</td><td>4</td><td>2</td><td>0</td><td>4</td></tr><tr><td>\( V_2 \)</td><td>5</td><td>∞</td><td>0</td><td>5</td><td>11</td><td>0</td><td>5</td><td>11</td><td>0</td><td>5</td><td>11</td><td>0</td></tr></table>

Floyd算法的时间复杂度为  $O(|V|^3)$  。不过其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。

Floyd算法允许图中有带负权值的边，但不允许包含总权值为负的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。

也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为  $O(|V|^2)\cdot |V| = O(|V|^3)$

BFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。


表 6.4 BFS 算法、Dijkstra 算法和 Floyd 算法求最短路径的总结


<table><tr><td></td><td>BFS 算法</td><td>Dijkstra 算法</td><td>Floyd 算法</td></tr><tr><td>用途</td><td>求单源最短路径</td><td>求单源最短路径</td><td>求各顶点之间的最短路径</td></tr><tr><td>无权图</td><td>适用</td><td>适用</td><td>适用</td></tr><tr><td>带权图</td><td>不适用</td><td>适用</td><td>适用</td></tr><tr><td>带负权值的图</td><td>不适用</td><td>不适用</td><td>适用</td></tr><tr><td>带负权回路的图</td><td>不适用</td><td>不适用</td><td>不适用</td></tr><tr><td>时间复杂度</td><td>O(|V|^2)或O(|V|+|E|)</td><td>O(|V|^2)</td><td>O(|V|^3)</td></tr></table>

# 6.4.3 有向无环图描述表达式

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。

# 命题追踪

# 构建表达式的有向无环图（2019）

有向无环图是描述含有公共子式的表达式的有效工具。例如表达式

$$
((a + b) ^ {*} (b ^ {*} (c + d)) + (c + d) ^ {*} e) ^ {*} ((c + d) ^ {*} e)
$$

可以用上一章描述的二叉树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的子表达式  $(c + d)$  和  $(c + d)^{*}e$  ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d8a18341ec95a13e2efbda465757ecb68257f12074db5d1a77e9ecaf1b67e909.jpg)



图6.20 二叉树描述表达式


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/92d2c2368984445b92601a3dd2e82983ac6b4703dbffff8290a07e3a03287028.jpg)



图6.21 有向无环图描述表达式


用有向无环图描述表达式的解题方法举例见本书配套课程。

# 注意

在表达式的有向无环图表示中，不可能出现重复的操作数顶点。

# 6.4.4 拓扑排序

AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边  $< V_{i}, V_{j}>$  表示活动  $V_{i}$  必须先于活动  $V_{j}$  进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。在AOV网中，活动  $V_{i}$  是活动  $V_{j}$  的直接前驱， $V_{j}$  是  $V_{i}$  的直接后继，这种前驱和后继关系具有传递性，且任何活动  $V_{i}$  不能以它自己作为自己的前驱或后继。

拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：

1）每个顶点出现且只出现一次。

2）若顶点  $A$  在序列中排在顶点  $B$  的前面，则在图中不存在从  $B$  到  $A$  的路径。

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点  $A$  到顶点  $B$  的路径，则在排序中  $B$  出现在  $A$  的后面。每个AOV网都有一个或多个拓扑排序序列。

# 命题追踪

# 拓扑排序和回路的关系（2011）

对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：

① 从AOV网中选择一个没有前驱（入度为0）的顶点并输出。

② 从网中删除该顶点和所有以它为起点的有向边。

③ 重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

# 命题追踪

# 拓扑排序的实例（2010、2014、2018、2021）

图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶点和所有以它为起点的有向边，最后得到拓扑排序的结果为{1,2,4,3,5}。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e871878f8c5967c9de1fc4bbfa7ad92d316aff3670cdde193b99f68e11fce2fd.jpg)


<table><tr><td>结点号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>初始入度</td><td>0</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>第1轮</td><td></td><td>0</td><td>2</td><td>1</td><td>2</td></tr><tr><td>第2轮</td><td></td><td></td><td>1</td><td>0</td><td>2</td></tr><tr><td>第3轮</td><td></td><td></td><td>0</td><td></td><td>1</td></tr><tr><td>第4轮</td><td></td><td></td><td></td><td></td><td>0</td></tr><tr><td>第5轮</td><td></td><td></td><td></td><td></td><td></td></tr></table>

(a)


图6.22 有向无环图的拓扑排序过程


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/692fdb6a9cca3e35d0c4bc1cd49bed4739f02434417a6746ab1fa689dc38ad0e.jpg)



图6.22 有向无环图的拓扑排序过程（续）


# 命题追踪 （算法题）拓扑排序的实现（2024）

拓扑排序算法（基于邻接表存储）的实现如下：

```javascript
boolTopologicalSort(GraphG){ InitStack(S); //初始化栈，存储入度为0的顶点 inti; for  $(\mathrm{i} = 0;\mathrm{i} <   \mathrm{G}.$  vexnum;i++) if(indegree[i]  $\equiv = 0$  ) Push(S,i); //将所有入度为0的顶点入栈 int count  $= 0$  ： //计数，记录当前已经输出的顶点数 while(!IsEmpty(S)){ //栈不空，则存在入度为0的顶点 Pop(S,i); //栈顶元素出栈 print[count  $+ + ] = i$  //输出顶点i for(p=G竖 vertices[i].firstarc;p:p  $\coloneqq$  nextarc){ //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S v=p->adjvex; if(!(-indegree[v])) Push(S,v); //入度为0，则入栈 } } if(count<G.vexnum) return false; //排序失败，有向图中有回路 else return true; //拓扑排序成功   
}
```

# 命题追踪 不同存储方式下的拓扑排序的效率（2016）

因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时间复杂度为  $O(|V| + |E|)$ ，采用邻接矩阵存储时拓扑排序的时间复杂度为  $O(|V|^2)$ 。

# 命题追踪 DFS 实现拓扑排序的思想（2020）

此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码见本节后的习题。对于有向无环图  $G$  中的任意结点  $u, v$  ，它们之间的关系必然是下列三种之一：

1）若  $u$  是  $v$  的祖先，则在调用DFS访问  $u$  之前，必然已对  $v$  进行了DFS访问，即  $v$  的DFS结束时间先于  $u$  的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。

2）若  $u$  是  $v$  的子孙，则  $v$  为  $u$  的祖先，按上述思路， $v$  的结束时间大于  $u$  的结束时间。

3）若  $u$  和  $\nu$  没有路径关系，则  $u$  和  $\nu$  在拓扑序列的关系任意。

于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。

对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：

① 从AOV网中选择一个没有后继（出度为0）的顶点并输出。

② 从网中删除该顶点和所有以它为终点的有向边。

③ 重复①和②直到当前的AOV网为空。

用拓扑排序算法处理AOV网时，应注意以下问题：

1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。

# 命题追踪

# 拓扑排序序列的存在性和唯一性分析（2011、2024）

2）拓扑排序的结果可能不唯一。不少人误认为AOV网的各顶点为线性序列是拓扑序列唯一的充要条件，而它其实只是充分非必要条件。拓扑序列是否唯一的判断条件是在每次输出顶点时，检测入度为0的顶点是否唯一，若每次都唯一，则说明拓扑序列唯一。

3）AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。

# 6.4.5 关键路径

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网。AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。

AOE网具有以下两个性质：

① 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；

② 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。

在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。

# 命题追踪

# 关键路径的性质（2020）

在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。

完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。

下面给出在寻找关键活动时所用到的几个参量的定义。

# 1. 事件  $v_{k}$  的最早发生时间  $v_{e}(k)$

指从源点  $\nu_{1}$  到顶点  $\nu_{k}$  的最长路径长度。事件  $\nu_{k}$  的最早发生时间决定了所有从  $\nu_{k}$  开始的活动能够开工的最早时间。可用下面的递推公式来计算：

$$
v _ {e} (\text {源 点}) = 0
$$

$\nu_{e}(k) = \operatorname{Max}\{\nu_{e}(j) + \operatorname{Weight}(\nu_{j}, \nu_{k})\}, \nu_{k}$  为  $\nu_{j}$  的任意后继，Weight  $(\nu_{j}, \nu_{k})$  表示  $\langle \nu_{j}, \nu_{k} \rangle$  上的权值

# 注意

计算  $v_{e}(r)$  值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：

① 初始时，令  $v_{e}[1 \dots n] = 0$ 。

② 输出一个入度为0的顶点  $\nu_{j}$  时，计算它所有直接后继顶点  $\nu_{k}$  的最早发生时间，若  $\nu_{e}[j] + \mathrm{Weight}(\nu_{j}, \nu_{k}) > \nu_{e}[k]$ ，则  $\nu_{e}[k] = \nu_{e}[j] + \mathrm{Weight}(\nu_{j}, \nu_{k})$ 。以此类推，直至输出全部顶点。

# 2. 事件  $v_{k}$  的最迟发生时间  $v_{l}(k)$

指在不推迟整个工程完成的前提下，即保证它的后继事件  $\nu_{j}$  在其最迟发生时间  $\nu_{j}(j)$  能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：

$$
\begin{array}{l} v _ {f} (\text {汇 点}) = v _ {e} (\text {汇 点}) \\ v _ {j} (k) = \operatorname {M i n} \left\{v _ {j} (j) - \operatorname {W e i g h t} \left(v _ {k}, v _ {j}\right) \right\}, v _ {k} \text {为} v _ {j} \text {的 任 意 前 驱} \\ \end{array}
$$

# 注意

计算  $\nu_{i}(k)$  值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：

① 初始时，令  $v_{l}[1 \dots n] = v_{e}[n]$ 。

② 栈顶顶点  $v_{j}$  出栈，计算其所有直接前驱顶点  $v_{k}$  的最迟发生时间，若  $v_{j}[j] - \mathrm{Weight}(v_{k}, v_{j}) < v_{l}[k]$ ，则  $v_{l}[k] = v_{l}[j] - \mathrm{Weight}(v_{k}, v_{j})$ 。以此类推，直至输出全部栈中顶点。

# 3. 活动  $a_{i}$  的最早开始时间  $e(i)$

指该活动弧的起点所表示的事件的最早发生时间。若边  $< \nu_{k},\nu_{j}>$  表示活动  $a_{i}$  ，则有  $e(i) = \nu_{c}(k)$

# 4. 活动  $a_{i}$  的最迟开始时间  $l(i)$

指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边  $<\nu_{k}, \nu_{j}>$  表示活动  $a_{i}$ ，则有  $l(i) = \nu_{l}(j) - \mathrm{Weight}(\nu_{k}, \nu_{j})$ 。

# 5. 一个活动  $a_{i}$  的最迟开始时间  $l(i)$  和其最早开始时间  $e(i)$  的差额  $d(i) = l(i) - e(i)$

指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动  $a_{i}$  可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称  $l(i) - e(i) = 0$  即  $l(i) = e(i)$  的活动  $a_{i}$  是关键活动。

# 命题追踪

# 求关键路径的实例（2019、2022）

求关键路径的算法步骤如下：

① 从源点出发，令  $v_{e}$  （源点）  $= 0$ ，按拓扑有序求其余顶点的最早发生时间  $v_{e}( )$  。

② 从汇点出发，令  $v_{f}$  （汇点）  $= v_{e}$  （汇点），按逆拓扑有序求其余顶点的最迟发生时间  $v_{f}(.)$  。

③ 根据各顶点的  $v_{e}(t)$  值求所有弧的最早开始时间  $e(t)$ 。

④ 根据各顶点的  $\nu_{l}(t)$  值求所有弧的最迟开始时间  $l(t)$ 。

⑤ 求AOE网中所有活动的差额  $d()$  ，找出所有  $d() = 0$  的活动构成关键路径。

图6.23所示为求解关键路径的过程，简单说明如下：

① 求  $v_{e}(0)$  ：初始  $v_{e}(1) = 0$ ，在拓扑排序输出顶点过程中，求得  $v_{e}(2) = 3$ ， $v_{e}(3) = 2$ ， $v_{e}(4) = \max \{v_{e}(2) + 2, v_{e}(3) + 4\} = \max \{5, 6\} = 6$ ， $v_{e}(5) = 6$ ， $v_{e}(6) = \max \{v_{e}(5) + 1, v_{e}(4) + 2, v_{e}(3) + 3\} = \max \{7, 8, 5\} = 8$ 。

若这是一道选择题，根据上述求  $v_{e}(t)$  的过程就已经能知道关键路径。

② 求  $v_{i}(6) = 8$ ，在逆拓扑排序出栈过程中，求得  $v_{i}(5) = 7$ ， $v_{i}(4) = 6$ ， $v_{i}(3) = \min \{v_{i}(4) - 4, v_{i}(6) - 3\} = \min \{2, 5\} = 2$ ， $v_{i}(2) = \min \{v_{i}(5) - 3, v_{i}(4) - 2\} = \min \{4, 4\} = 4$ ， $v_{i}(1)$  必然为0而无须再求。

③ 弧的最早开始时间  $e$  ( )等于该弧的起点的顶点的  $v_{e}$ , 结果如下表。

④ 弧的最迟开始时间  $l(i)$  等于该弧的终点的顶点的  $\nu (.)$  减去该弧持续的时间，结果如下表。

⑤ 根据  $l(i) - e(i) = 0$  的关键活动，得到的关键路径为  $(v_{1}, v_{3}, v_{4}, v_{6})$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1dfb965e9d49ab5977f0a09189618e304e7d1fefeaeb6962d1b4b8b28b8f334d.jpg)


<table><tr><td></td><td>\( v_1 \)</td><td>\( v_2 \)</td><td>\( v_3 \)</td><td>\( v_4 \)</td><td>\( v_5 \)</td><td>\( v_6 \)</td></tr><tr><td>\( v_e(i) \)</td><td>0</td><td>3</td><td>2</td><td>6</td><td>6</td><td>8</td></tr><tr><td>\( v_f(i) \)</td><td>0</td><td>4</td><td>2</td><td>6</td><td>7</td><td>8</td></tr></table>

<table><tr><td></td><td>a1</td><td>a2</td><td>a3</td><td>a4</td><td>a5</td><td>a6</td><td>a7</td><td>a8</td></tr><tr><td>e(i)</td><td>0</td><td>0</td><td>3</td><td>3</td><td>2</td><td>2</td><td>6</td><td>6</td></tr><tr><td>l(i)</td><td>1</td><td>0</td><td>4</td><td>4</td><td>2</td><td>5</td><td>6</td><td>7</td></tr><tr><td>l(i)-e(i)</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>3</td><td>0</td><td>1</td></tr></table>


图6.23 求解关键路径的过程


# 命题追踪 缩短工期的相关分析（2013）

对于关键路径，需要注意以下几点：

1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。

2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。

各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。


表 6.5 采用不同存储结构时各种图算法的时间复杂度


<table><tr><td></td><td>Dijkstra</td><td>Floyd</td><td>Prim</td><td>Kruskal</td><td>DFS</td><td>BFS</td><td>拓扑排序</td><td>关键路径</td></tr><tr><td>邻接矩阵</td><td>O(n2)</td><td>O(n3)</td><td>O(n2)</td><td>-</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td></tr><tr><td>邻接表</td><td>-</td><td>-</td><td>-</td><td>O(log2e)</td><td>O(n + e)</td><td>O(n + e)</td><td>O(n + e)</td><td>O(n + e)</td></tr></table>

# 6.4.6 本节试题精选

# 一、单项选择题

01. 任何一个无向连通图的最小生成树（）。

A. 有一棵或多棵

B. 只有一棵

C. 一定有多棵

D. 可能不存在

02. 用 Prim 算法和 Kruskal 算法构造图的最小生成树，所得到的最小生成树（）。

A. 相同

B. 不相同

C. 可能相同, 可能不同

D. 无法比较

03. 下列关于图的生成树和最小生成树的叙述中，正确的是（）。

A. 只要无向连通图中没有权值相同的边, 则其最小生成树唯一

B. 只要无向图中有权值相同的边，则其最小生成树一定不唯一

C. 从  $n$  个顶点的连通图中选取  $n - 1$  条权值最小的边, 即可构成最小生成树

D. 设连通图  $G$  含有  $n$  个顶点, 则含有  $n$  个顶点、 $n-1$  条边的子图一定是  $G$  的生成树

04. 设有  $n$  个顶点的无向连通图的最小生成树不唯一，则下列说法中正确的是（）。

A. 图的边数一定大于  $n - 1$

B. 图的权值最小的边一定有多条

C. 图的最小生成树的代价不一定相等

D. 图的各条边的权值不相等

05. 用 Prim 算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的顶点集合  $U = \{1,2,3\}$ ，已选取的边集合  $\mathrm{TE} = \{(1,2),(2,3)\}$ ，要选取下一条权值最小的边，应当从（）组中选取。

A.  $\{(1,4),(3,4),(3,5),(2,5)\}$

B.  $\{(3,4),(3,5),(4,5),(1,4)\}$

C.  $\{(1,2),(2,3),(3,5)\}$

D.  $\{(4,5),(1,3),(3,5)\}$

06. 用 Kruskal 算法求一个带权连通图的最小生成树，在算法执行的某个时刻，已选取的边集合  $\mathrm{TE} = \{(1,2),(2,3),(3,5)\}$ ，要选取下一条权值最小的边，不可能选取的边是（）。

A. (3,6)

B. (2, 4)

C. (1,3)

D. (1,4)

07. 下列关于图的最短路径的相关叙述中，正确的是（）。

A. 最短路径一定是简单路径

B. Dijkstra 算法不适合求有回路的带权图的最短路径

C. Dijkstra 算法不适合求任意两个顶点的最短路径

D. Floyd算法求两个顶点的最短路径时，  $\mathrm{path}_{k - 1}$  一定是  $\mathrm{path}_k$  的子集

08. 下列关于图的最短路径的相关叙述中，正确的是（）。

I. Dijkstra 算法求单源最短路径不允许边的权为负

II. Dijkstra 算法求每对顶点间的最短路径的时间复杂度是  $O(n^{2})$

III. Floyd算法求每对顶点间的最短路径允许边的权为负，但不允许含有负权的回路

A. I、II和III

B. 仅 I

C. I 和 III

D. II 和 III

09. 已知带权连通无向图  $G = (V, E)$ ，其中  $V = \{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}, v_{6}, v_{7}\}$ ， $E = \{(v_{1}, v_{2})|0, (v_{1}, v_{3})|2, (v_{3}, v_{4})|2, (v_{3}, v_{6})|1, (v_{2}, v_{5})|1, (v_{4}, v_{5})|4, (v_{4}, v_{6})|6, (v_{5}, v_{7})|7, (v_{6}, v_{7})|3\}$ （注：顶点偶对括号外的数据表示边上的权值），从源点  $v_{1}$  到顶点  $v_{7}$  的最短路径上经过的顶点序列是（）。

A.  $v_{1}, v_{2}, v_{5}, v_{7}$

B.  $v_{1}, v_{3}, v_{4}, v_{6}, v_{7}$

C.  $v_{1}, v_{3}, v_{4}, v_{5}, v_{7}$

D.  $v_{1}, v_{2}, v_{5}, v_{4}, v_{6}, v_{7}$

10. 用Dijkstra算法求一个带权有向图的从顶点0出发的最短路径，在算法执行的某个时刻，已求得的最短路径的顶点集合  $S = \{0,2,3,4\}$ ，下一个选取的目标顶点是顶点1，则可能修改的最短路径是（）。

A. 从顶点0到顶点3的最短路径

B. 从顶点0到顶点2的最短路径

C. 从顶点 2 到顶点 4 的最短路径

D. 从顶点 0 到顶点 1 的最短路径

11. 下面的（）方法可以判断出一个有向图是否有环（回路）。

I. 深度优先遍历 II. 拓扑排序 III. 求最短路径 IV. 求关键路径

A. I、II、IV

B. I、III、IV

C. I、II、III

D. 全部可以

12. 在有向图  $G$  的拓扑序列中，若顶点  $\nu_{i}$  在顶点  $\nu_{j}$  之前，则不可能出现的情形是（）。

A.  $G$  中有弧  $\left\{v_{i}, v_{j}\right\}$

B.  $G$  中有一条从  $\nu_{i}$  到  $\nu_{j}$  的路径

C.  $G$  中没有弧  $\left\{v_{i}, v_{j}\right\}$

D.  $G$  中有一条从  $\nu_{j}$  到  $\nu_{i}$  的路径

13. 下列关于拓扑排序的说法中，错误的是（）。

I. 若某有向图存在环路，则该有向图一定不存在拓扑排序

II. 在拓扑排序算法中为暂存入度为零的顶点，可以使用栈，也可以使用队列

III. 若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1

IV. 若有向图的拓扑有序序列唯一，则图中入度为0和出度为0的顶点都仅有1个

A. I、III、IV

B. III、IV

C. II、IV

D. III

14. 下列关于拓扑排序的说法中，正确的是（）。

I. 顶点数大于1的强连通图不能进行拓扑排序

II. 在一个有向图的拓扑序列中，若顶点  $a$  在顶点  $b$  之前，则图中必有一条弧  $\langle a, b \rangle$

III. 若有向无环图的拓扑序列唯一，则可以唯一确定该图

A. I和II

B. I、II 和 III

C. 仅 I

D. I 和 III

15. 若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图（）。

A. 含有多个出度为 0 的顶点

B. 是个强连通图

C. 含有多个入度为 0 的顶点

D. 含有顶点数大于 1 的强连通分量

16. 下图所示有向图的所有拓扑序列共有（）个。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/756c4bb48de7c030245a9a7168b1aafe6314039a311ea98a94e9d8a42b5031f1.jpg)


A. 4

B. 6

C. 5

D. 7

17. 已知有向图  $G = (V, E)$ ，其中  $V = \{v_1, v_2, v_3, v_4, v_5, v_6, v_7\}$ ， $E = \{<v_1, v_2>, <v_1, v_3>, <v_1, v_4>, <v_2, v_5>, <v_3, v_5>, <v_3, v_6>, <v_5, v_7>, <v_6, v_7>, <v_4, v_6>\}$ ， $G$  的拓扑序列是（）。

A.  $\{v_{1}, v_{3}, v_{4}, v_{6}, v_{2}, v_{5}, v_{7}\}$

B.  $\left\{v_{1}, v_{3}, v_{2}, v_{6}, v_{4}, v_{5}, v_{7}\right\}$

C.  $\left\{v_{1}, v_{3}, v_{4}, v_{5}, v_{2}, v_{6}, v_{7}\right\}$

D.  $\{v_{1}, v_{2}, v_{5}, v_{3}, v_{4}, v_{6}, v_{7}\}$

18. 下列哪种图的邻接矩阵是对称矩阵？（）

A. 有向网

B. 无向图

C.AOV网

D.AOE网

19. 若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为（）。

A. 对称

B. 稀疏

C. 三角

D. 一般

20. 用DFS算法遍历一个无环有向图，并在DFS算法退栈返回时输出相应的顶点，则输出的顶点序列是（）。

A. 逆拓扑有序

B. 拓扑有序

C. 无序的

D. 无法确定

21. 下列关于图的说法中，正确的是（）。

I. 有向图中顶点  $V$  的度等于其邻接矩阵中第  $V$  行中1的个数

II. 无向图的邻接矩阵一定是对称矩阵，有向图的邻接矩阵一定是非对称矩阵

III. 在带权图  $G$  的最小生成树  $G_{1}$  中，某条边的权值可能会超过未选边的权值

IV. 若有向无环图的拓扑序列唯一，则可以唯一确定该图

A. I、II和III

B. III 和 IV

C. III

D. IV

22. 下图所示的AOE网中，关键路径长度为（）。

A. 16

B. 17

C. 18

D. 19

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bc002bc4a1e389424dfd8b5b69752a590874f755b1da2ac4acde31750f317acd.jpg)


23. 若某带权图为  $G = (V, E)$ ，其中  $V = \{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}, v_{6}, v_{7}, v_{8}, v_{9}, v_{10}\}$ ， $E = \{<v_{1}, v_{2}>5, <v_{1}, v_{3}>6, <v_{2}, v_{5}>3, <v_{3}, v_{5}>6, <v_{4}, v_{4}>3, <v_{4}, v_{7}>1, <v_{4}, v_{8}>4, <v_{5}, v_{6}>4, <v_{5}, v_{7}>2, <v_{6}, v_{10}>4, <v_{7}, v_{9}>5, <v_{8}, v_{9}>2, <v_{9}, v_{10}>2\}$ （注：边括号外的数据表示边上的权值），则  $G$  的关键路径的长度为（）。

A. 19

B. 20

C. 21

D. 22

24. 下面关于求关键路径的说法中，不正确的是（）。

A. 求关键路径是以拓扑排序为基础的

B. 一个事件的最早发生时间与以该事件为始的弧的活动的最早开始时间相同

C. 一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差

D. 任何一个活动的持续时间的改变可能会影响关键路径的改变

25. 下列关于AOE网的关键路径的说法中，正确的是（）。

I. 改变网上某一关键路径上的任意一个关键活动后，必将产生不同的关键路径

II. 关键路径上活动的时间延长多少，整个工期也就随之延长多少

III. 缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度

IV. 缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度

V. 缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度

A. II 和 V

B. I、II 和 IV

C. II 和 IV

D. I 和 IV

26. 在求AOE网的关键路径时，若该有向图用邻接矩阵表示且第  $i$  列值全为  $\infty$  ，则（）。

A. 若关键路径存在，第  $i$  个顶点一定是起点

B. 若关键路径存在，第  $i$  个顶点一定是终点

C. 关键路径不存在

D. 该有向图对应的无向图存在多个连通分量

27.【2010统考真题】对下图进行拓扑排序，可得不同拓扑序列的个数是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b3ff67b3cee56eeb46010d9fd5e5e83f7bb27aef2b11f00efa117ac3f3ecc47d.jpg)


A. 4

B. 3

C. 2

D. 1

28.【2012统考真题】下列关于最小生成树的叙述中，正确的是（）。

I. 最小生成树的代价唯一

II. 所有权值最小的边一定会出现在所有的最小生成树中

III. 使用 Prim 算法从不同顶点开始得到的最小生成树一定相同

IV. 使用 Prim 算法和 Kruskal 算法得到的最小生成树总不相同

A. 仅 I

B. 仅 II

C. 仅 I、III

D. 仅 II、IV

29.【2012统考真题】对下图所示的有向带权图，若采用Dijkstra算法求从源点  $a$  到其他各

顶点的最短路径，则得到的第一条最短路径的目标顶点是  $b$  ，第二条最短路径的目标顶点是  $c$  ，后续得到的其余各最短路径的目标顶点依次是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/746c685c6b37561a13aa781d96fb04856bcfcfa515828b494695a61fd10fe288.jpg)


A.  $d, e, f$

B.  $e, d, f$

C.  $f, d, e$

D.  $f, e, d$

30.【2012统考真题】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是（）。

A. 存在，且唯一

B. 存在，且不唯一

C. 存在，可能不唯一

D. 无法确定是否存在

31.【2013统考真题】下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可缩短整个工程的工期。在下列选项中，加快其进度就可缩短工程工期的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/57a0f59607aebb3bf1a1b09ce2550c32ef57bf38f2e623d362400d3715fd9cd0.jpg)


A.  $c$  和  $e$

B.  $d$  和  $c$

C.  $f$  和  $d$

D.  $f$  和  $h$

32.【2014统考真题】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e0121e79a4ee5e7eef2cf58fbbf129f9b98fd46d7003382f71c87aaf3060f7db.jpg)


A.  $3,1,2,4,5,6$

B. 3, 1, 2, 4, 6, 5

C.  $3,1,4,2,5,6$

D.  $3, 1, 4, 2, 6, 5$

33.【2015统考真题】求下面的带权图的最小（代价）生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从  $V_{4}$  开始）第2次选中的边是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8b4f96043612034d6d59fd4b27b4d63a06b63313688030c10c5a5a2083fce1b1.jpg)


A.  $(V_{1}, V_{3})$

B.  $(V_{1}, V_{4})$

C.  $(V_{2}, V_{3})$

D.  $(V_{3}, V_{4})$

34.【2011统考真题】下列关于图的叙述中，正确的是（）。

I. 回路是简单路径

II. 存储稀疏图，用邻接矩阵比邻接表更省空间

III. 若有向图中存在拓扑序列，则该图不存在回路

A. 仅 II

B. 仅 I、II

C. 仅 III

D. 仅 I、III

35.【2016统考真题】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8dd2aaf4f753a3e9b57d28e280c3a28a0ab5568b91b586c8faa94efd49219eeb.jpg)


A. 5,2,3,4,6

B. 5,2,3,6,4

C.  $5,2,4,3,6$

D. 5,2,6,3,4

36.【2016统考真题】若对  $n$  个顶点、  $e$  条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是（）。

A.  $O(n)$

B.  $O(n + e)$

C.  $O\left(n^{2}\right)$

D.  $O(n e)$

37.【2018统考真题】下列选项中，不是如下有向图的拓扑序列的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/099c418d8ba74dc13c04c49393c01f01fbb44b66523d60dec2559f53a2f28776.jpg)


A.  $1, 5, 2, 3, 6, 4$

B. 5, 1, 2, 6, 3, 4

C.  $5,1,2,3,6,4$

D. 5, 2, 1, 6, 3, 4

38.【2019统考真题】下图所示的AOE网表示一项包含8个活动的工程。活动  $d$  的最早开始时间和最迟开始时间分别是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/70d7d555409120c7381dc12e232afcc4dbec134f2f81bd7742de9ba00f326164.jpg)


A. 3和7

B. 12和12

C. 12 和 14

D. 15和15

39.【2019统考真题】用有向无环图描述表达式  $(x + y)((x + y) / x)$ ，需要的顶点个数至少是（）。

A. 5

B. 6

C. 8

D. 9

40.【2020统考真题】已知无向图  $G$  如下所示，使用Kruskal算法求图  $G$  的最小生成树，加到最小生成树中的边依次是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6bdf8f3f71ea7e3d645cb00ed694afa4c33b42568905c8a85b5be83cda8bfad6.jpg)


A.  $(b,f),(b,d),(a,e),(c,e),(b,e)$

B.  $(b,f),(b,d),(b,e),(a,e),(c,e)$

C.  $(a,e),(b,e),(c,e),(b,d),(b,f)$

D.  $(a,e),(c,e),(b,e),(b,f),(b,d)$

41.【2020统考真题】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访问）顶点信息的语句移到退出递归前（执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图  $G$  ，若输出结果中包含  $G$  中的全部顶点，则输出的顶点序列是  $G$  的（）。

A. 拓扑有序序列

B. 逆拓扑有序序列

C. 广度优先搜索序列

D. 深度优先搜索序列

42.【2020统考真题】若使用AOE网估算工程进度，则下列叙述中正确的是（）。

A. 关键路径是从源点到汇点边数最多的一条路径

B. 关键路径是从源点到汇点路径长度最长的路径

C. 增加任意一个关键活动的时间不会延长工程的工期

D. 缩短任意一个关键活动的时间将会缩短工程的工期

43.【2021统考真题】给定如下有向图，该图的拓扑有序序列的个数是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c58ded7594b748964b31d9804195cba67b68ed2474469fcbeacb69ac43c8739f.jpg)


A. 1

B. 2

C. 3

D. 4

44.【2021统考真题】使用Dijkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2,3,4,5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist中的内容更新为（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/21ecb1f2d790d8102d5bb9f5e1f68e8d16db2a547f2fa86e2e3388a469798d87.jpg)


A. 26,3,14,6

B. 25,3,14,6

C. 21,3,14,6

D. 15,3,14,6

45.【2022统考真题】下图是一个有10个活动的AOE网，时间余量最大的活动是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8ceea1ecbfff84077555fd1fc67a8177413443ead1cf988f064f4a01d5c0a8c1.jpg)


A. c

B. g

C. h

D. j

46.【2023统考真题】已知无向连通图  $G$  中各边的权值均为1。在下列算法中，一定能够求出图  $G$  中从某顶点到其余各顶点最短路径的是（）。

I. Prim算法 II. Kruskal算法 III. 图的广度优先搜索算法

A. 仅I

B. 仅III

C. 仅 I、II

D. I、II、III

# 二、综合应用题

01. 下面是一种称为“破圈法”的求解最小生成树的方法：所谓“破圈法”，是指“任取一圈，去掉圈上权最大的边”，反复执行这一步骤，直到没有圈为止。试判断这种方法是否正确。若正确，说明理由；若不正确，举出反例（注：圈就是回路）。

02. 已知有向图如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d24252747ffd5e8977fedd45aabc53a43d7fd3178d62bbdf0c4a3116d0d1fcb3.jpg)


1）写出该图的邻接矩阵表示并据此给出从顶点1出发的深度优先遍历序列。

2）求该有向图的强连通分量的数目。

3）给出该图的任意两个拓扑序列。

4）若将该图视为无向图，分别用 Prim 算法和 Kruskal 算法求最小生成树。

03. 对下图所示的无向图，按照 Dijkstra 算法，写出从顶点 1 到其他各个顶点的最短路径和最短路径长度（顺序不能颠倒）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/671ab058e344ac7e2237f40e68d48e589b28073d42c4d83b923e153eb8ebf92d.jpg)


04. 下图所示为一个用AOE网表示的工程。

1）画出此图的邻接表表示。

2）完成此工程至少需要多少时间？

3）指出关键路径。

4）哪些活动加速可以缩短完成工程所需的时间？

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d24698f70b0b6209b1529cfb572f7d23fea5413dc3fcc1b5bf448dbb133a11fe.jpg)


05. 下表给出了某工程各工序之间的优先关系和各工序所需的时间（其中“一”表示无先驱工序），请完成以下各题：

1）画出相应的AOE网。

2）列出各事件的最早发生时间和最迟发生时间。

3）求出关键路径并指明完成该工程所需的最短时间。

<table><tr><td>工序代号</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td></tr><tr><td>所需时间</td><td>3</td><td>2</td><td>2</td><td>3</td><td>4</td><td>3</td><td>2</td><td>1</td></tr><tr><td>先驱工序</td><td>-</td><td>-</td><td>A</td><td>A</td><td>B</td><td>A</td><td>C、E</td><td>D</td></tr></table>

06. 一连通无向图，边非负权值，问用Dijkstra最短路径算法能否给出一棵生成树，该树是否一定是最小生成树？说明理由。

07. 试编写利用DFS实现有向无环图拓扑排序的算法。

08.【2009统考真题】带权图（权值非负，表示边连接的两顶点间的距离）的最短路径问题是找出从初始顶点到目标顶点之间的一条最短路径。假设从初始顶点到目标顶点之间存在路径，现有一种解决该问题的方法：

① 设最短路径初始时仅包含初始顶点，令当前顶点  $u$  为初始顶点。

② 选择离  $u$  最近且尚未在最短路径中的一个顶点  $v$ ，加入最短路径，修改当前顶点  $u = v$ 。

③ 重复步骤②，直到  $u$  是目标顶点时为止。

请问上述方法能否求得最短路径？若该方法可行，请证明；否则，请举例说明。

09.【2011统考真题】已知有6个顶点（顶点编号为  $0\sim 5$  ）的有向带权图  $G$  ，其邻接矩阵  $\mathbf{A}$  为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。

<table><tr><td>4</td><td>6</td><td>∞</td><td>∞</td><td>∞</td><td>5</td><td>∞</td><td>∞</td><td>∞</td><td>4</td><td>3</td><td>∞</td><td>∞</td><td>3</td><td>3</td></tr></table>

要求：

1）写出图  $G$  的邻接矩阵  $\mathbf{A}$

2）画出有向带权图  $G$ 。

3）求图  $G$  的关键路径，并计算该关键路径的长度。

10.【2014统考真题】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息（LSI），R1构造的网络拓扑图（见下图）是根据题下表及R1的接口名构造出来的网络拓扑。

<table><tr><td colspan="2"></td><td>R1的LSI</td><td>R2的LSI</td><td>R3的LSI</td><td>R4的LSI</td><td>备注</td></tr><tr><td colspan="2">Router ID</td><td>10.1.1.1</td><td>10.1.1.2</td><td>10.1.1.5</td><td>10.1.1.6</td><td>标识路由器的IP地址</td></tr><tr><td rowspan="3">Link1</td><td>ID</td><td>10.1.1.2</td><td>10.1.1.1</td><td>10.1.1.6</td><td>10.1.1.5</td><td>所连路由器的Router ID</td></tr><tr><td>IP</td><td>10.1.1.1</td><td>10.1.1.2</td><td>10.1.1.5</td><td>10.1.1.6</td><td>Link1的本地IP地址</td></tr><tr><td>Metric</td><td>3</td><td>3</td><td>6</td><td>6</td><td>Link1的费用</td></tr><tr><td rowspan="3">Link2</td><td>ID</td><td>10.1.1.5</td><td>10.1.1.6</td><td>10.1.1.1</td><td>10.1.1.2</td><td>所连路由器的Router ID</td></tr><tr><td>IP</td><td>10.1.1.9</td><td>10.1.1.13</td><td>10.1.1.10</td><td>10.1.1.14</td><td>Link2的本地IP地址</td></tr><tr><td>Metric</td><td>2</td><td>4</td><td>2</td><td>4</td><td>Link2的费用</td></tr><tr><td rowspan="2">Net1</td><td>Prefix</td><td>192.1.1.0/24</td><td>192.1.6.0/24</td><td>192.1.5.0/24</td><td>192.1.7.0/24</td><td>直连网络Net1的网络前缀</td></tr><tr><td>Metric</td><td>1</td><td>1</td><td>1</td><td>1</td><td>到达直连网络Net1的费用</td></tr></table>

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/eaf075e06f578e19cbe0d44b741e6aa4f44ee457be452e82dce45926e67ed2ab.jpg)


请回答下列问题。

1）本题中的网络可抽象为数据结构中的哪种逻辑结构？

2）针对表中的内容，设计合理的链式存储结构，以保存表中的链路状态信息（LSI）。要求给出链式存储结构的数据类型定义，并画出对应表的链式存储结构示意图（示意图中可仅以ID标识结点）。

3）按照Dijkstra算法的策略，依次给出R1到达子网  $192.1.x.x$  的最短路径及费用。

11.【2017统考真题】使用Prim算法求带权连通图的最小（代价）生成树（MST）。请回答下列问题：

1）对下列图  $G$  ，从顶点  $A$  开始求  $G$  的MST，依次给出按算法选出的边。

2）图  $G$  的MST是唯一的吗？

3）对任意的带权连通图，满足什么条件时，其MST是唯一的？

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c45e3cd7507e6a6fbc1c17a8b0f7d450a1b7c1a41373db603359c5ab2af1f818.jpg)


12.【2018统考真题】拟建设一个光通信骨干网络连通BJ、CS、XA、QD、JN、NJ、TL和WH等8个城市，下图中无向边上的权值表示两个城市之间备选光缆的铺设费用。

请回答下列问题：

1）仅从铺设费用角度出发，给出所有可能的最经济的光缆铺设方案（用带权图表示），并计算相应方案的总费用。

2）该图可采用图的哪种存储结构？给出求解问题1）所用的算法名称。

3）假设每个城市采用一个路由器按1）中得到的最经济方案组网，主机H1直接连接TL的路由器，主机H2直接连接BJ的路由器。若H1向H2发送一个  $\mathrm{TTL} = 5$  的IP分组，则H2是否可以收到该IP分组？

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/902f5ea702fa3717a94dab17a9123e5d00c8d9f966524da3742339fa7c0ceeee.jpg)


13.【2024统考真题】2023年10月26日，神舟十七号载人飞船发射取得圆满成功，再次彰显了中国航天事业的辉煌成就。载人航天工程是包含众多子工程的复杂系统工程，为了保证工程的有序开展，需要明确各子工程的前导子工程，以协调各子工程的实施。该问题可以简化、抽象为有向图的拓扑序列问题。已知有向图  $G$  采用邻接矩阵存储，类型定义如下。

```txt
typedef struct //图的类型定义  
{ int numVertices, numEdges; //图的顶点数和有向边数 char VerticesList [MAXV]; //顶点表，MAXV为已定义常量 int Edge [MAXV] [MAXV]; //邻接矩阵  
} MGraph;
```

请设计算法：int uniquely(MGraqh G)，判定 G 是否存在唯一的拓扑序列，若是，则返回 1，否则返回 0。要求如下。

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

# 6.4.7 答案与解析

# 一、单项选择题

# 01. A

当无向连通图存在权值相同的多条边时，最小生成树可能是不唯一的；另外，这是一个无向连通图，因此最小生成树必定存在，从而选择A。

# 02. C

因为无向连通图的最小生成树不一定唯一，所以用不同算法生成的最小生成树可能不同，但当无向连通图的最小生成树唯一时，不同算法生成的最小生成树必定是相同的。

# 03. A

最小生成树算法是基于贪心策略的，每次总是选取权值最小且满足条件的边，若各边权值不同，则每次选择的新顶点也是唯一的，因此最小生成树唯一，A 正确。对于 B，若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。对于 C，选取的  $n - 1$  条边可能构成回路。对于 D，含有  $n$  个顶点、  $n - 1$  条边的子图可能构成回路，也可能不连通。

# 04. A

若图的边数小于  $n - 1$ ，则图不存在最小生成树；若无向连通图的边数等于  $n - 1$ ，则最小生成树唯一，即图本身，所以图的边数一定大于  $n - 1$ ，A 正确。若最小生成树不唯一，则一定存在权值相等的边，但未必是权值最小的边，如下图所示，B 错误。最小生成树可能不唯一，但代价一定相同，C 错误。当图的各边的权值互不相等时，图的最小生成树是唯一的，D 错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2638f60809c937e1cf3122e6d2083f7d1c6a05fdd77ab3a45effe17ed4aef937.jpg)


# 05. A

$U = \{1,2,3\}$  ，  $V - U = \{4,5,\dots \}$  ，候选边只能是这两个顶点集之间的边，只有选项A符合题意。

# 06. C

若选取边(1,3)则会构成回路。

# 07. A

选项A正确，见严蔚敏老师的《数据结构》教材。Dijkstra算法适合求解有回路的带权图的最短路径，也可以求任意两个顶点的最短路径，不适合求带负权值的最短路径问题。在用Floyd算法求两个顶点的最短路径时，当最短路径发生更改时， $\mathrm{path}_{k-1}$  就不是  $\mathrm{path}_k$  的子集。

# 08. C

在负权图中，Dijkstra算法既不能保证每次选出的顶点都是真正的最近顶点，又不能保证已确定的最短路径不再被改变，因此Dijkstra算法不允许边的权为负，选项I正确。求每对顶点间的最短路径需要调用Dijkstra算法  $n$  次，时间复杂度为  $O(n^{3})$ ，选项II错误。Floyd算法求每对顶点间的最短路径允许有负边的存在，但不允许包含总权值为负的回路，选项III正确。

# 09. B

题目所描述的图  $G$  如下图所示。A, B, C, D对应的路径长度分别为18, 13, 15, 24。应用Dijkstra算法不难求出最短路径为  $\nu_{1} \rightarrow \nu_{3} \rightarrow \nu_{4} \rightarrow \nu_{6} \rightarrow \nu_{7}$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9a4650ff61a5ee2acdd18c061fc0436ea80065275a5f92c04a9b51c08b0cf14e.jpg)


10. D

在Dijkstra算法的执行过程中，只可能修改从源点0到集合  $V - S$  中某个顶点的最短路径。

11. A

使用深度优先遍历，若从有向图上的某个顶点  $u$  出发，在  $\mathrm{DFS}(u)$  结束之前出现一条从顶点  $v$  到  $u$  的边， $v$  在生成树上是  $u$  的子孙，图中必定存在包含  $u$  和  $v$  的环，因此深度优先遍历可以检测一个有向图是否有环。拓扑排序时，当某顶点不为任何边的头时才能加入序列，存在环时环中的顶点一直是某条边的头，不能加入拓扑序列。也就是说，还存在无法找到下一个可以加入拓扑序列的顶点，则说明此图存在回路。求最短路径是允许图有环的。至于关键路径能否判断一个图有环，则存在一些争议。关键路径本身虽然不允许有环，但求关键路径的算法本身无法判断是否有环，判断是否有环是求关键路径的第一步——拓扑排序。

12. D

若图  $G$  中存在一条从  $\nu_{j}$  到  $\nu_{i}$  的路径，说明  $V_{j}$  是  $V_{i}$  的前驱，则要把  $V_{j}$  消去以后才能消去  $V_{i}$ ，从而拓扑序列中必然先输出  $\nu_{j}$ ，再输出  $\nu_{i}$ ，这显然与题意矛盾。

13. D

对于I，若有向图中存在环，运行拓扑排序算法后，肯定会剩下有环的子图，在此环中无法再找到入度为0的顶点，拓扑排序也就无法再运行。对于II，若两个顶点之间不存在祖先或子孙关系，则它们在拓扑序列中的前后关系是任意的，因此使用栈和队列都可以，因为入栈或队列的都是入度为0的顶点。III项是难点，若拓扑序列唯一，则很自然联想到一个线性的有向图，下图的拓扑序列也唯一，但却不满足该条件。对于IV，若入度为0的顶点不唯一，则这些顶点均可作为拓扑序列的起点；若出度为0的顶点不唯一，则这些顶点均可作为拓扑序列的终点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3ecf298ac7fb22561870212ca776ccab3f10500be5df24b22f88ef1c2999b9f3.jpg)


14.C

强连通图是指有向图中任意顶点对之间都存在两条相反的路径，这意味着强连通图中一定存在环，因此不能进行拓扑排序，选项I正确。假设顶点  $a$  和  $b$  的入度均为0，且分别有两条弧从  $a$  和  $b$  指向同一顶点  $c$  ，则产生的拓扑序列可以是  $abc$  ，但是此时并无一条弧  $\langle a, b \rangle$  ，选项II错误。如图1和2所示的有向图对应的拓扑序列都是abcd，且都是唯一的，选项III错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5b572226ff444c734fcb942d4ccab5ee7f567ffa71fc85f8f5d187f159d6156e.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/69f21ad3c6dd985df617d993b1fd59761fad7614cf10a7685ec77a2612b264fd.jpg)



图2


15. D

一个有向图中的顶点不能排成一个拓扑序列，表明其中存在一个顶点数目大于1的回路（环），该回路构成一个强连通分量，从而答案选择选项D。

# 16. C

本图的拓扑排序序列有ABCFDEG, ABCDFEG, ABCDEFG, ABDCFEG和ABDCEFG。读者应能把这一类经典习题的拓扑序列全部写出来。

# 17. A

拓扑序列的过程：找到入度为0的顶点，删除该顶点及其所有出边，并将顶点加入拓扑序列，重复直至所有顶点都加入拓扑序列。选择入度为0的顶点  $v_{1}$ ，删除与  $v_{1}$  有关的边；此时顶点  $v_{3}$  的入度为0，选择  $v_{3}$ ，删除与  $v_{3}$  有关的边；以此类推，得出  $G$  的拓扑序列。

# 18. B

无向图的邻接矩阵存储中，每条边存储两次，且  $A[i][j] = A[j][i]$ 。

# 19. C

此题一直以来争议较大，因为有些书中漏掉了“有序”二字。可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元素全为零的充分必要条件是，该有向图可以进行拓扑排序。若这个题目把“有序”二字去掉，显然应选择选项D。但此题题干中已经指出是“有序的拓扑序列”，因此应选选项C。需要注意的是，若一个有向图的邻接矩阵为三角矩阵（对角线以上或以下的元素为0），则图中必不存在环，因此其拓扑序列必然存在。

# 20. A

设图中有顶点  $v_{i}$ ，它有后继顶点  $v_{j}$ ，即存在边  $< v_{i}, v_{j} >$  。根据DFS的规则，  $v_{i}$  入栈后，必先遍历完其后继顶点后  $v_{i}$  才会出栈，也就是说  $v_{i}$  会在  $v_{j}$  之后出栈，在如题所指的过程中，  $v_{i}$  在  $v_{j}$  后打印。  $v_{i}$  和  $v_{j}$  具有任意性，因此由上面的规律看出，输出顶点的序列是逆拓扑有序序列。

对有向无环图利用深度优先搜索进行拓扑排序的例子如下：如下图所示，退出DFS栈的顺序为efgdcahb，此图的一个拓扑序列为bhacdgfe。该方法的每一步均是先输出当前无后继的结点，即对每个结点  $\nu$  ，先递归地求出  $\nu$  的每个后继的拓扑序列。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9677119272c0127c355e693927e364ec51f94426a2cbd4df4ab8025f5ee54efe.jpg)


# 21. C

有向图邻接矩阵的第  $V$  行中1的个数是顶点  $V$  的出度，而有向图中顶点的度为入度与出度之和，选项I错。无向图的邻接矩阵一定是对称矩阵，但当有向图中任意两个顶点之间有边相连，且是两条方向相反的有向边时，有向图的邻接矩阵也是一个对称矩阵，选项Ⅱ错。最小生成树中的  $n - 1$  条边不能保证是图中权值最小的  $n - 1$  条边，因为权值最小的  $n - 1$  条边并不一定能使图连通。在下图中，左图的最小生成树如下图所示，权值为3的边不在其最小生成树中。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/193efc60e803609902301362ac770b2bc4c10b1e2754d38b73d65a2b74244001.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/076739ae7ccc4a094d0962668fdeba6f6110c3572a33d90d83da2fcbd07de53e.jpg)


有向无环图的拓扑序列唯一并不能唯一确定该图。在下图所示的两个有向无环图中，拓扑序列都为  $V_{1}, V_{2}, V_{3}, V_{4}$ ，IV错。注意，很多辅导书对该命题的判断是错误的。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e3aedc63ac7b838dd27e524db900550eed47914e8d4bd6a12ac174e58b3c4eaf.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5bcaba900fca30d4c66459e1775b45b4c024729d52874236e0df1505d9a25206.jpg)


22.C

观察题图，从  $V_{0}$  到  $V_{8}$  的最长路径为  $V_{0} \rightarrow V_{1} \rightarrow V_{4} \rightarrow V_{6} \rightarrow V_{8}$ ，长度为  $6 + 1 + 9 + 2 = 18$ 。

23.C

题目描述的图如下，得到关键路径的长度为21，图中画出的两条路径都是关键路径。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6b6501166a76b1ecd574b1c4f4b669e42858cc19a59edb1379bbc48f0722d75b.jpg)


24.C

一个事件的最迟发生时间  $= \min$  {以该事件为尾的弧的活动的最迟开始时间}，或  $\min$  {以该事件为尾的弧所指事件的最迟发生时间与该弧的活动的持续时间之差}。改变AOE网中任何一个活动的持续时间，需要重新计算关键活动，可能导致关键路径的改变。

25.C

若改变的是所有关键路径上的公共活动，则不一定会产生不同的关键路径（延长必然不会导致，只有缩短才有可能导致）。根据关键路径的定义，可知选项Ⅱ正确。关键路径是源点到终点的最长路径，只有所有关键路径的长度都缩短时，整个图的关键路径才能有效缩短，但也不能任意缩短，一旦缩短到一定程度，该关键活动就可能变成非关键活动。

26. A

邻接矩阵第  $i$  列值全为  $\infty$  ，说明顶点  $i$  没有入边，为整个工程的开始，若关键路径存在，则该顶点一定是起点。不能确定关键路径是否存在，也不能确定其对应的无向图的连通分量个数。

27. B

拓扑排序的过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ae85e384dbe68a65d75002b92fb694861991465911fabc93ce56a50a0ec500f3.jpg)


可以得到3种不同的拓扑序列，即abcd、abcd和aebcd。

28. A

最小生成树的树形可能不唯一（因为可能存在权值相同的边），但代价一定是唯一的，I 正

确。若权值最小的边有多条并且构成环状，则总有权值最小的边将不出现在某棵最小生成树中，II错误。设  $N$  个结点构成环，  $N$  条边的权值相等，从不同的顶点开始执行Prim算法，只要选取任意不同的  $N - 1$  条边，就能得到不同的最小生成树，III错误。当最小生成树唯一时（各边的权值不同)，Prim算法和Kruskal算法得到的最小生成树相同，IV错误。

# 29. C

从  $a$  到各顶点的最短路径的求解过程下：

<table><tr><td>顶点</td><td>第1轮</td><td>第2轮</td><td>第3轮</td><td>第4轮</td><td>第5轮</td></tr><tr><td>b</td><td>(a,b)2</td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>(a,c)5</td><td>(a,b,c)3</td><td></td><td></td><td></td></tr><tr><td>d</td><td>∞</td><td>(a,b,d)5</td><td>(a,b,d)5</td><td>(a,b,d)5</td><td></td></tr><tr><td>e</td><td>∞</td><td>∞</td><td>(a,b,c,e)7</td><td>(a,b,c,e)7</td><td>(a,b,d,e)6</td></tr><tr><td>f</td><td>∞</td><td>∞</td><td>(a,b,c,f)4</td><td></td><td></td></tr><tr><td>集合S</td><td>{a,b}</td><td>{a,b,c}</td><td>{a,b,c,f}</td><td>{a,b,c,f,d}</td><td>{a,b,c,f,d,e}</td></tr></table>

后续目标顶点依次为  $f, d, e$ 。

本题也可用排除法：对于A，若下一个顶点为  $d$  ，路径  $a, b, d$  的长度为5，而  $a, b, c, f$  的长度仅为4，显然错误。同理可排除B。将  $f$  加入集合  $S$  后，采用上述方法也可排除D。

# 30. C

对角线以下元素均为零，表明只有顶点  $i$  到  $j (i < j)$  可能有边，而顶点  $j$  到  $i$  一定没有边，即有向图是一个无环图，因此一定存在拓扑序列。对于拓扑序列是否唯一，试举一例：设有向图的邻接矩阵  $\begin{bmatrix} 0 & 1 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}$ ，存在两个拓扑序列，因此该图存在可能不唯一的拓扑序列。

结论：对于任一有向图，若它的邻接矩阵中对角线以下（或以上）的元素均为零，则存在拓扑序列（可能不唯一）。反之，若图存在拓扑序列，却不一定能满足邻接矩阵中主对角线以下的元素均为零，但是可以通过适当地调整结点编号，使其邻接矩阵满足前述性质。

# 31. C

找出AOE网的全部关键路径为  $bdcg$  、bdeh和  $bfh$  。根据性质，只有当所有关键路径的活动时间同时减少时，才能缩短工期。即正确选项中的路径必须能涵盖所有的关键路径。选项A和B不能涵盖  $bfh$  这条路径，选项D不能涵盖  $bdcg$  这条路径，只有选项C能涵盖所有关键路径，因此只有加快  $f$  和  $d$  的进度才能缩短工期（建议在图中检验）。

# 32. D

按照拓扑排序的算法，每次都选择入度为0的结点从图中删除，此图中一开始只有结点3的入度为0；删除结点3后，只有结点1的入度为0；删除结点1后，只有结点4的入度为0；删除结点4后，结点2和结点6的入度都为0，此时选择删除不同的结点，会得出不同的拓扑序列，分别处理完毕后可知可能的拓扑序列为3,1,4,2,6,5和3,1,4,6,2,5。

# 33.C

从  $V_{4}$  开始，Kruskal算法选中的第一条边一定是权值最小的  $(V_{1}, V_{4})$  ，B错误。  $V_{1}$  和  $V_{4}$  已经可达，因此含有  $V_{1}$  和  $V_{4}$  的权值为8的第二条边一定符合Prim算法，排除A和D。

# 34. C

第一个顶点和最后一个顶点相同的路径称为回路；序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，选项I错误。稀疏图是边比较少的情况，邻接矩阵存储的空间复杂度为  $O(n^{2})$  ，必将浪费大量的空间，而邻接表存储的空间复杂度为  $O(n + e)$  ，所以应选用邻接

表，选项II错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，选项III正确。

# 35. B 公众号：小兔网盘 免费分享无水印PDF

根据Dijkstra算法，从顶点1到其余各顶点的最短路径如下表所示。

<table><tr><td>顶点</td><td>第1轮</td><td>第2轮</td><td>第3轮</td><td>第4轮</td><td>第5轮</td></tr><tr><td>2</td><td>5v1→v2</td><td>5v1→v2</td><td></td><td></td><td></td></tr><tr><td>3</td><td>∞</td><td>∞</td><td>7v1→v2→v3</td><td></td><td></td></tr><tr><td>4</td><td>∞</td><td>11v1→v5→v4</td><td>11v1→v5→v4</td><td>11v1→v5→v4</td><td>11v1→v5→v4</td></tr><tr><td>5</td><td>4v1→v5</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>∞</td><td>9v1→v5→v6</td><td>9v1→v5→v6</td><td>9v1→v5→v6</td><td></td></tr><tr><td>集合S</td><td>{1,5}</td><td>{1,5,2}</td><td>{1,5,2,3}</td><td>{1,5,2,3,6}</td><td>{1,5,2,3,6,4}</td></tr></table>

快速解法。依次观察从顶点1到其他顶点的最短路径长度：顶点1到顶点2的最短路径长度为5；顶点1到顶点3的最短路径长度为  $5 + 2 = 7$  ；顶点1到顶点4的最短路径长度为11；顶点1到顶点5的最短路径长度为4；顶点1到顶点6的最短路径长度为  $4 + 5 = 9$  ；最终dist[]  $= \{0,5,7,11,4,9\}$ ，根据dist数组值从小到大选择顶点顺序为1,5,2,3,6,4。

# 36. B

采用邻接表作为AOV网的存储结构进行拓扑排序，需要对  $n$  个顶点做入栈、出栈、输出各一次，当处理  $e$  条边时，需要检测这  $n$  个顶点的边链表结点，共需要的时间为  $O(n + e)$  。若采用邻接矩阵作为AOV网的存储结构进行拓扑排序，在处理  $e$  条边时需对每个顶点检测相应矩阵中的某一行，寻找与它相关联的边，以便对这些顶点的入度减1，需要的时间代价为  $O(n^{2})$  。

【补充】有两种常用的拓扑排序算法：基于BFS的算法和基于DFS的算法。本题未指明采用哪种算法，因此只需验证一种算法即可（说明两种算法在对应条件下的时间复杂度相同）。

基于BFS的算法的思想：首先找到所有入度为0的结点，将它们加入一个队列，并将它们作为拓扑序列的起始部分；然后依次从队列中取出结点，并删除它们与后继结点的所有边。若某个后继结点的入度变为0，则将它也加入队列，并将它加入拓扑序列，重复这个过程。

基于DFS的算法的思想：在DFS调用过程中设定一个时间标记，当DFS调用结束时，对各结点计时，进而按结束时间从大到小排序，可以得到一个拓扑序列。

# 37. D

拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1,5或5,1（因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱）。

# 38. C

活动  $d$  的最早开始时间等于该活动弧的起点所表示的事件的最早发生时间，活动  $d$  的最早开始时间等于事件2的最早发生时间  $\max \{a,b + c\} = \max \{3,12\} = 12$  。活动  $d$  的最迟开始时间等于该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差，先算出图中关键路径长度为27（对于不复杂的选择题，找出所有路径计算长度)，那么事件4的最迟发生时间为  $\min \{27 - g\} = \min \{27 - 6\} = 21$  ，活动  $d$  的最迟开始时间为  $21 - d = 21 - 7 = 14$  。

常规方法：按照关键路径算法算得到下表。

<table><tr><td></td><td>\( v_1 \)</td><td>\( v_2 \)</td><td>\( v_3 \)</td><td>\( v_4 \)</td><td>\( v_5 \)</td><td>\( v_6 \)</td></tr><tr><td>\( v_e(t) \)</td><td>0</td><td>12</td><td>8</td><td>19</td><td>18</td><td>27</td></tr><tr><td>\( v_f(t) \)</td><td>0</td><td>12</td><td>8</td><td>21</td><td>18</td><td>27</td></tr></table>

<table><tr><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td></tr><tr><td>e(i)</td><td>0</td><td>8</td><td>0</td><td>12</td><td>12</td><td>8</td><td>19</td><td>18</td></tr><tr><td>l(i)</td><td>9</td><td>8</td><td>0</td><td>14</td><td>12</td><td>8</td><td>21</td><td>18</td></tr><tr><td>l(i) - e(i)</td><td>9</td><td>0</td><td>0</td><td>2</td><td>0</td><td>0</td><td>2</td><td>0</td></tr></table>

从表中可知，活动  $d$  的最早开始时间和最迟开始时间分别为12和14，所以选择选项C。

# 39. A

先将该表达式转换成有向二叉树，该二叉树中有些顶点是重复的，为了节省存储空间，去除重复的顶点，将有向二叉树去重转换成有向无环图，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/67acb60c3f9091ef1d61e0bf78edada523769e04fece5aa94fd95ed115991974.jpg)


# 40. A

Kruskal 算法：按权值递增顺序依次选取  $n - 1$  条边，并保证这  $n - 1$  条边不构成回路。初始构造一个仅含  $n$  个顶点的森林；第一步，选取权值最小的边  $(b, f)$  加入最小生成树；第二步，剩余边中权值最小的边为  $(b, d)$ ，加入最小生成树，第二步操作后权值最小的边  $(d, f)$  不能选，因为会与之前已选取的边形成回路；接下来依次选取权值9、10、11对应的边加入最小生成树，此时6个顶点形成了一棵树，最小生成树构造完成。按照上述过程，加到最小生成树的边依次为  $(b, f)$ ， $(b, d)$ ， $(a, e)$ ， $(c, e)$ ， $(b, e)$ 。其生成过程如下所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0611b5bbac467dad2be8e7bd85fb2a77dbee1eaeeed93f619c1ecaafa5ab7f36.jpg)



第一步



选取边  $< b, f>$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fe0566f0e97e1411f3206e932e316fc5dd40e2c07d451299044fb8d5b041eb46.jpg)



第二步



选取边  $< b, d>$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7e1ab4fb5a1ad3e208ee2805b64f49158c98503eb0ccf1a37cfbc66c370a3b3b.jpg)



第三步



选取边  $<  a.e>$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8577384fc7db2d1e95fe92f901c1d11caa3477c84852d021c8e932ee268d556d.jpg)



第四步



选取边  $<  c,e>$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/20a038f7a78e51824c1e7d087928e92e4c7b93c96292d1d704301b5c92d8af1c.jpg)



第五步



选取边  $< b, e>$


# 41. B

根据题干所提供的信息可知：

① 图  $G$  为有向无环图，因此一定存在拓扑序列和逆拓扑序列。

②DFS的性质是顶点  $\nu_{i}$  的所有后继顶点  $\nu_{j}$  出栈后，  $\nu_{i}$  才会出栈。

③本题要求执行输出语句后立刻退出递归，即执行完输出语句后立即出栈，因此后入栈的

顶点先输出，结合②不难得出只有输出顶点  $v_{i}$  的所有后继顶点  $v_{j}$  后，  $v_{i}$  才会输出。

综合上述分析，输出的顶点序列是逆拓扑有序序列。

# 42. B

关键路径是指权值之和最大而非边数最多的路径，选项A错误。选项B是关键路径的概念。无论是存在一条还是存在多条关键路径，增加任意一个关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，选项C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期；存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径，选项D错误。

# 43. A

求拓扑序列的过程：从图中选择无入边的结点，输出该结点并删除该结点的所有出边，重复上述过程，直至全部结点都已输出，这样求得的拓扑序列为  $ABCDEF$  。每次输出一个结点并删除该结点的所有出边后，都发现有且仅有一个结点无入边，因此该拓扑序列唯一。

# 44.C

在执行Dijkstra算法时，首先初始化dist[]，若顶点1到顶点  $i$  （ $i = 2,3,4,5$ ）有边，就初始化为边的权值；若无边，就初始化为  $\infty$ ；初始化顶点集  $S$  只含顶点1。Dijkstra算法每次选择一个到顶点1距离最近的顶点  $j$  加入顶点集  $S$ ，并判断由顶点1绕行顶点  $j$  后到任意一个顶点  $k$  是否距离更短，若距离更短（ $\mathrm{dist}[j] + \mathrm{arcs}[j][k] < \mathrm{dist}[k]$ ），则将  $\mathrm{dist}[x]$  更新为  $\mathrm{dist}[j] + \mathrm{arcs}[j][k]$ ；重复该过程，直至所有顶点都加入顶点集  $S$ 。数组dist的变化过程如下图所示，可知将第二个顶点5加入顶点集S后，数组dist更新为21,3,14,6。

$$
\mathrm {d i s t} \{2 6, 3, \infty , 6 \} \xrightarrow {\text {顶 点} 3 \text {入 S}} \{2 5, 3, \infty , 6 \} \xrightarrow {\text {顶 点} 5 \text {入 S}} \{2 1, 3, 1 4, 6 \}
$$

# 45. B

在AOE网中，活动的时间余量  $=$  结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的持续时间。根据关键路径算法得到下表：

<table><tr><td>结点编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>最早开始时间vc(i)</td><td>0</td><td>2</td><td>5</td><td>8</td><td>9</td><td>12</td></tr><tr><td>最迟开始时间vt(i)</td><td>0</td><td>4</td><td>5</td><td>8</td><td>11</td><td>12</td></tr></table>

$c$  的时间余量  $= v_{f}(3) - v_{e}(2) - 1 = 5 - 2 - 1 = 2$  ，  $g$  的时间余量  $= v_{f}(6) - v_{e}(3) - 1 = 12 - 5 - 1 = 6$  ，  $h$  的时间余量  $= v_{f}(5) - v_{e}(4) - 1 = 11 - 8 - 1 = 2$  ，  $j$  的时间余量  $= v_{f}(6) - v_{e}(5) - 1 = 12 - 9 - 1 = 2$  。

# 46. B

Prim算法和Kruskal算法用于求解最小生成树，最小生成树中某顶点到其余各顶点的路径不一定具有最短路径的性质。例如，在下图所求得的最小生成树中，  $a$  到  $c$  的路径长度为2，但原图中  $a$  到  $c$  的最短路径长度为1。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3fecac0285fe3cc996ae07204b6eb4d6fafd6354d67124ef17a187489a0ab4cd.jpg)


图的广度优先搜索算法总按距离由近到远来遍历图中的每个顶点，因此可用来求解非带权图（或各边权值均相同）的单源最短路径问题。

# 二、综合应用题

# 01.【解答】

这种方法是正确的。

经过“破圈法”之后，最终没有回路，因此一定可以构造出一棵生成树。下面证明这棵生成树是最小生成树。记“破圈法”生成的树为  $T$  ，假设  $T$  不是最小生成树，则必然存在最小生成树  $T_{0}$  ，使得它与  $T$  的公共边尽可能多，则将  $T_{0}$  与  $T$  取并集，得到一个图，此图中必然存在回路，“破圈法”的定义就是从回路中去除权最大的边，因此此时生成的  $T$  的权必然是最小的，这与原假设矛盾，从而  $T$  是最小生成树。下图说明了“破圈法”的过程：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f7ac304f15d067860e5c37b41276910c70bea0c6dfc545c7d38d8d7b5386088c.jpg)


# 02.【解答】

# 1）该图的邻接矩阵为

$$
\boldsymbol {A} = \begin{array}{c c c c c c c} 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 1 & 0 & 3 & 3 & 6 & \infty & \infty & \infty \\ 2 & \infty & 0 & 4 & \infty & 5 & \infty & \infty \\ 3 & \infty & \infty & 0 & \infty & 4 & \infty & \infty \\ 4 & \infty & \infty & \infty & 0 & \infty & 5 & \infty \\ 5 & \infty & \infty & \infty & \infty & 0 & \infty & 3 \\ 6 & \infty & \infty & 3 & \infty & \infty & 0 & 7 \\ 7 & \infty & \infty & \infty & \infty & \infty & \infty & 0 \end{array}
$$

得到的深度优先遍历序列为1,2,3,5,7,4,6。

2）解题思路：当某个顶点只有出弧而没有入弧时，其他顶点无法到达这个顶点，不可能与其他顶点和边构成强连通分量（这个单独的顶点构成一个强连通分量）。

① 顶点1无入弧构成第一个强连通分量。删除顶点1及所有以之为尾的弧。

② 顶点2无入弧构成一个强连通分量。删除顶点2及所有以之为尾的弧。

$③$

以此类推，最后得到每个顶点都是一个强连通分量，所以强连通分量数目为7。

3）该图的两个拓扑序列如下：

$①$  1,2,4,6,3,5,7

$②$  1,4,2,6,3,5,7

4）若视该图为无向图：

用 Prim 算法生成最小生成树的过程如下：

1—2，1—3，3—6，3—5，5—7，6—4（图略）。

用Kruskal算法生成最小生成树的过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cc2fde1fd6cf034c816cbe618b3bacb5856a09f1fc3278d18237b18213aef020.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d889a17cc8d3411a4de6bec0f8a5ae34621f489459fc30729fd2a97254a5f06b.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a9b8f612b99bfad571cd89af06839cea0239d9360a926d3cc926421509a26692.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/286b6fac0ac6e3bd4f8c6f6bb7de0843be7c47e9581107406d37597fa3dcedda.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0af3dc532ffb0e01327030fd9ddb8890482c44bcce4c0343b384498ac6f0c6c0.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6ccf01e46d09c8b59a757e60a16ff492cb3cea2e633d95dca81eaacb5fb50646.jpg)


# 03.【解答】

根据Dijkstra算法，求从顶点1到其余各顶点的最短路径如下表所示。

<table><tr><td rowspan="2">顶点</td><td colspan="5">从顶点1到各终点的dist值</td></tr><tr><td>第1轮</td><td>第2轮</td><td>第3轮</td><td>第4轮</td><td></td></tr><tr><td>2</td><td>7v1, v2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>11v1, v3</td><td>11v1, v3</td><td></td><td></td><td></td></tr><tr><td>4</td><td>∞</td><td>16v1, v2, v4</td><td>16v1, v2, v4</td><td></td><td></td></tr><tr><td>5</td><td>∞</td><td>∞</td><td>18v1, v3, v5</td><td>18v1, v3, v5</td><td></td></tr><tr><td>6</td><td>∞</td><td>∞</td><td>19v1, v3, v6</td><td>19v1, v3, v6</td><td>19v1, v3, v6</td></tr><tr><td>集合S</td><td>{1,2}</td><td>{1,2,3}</td><td>{1,2,3,4}</td><td>{1,2,3,4,5}</td><td>{1,2,3,4,5,6}</td></tr></table>

# 04.【解答】

1）该图的邻接表表示如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b9c9be2ce52cf682bbd749ec6f52aba722f48b6f858899eccddcc65f03301c88.jpg)


求关键路径的算法如下：

① 输入  $e$  条弧  $\langle j, k \rangle$  ，建立AOE网的存储结构。

② 从源点  $v_{1}$  出发，令  $v_{e}(1) = 0$ ，求  $v_{e}(j)$ ， $2 \leqslant j \leqslant n$ 。

③ 从汇点  $v_{n}$  出发，令  $v_{1}(n) = v_{e}(n)$ ，求  $v_{1}(i)$ ， $1 \leqslant i \leqslant n - 1$ 。

④ 根据各顶点的  $\nu_{e}$  和  $\nu_{1}$  值，求每条弧  $s$  （活动）的最早开始时间  $e(s)$  和最晚开始时间  $l(s)$ ，其中  $e(s) = l(s)$  为关键活动。

2）根据以上算法可以得到至少需要时间16。

3）关键路径为  $(V_{1}, V_{3}, V_{5}, V_{7}, V_{9})$ 。

4）活动  $a_{2}, a_{6}, a_{9}, a_{12}$  加速，可以缩短工程所需的时间。

# 05.【解答】

1）根据题表可以画出AOE网如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5b57f3b874f694e2c3cab3dc30b7153ba6c0ac537f4c0f514a841a0871ba125c.jpg)


求解各事件和活动的最早发生时间与最迟发生时间公式分别如下：

①  $v_{e}$  (源点) = 0，  $v_{e}(k) = \operatorname{Max}\{v_{e}(j) + \operatorname{Weight}(v_{j}, v_{k})\}$ ，  $\operatorname{Weight}(v_{j}, v_{k})$  表示从  $v_{j}$  指向  $v_{k}$  的弧的权值。

②  $v_{1}($  汇点）  $= v_{e}($  汇点），  $v_{1}(j) = \mathrm{Min}\{v_{1}(k) - \mathrm{Weight}(v_{j},v_{k})\}$ ，Weight  $(v_{j},v_{k})$  表示从  $v_{j}$  指向  $v_{k}$  的弧的权值。

③ 若边  $< v_{k}, v_{j}>$  表示活动  $a_{i}$ ，则有  $e(i) = v_{e}(k)$ 。

④ 若边  $< v_{k}, v_{j}>$  表示活动  $a_{i}$ ，则有  $l(i) = v_{1}(j) - \text{Weight}(v_{k}, v_{j})$ 。

⑤  $d(i) = l(i) - e(i)$ 。

关键路径即由  $d(i) = 0$  的  $i$  构成。

2）根据上述公式，各事件的最早发生时间  $\nu_{e}$  和最迟发生时间  $\nu_{l}$  如下表所示。

<table><tr><td></td><td>\( v_1 \)</td><td>\( v_2 \)</td><td>\( v_3 \)</td><td>\( v_4 \)</td><td>\( v_5 \)</td><td>\( v_6 \)</td></tr><tr><td>\( v_c(i) \)</td><td>0</td><td>3</td><td>2</td><td>6</td><td>6</td><td>8</td></tr><tr><td>\( v_f(i) \)</td><td>0</td><td>4</td><td>2</td><td>6</td><td>7</td><td>8</td></tr></table>

3）根据上述公式，各活动最早发生时间  $e$  、最迟发生时间  $l$  和时间余量  $d(i) = l(i) - e(i)$  如下表所示。

<table><tr><td></td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td></tr><tr><td>e(i)</td><td>0</td><td>0</td><td>3</td><td>3</td><td>2</td><td>3</td><td>6</td><td>6</td></tr><tr><td>l(i)</td><td>1</td><td>0</td><td>4</td><td>4</td><td>2</td><td>5</td><td>6</td><td>7</td></tr><tr><td>l(i)-e(i)</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>2</td><td>0</td><td>1</td></tr></table>

所以关键路径为  $B$  、  $E$  、  $G$  ，完成该工程最少需要8（单位依题意而定）。

# 06.【解答】

Dijkstra算法每一步都会贪婪地选择与源点  $\nu_{0}$  最近的下一条边，直到  $\nu_{0}$  连接到图中所有顶点。Prim算法（已知是最小生成树算法）与Dijkstra算法高度相似，但是在每个阶段，它贪婪地选择与该阶段已加入MST中任意一个顶点最近的下一条边。显然，Dijkstra算法可以产生一棵生成树，但该树不一定是最小生成树，只需举出一个反例即可，以下图  $G$  为例（将a作为源点）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/421798476eb698b3042390f029203ed418905121bb84195f0fc54f9d7c877796.jpg)



(a) 图  $G$


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/36d87c158d2a40ad1bd7f6586998181525300b8c8d6d0a2dc212f150dd9d045d.jpg)



(b) 两种算法产生的生成树


Dijkstra算法得到的路径集合为  $\{(a,b),(a,c),(a,d)\}$  ，该生成树的总权值为  $5 + 5 + 5 = 15$  。

Prim算法得到的边集合为  $\{(a,d),(b,d),(c,d)\}$  ，该最小生成树的总权值为  $5 + 1 + 1 = 7$  。

显然，Dijkstra算法得到的生成树不一定是最小生成树。

# 07.【解答】

本节前面给出了DFS实现拓扑排序的思想，下面是利用DFS求各顶点结束时间的代码（在DFS的基础上加入了time变量）。将结束时间从大到小排序，即可得到拓扑序列。

```c
bool visited [MAX_VERTEX_NUM]; //访问标记数组  
void DFSTraverse (Graph G) {  
    for (v = 0; v < G.vexnum; ++v)  
        visited[v] = FALSE; //初始化访问标记数组  
    time = 0;  
    for (v = 0; v < G.vexnum; ++v) //本代码从 v = 0 开始遍历  
        if (!visited[v]) DFS(G, v);  
}  
void DFS (Graph G, int v) {  
    visited[v] = TRUE;  
    visit(v);  
    for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w))  
        if (!visited[w]) { //w为 v 的尚未访问的邻接点  
            DFS(G, w);  
        }  
    time = time + 1;  
finishTime[v] = time;  
}
```

# 08.【解答】

该方法不一定能（或不能）求得最短路径。

例如，对于下图所示的带权图，若按照题中的原则，从  $A$  到  $C$  的最短路径是  $A \rightarrow B \rightarrow C$  ，事实上其最短路径是  $A \rightarrow D \rightarrow C$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7d6bd57488adeeb972a34d400c420445c1ef21aa61632be4be7e91f0c66745a3.jpg)


# 09.【解答】

1）在上三角矩阵A[6][6]中，第1行至第5行主对角线上方的元素个数分别为5,4,3,2,1，

由此可以画出压缩存储数组中的元素所属行的情况，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/07ebedb1df666e2a34a46fcdefe97e1fe79b253948bd87d5108bfa2cb31c2d98.jpg)


可以用“平移”的思想，将前5个、后4个、后3个、后2个、后1个元素，分别移动到矩阵对角线（“0”）右边的行上。图  $G$  的邻接矩阵  $\mathbf{A}$  为

$$
\boldsymbol {A} = \left[ \begin{array}{c c c c c c} 0 & 4 & 6 & \infty & \infty & \infty \\ \infty & 0 & 5 & \infty & \infty & \infty \\ \infty & \infty & 0 & 4 & 3 & \infty \\ \infty & \infty & \infty & 0 & \infty & 3 \\ \infty & \infty & \infty & \infty & 0 & 3 \\ \infty & \infty & \infty & \infty & \infty & 0 \end{array} \right]
$$

2）有向带权图  $G$  如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e5fb5f0952944453f0acbb2b6e2beeb2e9e83facad3aa692a1ff34292d50b09a.jpg)


3）先计算各个事件的最早发生时间，得到  $v_{e}(.)$  和  $v_{f}(.)$  数组如下表所示。

<table><tr><td>i</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>ve(i)</td><td>0</td><td>4</td><td>9</td><td>13</td><td>12</td><td>16</td></tr><tr><td>vi(i)</td><td>0</td><td>4</td><td>9</td><td>13</td><td>13</td><td>16</td></tr></table>

接下来计算所有活动的最早和最迟发生时间  $e()$  和  $l()$ ，如下表所示。

<table><tr><td></td><td>\( {a}_{0 - 1} \)</td><td>\( {a}_{0 - 2} \)</td><td>\( {a}_{1 - 2} \)</td><td>\( {a}_{2 - 3} \)</td><td>\( {a}_{2 - 4} \)</td><td>\( {a}_{3 - 5} \)</td><td>\( {a}_{4 - 5} \)</td></tr><tr><td>\( e\left( \right) \)</td><td>0</td><td>0</td><td>4</td><td>9</td><td>9</td><td>13</td><td>12</td></tr><tr><td>\( l\left( \right) \)</td><td>0</td><td>3</td><td>4</td><td>9</td><td>10</td><td>13</td><td>13</td></tr><tr><td>\( l\left( \right)  - e\left( \right) \)</td><td>0</td><td>3</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></table>

满足  $l() - e() = 0$  的路径就是关键路径，所以关键路径为  $a_{0\rightarrow 1},a_{1\rightarrow 2},a_{2\rightarrow 3},a_{3\rightarrow 5}$ ，如下图所示（双线箭头表示），长度为  $4 + 5 + 4 + 3 = 16$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/51e6cb5b5752cf2fb5ca1e77ed8bbd8328d53cbda16b1f86521cc54b5e85fb8c.jpg)


按求关键路径的公式计算较为复杂，建议考生面临此类题时直接穷举各条路径即可。

# 10.【解答】

本题初看起来感觉难度较大，但仔细分析就可发现考查的其实是邻接表的数据结构。

1）图题中给出的是一个简单的网络拓扑图，可以抽象为无向图。

2）图的常用存储结构有邻接矩阵法和邻接表法，其中邻接表法属于链式存储结构，因此本题的基本思路就是写出邻接表的数据类型定义，并根据题意调整相应的边表结点和顶点表结点的成员变量。具体分析如下：邻接表由表头顶点和弧顶点组成。根据题目给出的图和表，可将顶点分为三类：路由器、网络和链路。路由器是连接网络和链路的载体，因此可将它作为表头顶点。网络和链路则是连接路由器的边，因此可将它们作为弧顶

点。为了简化代码，可将网络和链路的结构合并为一个，用一个标志位来区分它们，这样就可用邻接表来实现图的存储。链式存储结构如下图所示。


弧结点的两种基本形态


<table><tr><td>Flag=1 Next</td><td>Flag=2 Next</td></tr><tr><td>ID</td><td>Prefix</td></tr><tr><td>IP</td><td>Mask</td></tr><tr><td>Metric</td><td>Metric</td></tr></table>

其数据类型定义如下：

```txt
typedef struct{ unsigned int ID，IP; }LinkNode; //Link的结构 typedef struct{ unsigned int Prefix，Mask; }NetNode; //Net的结构 typedef struct Node{ int Flag; //Flag=1为Link;Flag=2为Net union{ LinkNode Lnode; NetNode Nnode }LinkORNet; Unsigned int Metric; struct Node \*next; }ArcNode; //弧结点 typedef struct hNode{ unsigned int RouterID; ArcNode \*LN link; Struct hNode \*next; }HNODE; //表头结点
```

对应表的链式存储结构示意图如下所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/35c929f2594a20f8d4f86aaad5735a2b9a7f421cd8e74c4112407bc50cc29e95.jpg)


3）计算结果如下表所示。

<table><tr><td></td><td>目的网络</td><td>路径</td><td>代价(费用)</td></tr><tr><td>步骤1</td><td>192.1.1.0/24</td><td>直接到达</td><td>1</td></tr><tr><td>步骤2</td><td>192.1.5.0/24</td><td>R1→R3→192.1.5.0/24</td><td>3</td></tr><tr><td>步骤3</td><td>192.1.6.0/24</td><td>R1→R2→192.1.6.0/24</td><td>4</td></tr><tr><td>步骤4</td><td>192.1.7.0/24</td><td>R1→R2→R4→192.1.7.0/24</td><td>8</td></tr></table>

# 11.【解答】

1）Prim算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中的所有顶点为止。算法的每一步在连接树集合  $S$  的顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合  $S$  。当算法终止时， $S$  就是最小生成树。

①  $S$  中顶点为  $A$  ，候选边为  $(A, D), (A, B), (A, E)$  ，选择  $(A, D)$  加入  $S$  。

②  $S$  中顶点为  $A, D$ ，候选边为  $(A, B), (A, E), (D, E), (C, D)$ ，选择  $(D, E)$ ，加入  $S$ 。

③  $S$  中顶点为  $A, D, E$ ，候选边为  $(A, B), (C, D), (C, E)$ ，选择  $(C, E)$  加入  $S$ 。

④  $S$  中顶点为  $A, D, E, C$  ，候选边为  $(A, B), (B, C)$  ，选择  $(B, C)$  加入  $S$  。

⑤  $S$  就是最小生成树。

依次选出的边为

$$
(A, D), (D, E), (C, E), (B, C)
$$

2）图  $G$  的MST是唯一的。第一小题的最小生成树包括了图中权值最小的4条边，其他边除  $(A,E)$  外都比这4条边大，但若用  $(A,E)$  替换同权值的  $(C,E)$ ， $A,D,E$  三个顶点构成了回路，因此不能替换，所以此图的MST唯一。

3）当带权连通图的任意一个环中所包含的边的权值均不相同时，其MST是唯一的。此题不要求回答充分必要条件，所以回答一个限制边权值的充分条件即可。

# 12.【解答】

1）为了求解最经济的方案，可把问题抽象为求无向带权图的最小生成树。可以采用手动Prim算法或Kruskal算法作图。注意本题的最小生成树有两种构造，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/84cb6a5149ba873d82104ec0ca08fe0f545ddcab8af28f3a6d0333fe795a5108.jpg)



方案1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6ca5d2908f5365d13661d251be2f15828b996649ca9dcdb4bba187fca8882853.jpg)



方案2


方案的总费用为16。

2）存储题中的图可采用邻接矩阵（或邻接表）。构造最小生成树采用 Prim 算法（或 Kruskal 算法）。

3） $\mathrm{TTL} = 5$ ，即IP分组的生存时间（最大传递距离）为5，方案1中TL和BJ的距离过远， $\mathrm{TTL} = 5$ 不足以让IP分组从H1传送到H2，因此H2不能收到IP分组。而方案2中TL和BJ邻近，H2可以收到IP分组。

# 13.【解答】

1）算法的基本设计思想：建立图  $G$  各顶点的入度表degree[]。选择入度为0的顶点  $\nu$ ，将  $\nu$  的所有邻接点的入度减1，重复执行这个过程。若每次选中的入度为0的顶点有且仅有一个，且共进行了G.numVertices次，则意味着存在唯一的拓扑序列，返回1，否则不存在拓扑序列，或者存在多个拓扑序列，返回0。

2）用C语言描述的算法如下：

```txt
int uniquely(MGraph G){//判定有向图是否存在唯一的拓扑序列  
int \*degree,i,j,count  $= 0$  in0=-1,prev_in0;  
degree=(int\*)malloc(G.numVertices\*sizeof(int));  
for(j=0;j<G.numVertices;j++){//计算各顶点的入度  
degree[j]=0;  
for(i=0;i<G.numVertices;i++)  
    degree[j]  $+ = G$  .Edge[i][j];  
if(degree[j] == 0) {  
    if(in0==-1) in0=j; //入度为0的顶点  
    else in0=-2; //有多个入度为0的顶点  
}  
}  
while (in0 >= 0) {  
    count++;  
    prev_in0 = in0;  
    in0 = -1;  
    for(j=0;j<G.numVertices;j++)  
        if(G.Circle[prev_in0][j]>0) {  
            if(--degree[j] == 0) { //邻接点入度值减1  
                if(in0==-1) in0=j; //入度为0的顶点  
                    else in0=-2; //有多个入度为0的顶点  
            }  
        }  
}  
free (degree);  
if(count == G.numVertices) return 1;  
else return 0;
```

# 归纳总结

# 1. 关于图的基本操作

本章中的很多程序对采用邻接表或邻接矩阵的存储结构都适用，主要原因是在图的基本操作函数中保持了相同的参数和返回值，而封闭了内部实现细节。

例如，取  $\mathbf{x}$  邻接顶点  $\mathrm{y}$  的下一个邻接顶点的函数NextNeighbor  $(G, x, y)$ 。

1）用邻接矩阵作为存储结构

```txt
int NextNeighbor(MGraph& G, int x, int y) {
    if (x != -1 && y != -1) {
        for (int col = y + 1; col < G.vexnum; col++) {
            if (G.Eddge[x][col] > 0 && G.Eddge[x][col] < maxWeight)
                return col; //maxWeight 代表
            }
        }
    return -1;
}
```

2）用邻接表作为存储结构

```c
int NextNeighbor(ALGraph& G, int x, int y) {
if (x != -1) {
ArcNode *p = Gvertices[x].first; //对应边链表第一个边结点
while (p != NULL && p->data != y) //寻找邻接顶点y
p = p->next;
if (p != NULL && p->next != NULL)
```

```c
return p->next->data; //返回下一个邻接顶点  
}  
return -1;
```

2. 关于图的遍历、连通性、生成树、关键路径的几个要点

1）在执行图的遍历时，因为图中可能存在回路，且图的任意一个顶点都可能与其他顶点相连，所以在访问完某个顶点后可能会沿某些边又回到了曾经访问过的顶点。因此，需要设置一个辅助数组visited[]标记顶点是否已被访问过，避免重复访问。

2）深度优先搜索时利用回溯法对图遍历，一般利用递归方法实现，每当向前递归查找某一邻接结点之前，必须判断该结点是否访问过。另外，递归算法均可借助栈来实现非递归算法，深度优先搜索也不例外，具体程序见6.3.4节的综合应用题03。

3）广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。因此，它不是一个递归的过程。

4）一个给定的图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入先后次序不同，则生成的邻接表表示也不同。

5）图的最小生成树首先必须是带权连通图，其次要在  $n$  个顶点的图中选择  $n - 1$  条边将其连通，使得其权值总和达到最小，且不出现回路。

6）加速某一关键活动不一定能缩短整个工程的工期，因为AOE网中可能存在多条关键路径。可能存在称为桥的一种特殊关键活动，它位于所有的关键路径上，只有它加速才会缩短整个工期。

# 思维拓展

【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的边，无向图不再连通，描述算法。

# 提示

要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料。

# 第7章

# 查找

# 【考纲内容】

（一）查找的基本概念

（二）顺序查找法

（三）分块查找法

（四）折半查找法

（五）树形查找

二叉搜索树：平衡二叉树；红黑树

（六）B树及其基本操作、B+树的基本概念

（七）散列（Hash）表

（八）查找算法的分析及应用

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/41d8e5fa2ab8919aa5695ca72dbd8776c8d980ce81de66242d42a0366069c4f0.jpg)


# 【复习提示】

本章是考研命题的重点。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找长度等。对于二叉排序树、二叉平衡树和红黑树，要了解它们的概念、性质和相关操作等。B树和  $\mathrm{B + }$  树是本章的难点。对于B树，考研大纲要求掌握插入、删除和查找的操作过程；对于  $\mathrm{B + }$  树，仅要求了解其基本概念和性质。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。

# 7.1 查找的基本概念

1）查找。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ba2a8cfbdacf5cfeaaabc1f6e2fad92168b27a74072176c59d647c701376d5ab.jpg)



视频讲解


2）查找表。用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。对查找表的常见操作有：①查询符合条件的数据元素；②插入、删除数据元素。

3）静态查找表。若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地插入或删除的查找表称为动态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。

4）关键字。数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。

5）平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为

$$
\mathrm {A S L} = \sum_ {i = 1} ^ {n} P _ {i} C _ {i}
$$

式中， $n$  是查找表的长度； $P_{i}$  是查找第  $i$  个数据元素的概率，一般认为每个数据元素的查找概率相等，即  $P_{i} = 1 / n$ ； $C_{i}$  是找到第  $i$  个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。

# 7.2 顺序查找和折半查找

# 7.2.1 顺序查找

顺序查找也称线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过指针 next 来依次扫描每个元素。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。下面分别进行讨论。

# 1. 一般线性表的顺序查找

作为一种最直观的查找方法，其基本思想：①从线性表的一端开始，逐个检查关键字是否满足给定的条件；②若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；③若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。下面给出其算法，后面说明了算法中引入的“哨兵”的作用。

```txt
typedef struct{ //查找表的数据结构（顺序表）ElemType \*elem; //动态数组基址int TableLen; //表的长度}SSTable;int Search_Seq(SSTable ST,ElemType key){ST.elem[0]=key; //“哨兵”for(int i=ST.TableLen;ST.elem[i]！  $=$  key;--i);//从后往前找return i; //若查找成功，则返回元素下标；若查找失败，则返回0}
```

上述算法中，将ST.elem[0]称为哨兵，引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界。算法从尾部开始查找，若找到ST.elem[i] == key则返回i值，查找成功。否则一定在查找到ST.elem[0] == key时跳出循环，此时返回的是0，查找失败。在程序中引入“哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。

对于有  $n$  个元素的表，给定值key与表中第  $i$  个元素相等，即定位第  $i$  个元素时，需进行  $n - i + 1$

次关键字的比较，即  $C_i = n - i + 1$  。查找成功时，顺序查找的平均长度为

$$
\mathrm {A S L} _ {\text {成 功}} = \sum_ {i = 1} ^ {n} P _ {i} (n - i + 1)
$$

当每个元素的查找概率相等，即  $P_{i} = 1 / n$  时，有

$$
\mathrm {A S L} _ {\text {成 功}} = \sum_ {i = 1} ^ {n} P _ {i} (n - i + 1) = \frac {n + 1}{2}
$$

查找不成功时，与表中各关键字的比较次数显然是  $n + 1$  次，即  $\mathrm{ASL}_{\text{不成功}} = n + 1$ 。

通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小至大重新排列。

综上所述，顺序查找的缺点是当  $n$  较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对链表只能进行顺序查找。

# 2. 有序线性表的顺序查找

若在查找之前就已知表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低查找失败的平均查找长度。假设表  $L$  是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key，当查找到第  $i$  个元素时，发现第  $i$  个元素的关键字小于key，但第  $i + 1$  个元素的关键字大于key，这时就可返回查找失败的信息，因为第 $i$  个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。

# 命题追踪 有序线性表的顺序查找的应用（2013）

可以用如图7.1所示的判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性表中存在的元素；矩形结点称为失败结点（若有  $n$  个结点，则相应地有  $n + 1$  个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到矩形结点，则说明查找失败。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/20217a72817c202c454d9482a9f34cf91be4b4b965ff6af69277c496f16c4124.jpg)



图7.1 有序顺序表上的顺序查找判定树


在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为

$$
\mathrm {A S L} _ {\text {不 成 功}} = \sum_ {j = 1} ^ {n} q _ {j} (l _ {j} - 1) = \frac {1 + 2 + \cdots + n + n}{n + 1} = \frac {n}{2} + \frac {n}{n + 1}
$$

式中，  $q_{j}$  是到达第  $j$  个失败结点的概率，在相等查找概率的情形下，它为  $1 / (n + 1)$ ； $l_{j}$  是第  $j$  个失败结点所在的层数。当  $n = 6$  时，ASL 不成功  $= 6 / 2 + 6 / 7 = 3.86$ ，比一般的顺序查找好一些。

注意，有序线性表的顺序查找和后面的折半查找的思想是不一样的，且有序线性表的顺序查找中的线性表可以是链式存储结构，而折半查找中的线性表只能是顺序存储结构。

# 7.2.2 折半查找

折半查找也称二分查找，它仅适用于有序的顺序表。

# 命题追踪 分析对比给定查找算法与折半查找的效率（2016）

折半查找的基本思想：①首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；②若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若key大于中间元素，则所查找的元素只可能在后半部分），然后在缩小的范围内继续进行同样的查找。重复上述步骤，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法如下：

```c
int Binary_Search(SSTable L, ElemType key) {
    int low = 0, high = L.TableLen - 1, mid;
    while (low <= high) {
        mid = (low + high) / 2; //取中间位置
        if (L.element[mid] == key)
            return mid; //查找成功则返回所在位置
        else if (L.element[mid] > key)
            high = mid - 1; //从前半部分继续查找
        else
            low = mid + 1; //从后半部分继续查找
    }
    return -1; //查找失败，返回-1
```

当折半查找算法选取中间结点时，既可以采用向下取整，又可以采用向上取整。但每次查找的取整方式必须相同，这部分内容请读者结合本节部分习题来理解。

# 命题追踪 折半查找的查找路径的判断（2015）

例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元素，指针low和high分别指向表的下界和上界，mid则指向表的中间位置(low+high)/2」。

下面来说明查找11的过程（查找32的过程请读者自行分析）：

```txt
7 10 13 16 19 29 32 33 37 41 43 ↑ low ↑ mid ↑ high
```

第一次查找时，将中间位置元素与key比较。因为  $11 < 29$  ，说明待查元素若存在，则必在范围[low,mid-1]内，令high指向位置mid-1，high=mid-1=5，mid=(1+5)/2=3，第二次查找范围为[1,5]。

```txt
7 10 13 16 19 29 32 33 37 41 43 ↑ low ↑ mid ↑ high
```

第二次查找时，将中间位置元素与key比较。因为  $11 < 13$  ，说明待查元素若存在，则必在范围[low,mid-1]内，令high指向位置mid-1，high=mid-1=2，mid=(1+2)/2=1，第三次查找范围为[1,2]。

```txt
7 10 13 16 19 29 32 33 37 41 43 low ↑ ↑high mid ↑
```

第三次查找时，将中间位置元素与key比较。因为  $11 > 7$  ，说明待查元素若存在，则必在范围[mid+1,high]内。令low=mid+1=2，mid=(2+2)/2=2，第四次查找范围为[2，2]。

```txt
7 10 13 16 19 29 32 33 37 41 43 low↑↑high ↑mid
```

第四次查找，此时子表只含有一个元素，且  $10 \neq 11$  ，所以表中不存在待查元素。

# 命题追踪 分析给定二叉树树形能否构成折半查找判定树（2017）

折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找失败的区间。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于其右子结点值。若有序序列有  $n$  个元素，则对应的判定树有  $n$  个圆形的非叶结点和  $n + 1$  个方形的叶结点。显然，判定树是一棵平衡二叉树（见7.3.2节）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e2fcad1c2e65c96cc09955bcf2dc30c202d55653f0d33fb60a42cfaff67e1c50.jpg)



图7.2 描述折半查找过程的判定树


# 命题追踪 折半查找的最多比较次数的分析（2010、2023）

由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为

$$
\mathrm {A S L} = \frac {1}{n} \sum_ {i = 1} ^ {n} l _ {i} = \frac {1}{n} (1 \times 1 + 2 \times 2 + \dots + h \times 2 ^ {h - 1}) = \frac {n + 1}{n} \log_ {2} (n + 1) - 1 \approx \log_ {2} (n + 1) - 1
$$

式中， $h$  是树的高度，并且元素个数为  $n$  时树高  $h = \lceil \log_2(n + 1) \rceil$ 。所以，折半查找的时间复杂度为  $O(\log_2 n)$ ，平均情况下比顺序查找的效率高。

在图7.2所示的判定树中，在等概率情况下，查找成功（圆形结点）的  $\mathrm{ASL} = (1\times 1 + 2\times 2 + 3\times 4 +$ $4\times 4) / 11 = 3$  ，查找失败（方形结点）的  $\mathrm{ASL} = (3\times 4 + 4\times 8) / 12 = 11 / 3$  。

# 命题追踪 折半查找的适用场景（2024）

因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。

# 7.2.3 分块查找

分块查找也称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有

各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。

分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。

例如，关键码集合为{88,24,72,61,21,6,32,11,8,31,22,83,78,54}，按照关键码值24,54,78,88，分为4个块和索引表，如图7.3所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0e3c4212e3e0e676c92acc7fd0f4b726f4064e50a2732acb773fbd8d67fd4c5e.jpg)



图7.3 分块查找示意图


分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为  $L_{\mathrm{I}}$  和  $L_{\mathrm{S}}$  ，则分块查找的平均查找长度为

$$
\mathrm {A S L} = L _ {\mathrm {I}} + L _ {\mathrm {S}}
$$

将长度为  $n$  的查找表均匀地分为  $b$  块，每块有  $s$  个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为

$$
\mathrm {A S L} = L _ {\mathrm {I}} + L _ {\mathrm {S}} = \frac {b + 1}{2} + \frac {s + 1}{2} = \frac {s ^ {2} + 2 s + n}{2 s}
$$

此时，若  $s = \sqrt{n}$  ，则平均查找长度取最小值  $\sqrt{n} + 1$  。

虽然索引表占用了额外的存储空间，索引查找也增加了一定的系统开销，但由于其分块结构，使得在块内查找时的范围较小，与顺序查找相比，分块查找的总体效率提升了不少。

# 7.2.4 本节试题精选

# 一、单项选择题

01. 顺序查找适合于存储结构为（）的线性表。

A. 顺序存储结构或链式存储结构

B. 散列存储结构

C. 索引存储结构

D. 压缩存储结构

02. 由  $n$  个数据元素组成的两个表：一个递增有序，一个无序。采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任意一个元素的概率是相同的，则在两种表中成功查找（）。

A. 平均时间后者小

B. 平均时间两者相同

C. 平均时间前者小

D. 无法确定

03. 对长度为  $n$  的有序单链表，若查找每个元素的概率相等，则顺序查找表中任意一个元素的查找成功的平均查找长度为（）。

A.  $n / 2$

B.  $(n + 1) / 2$

C.  $(n - 1) / 2$

D.  $n / 4$

04. 对长度为3的顺序表进行查找，若查找第一个元素的概率为1/2，查找第二个元素的概率为1/3，查找第三个元素的概率为1/6，则查找任意一个元素的平均查找长度为（）。

A.  $5 / 3$

B. 2

C.  $7 / 3$

D.  $4 / 3$

05. 下列关于二分查找的叙述中，正确的是（）。

A. 表必须有序，表可以顺序方式存储，也可以链表方式存储

B. 表必须有序且表中数据必须是整型、实型或字符型

C. 表必须有序，而且只能从小到大排列

D. 表必须有序，且表只能以顺序方式存储

06. 在一个顺序存储的有序线性表上查找一个数据时，既可以采用折半查找，也可以采用顺序查找，但前者比后者的查找速度（）。

A. 必然快

B. 取决于表是递增还是递减

C. 在大部分情况下要快

D. 必然不快

07. 折半查找过程所对应的判定树是一棵（）。

A. 最小生成树

B. 平衡二叉树

C. 完全二叉树

D. 满二叉树

08. 折半查找和二叉排序树的时间性能（）。

A. 相同

B. 有时不相同

C. 完全不同

D. 无法比较

09. 在有 11 个元素的有序表 A[1,2,…,11] 中进行折半查找 (  $\left\lfloor (\text{low} + \text{high}) / 2 \right\rfloor$  )，查找元素 A[11] 时，被比较的元素下标依次是（）。

A. 6,8,10,11

B. 6, 9, 10, 11

C. 6,7,9,11

D. 6,8,9,11

10. 已知有序表(13, 18, 24, 35, 47, 50, 62, 83, 90, 115, 134)，当二分查找值为90的元素时，查找成功的元素比较次数为（）。

A. 1

B. 2

C. 4

D. 6

11. 若有序表的关键字序列为  $\{b, c, d, e, f, g, q, r, s, t\}$ ，则在二分查找关键字  $b$  的过程中，进行比较的关键字依次为（）。

A.  $f, c, b$

B.  $f, d, b$

C.  $g, c, b$

D.  $g, d, b$

12. 对表长为  $n$  的有序表进行折半查找,其判定树的高度为 (   )。

A.  $\lceil \log_2(n + 1)\rceil$

B.  $\lfloor \log_2(n + 1)\rfloor -1$

C.  $\left\lceil \log_2 n \right\rceil$

D.  $\lfloor \log_2 n \rfloor - 1$

13. 已知一个长度为 16 的顺序表，其元素按关键字有序排列，若采用折半查找算法查找一个不存在的元素，则比较的次数至少是（），至多是（）。

A. 4

B. 5

C. 6

D. 7

14. 具有 12 个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的平均查找长度为（），折半查找查找失败的平均查找长度为（）。

A. 37/12

B.  $35 / 12$

C.  $39 / 13$

D.  ${49}/{13}$

15. 下列关于查找的说法中，正确的是（）。（注，涉及下节内容）

A. 若数据元素保持有序，则查找时就可以采用折半查找法

B. 折半查找与二叉查找树的时间性能在最坏情况下是相同的

C. 折半查找法的平均查找长度一定小于顺序查找法

D. 折半查找法查找一个元素大约需要  $O(\log_2 n)$  次关键字比较

16. 采用分块查找时，数据的组织方式为（）。

A. 数据分成若干块, 每块内数据有序

B. 数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块

C. 数据分成若干块, 每块内数据有序, 每块内最大 (或最小) 的数据组成索引块

D. 数据分成若干块, 每块 (除最后一块外) 中数据个数需相同

17. 对有 2500 个记录的索引顺序表（分块表）进行查找，最理想的块长为（）。

A. 50

B. 125

C. 500

D.  $\left\lceil \log_2 2500 \right\rceil$

18. 设顺序存储的某线性表共有 123 个元素，按分块查找的要求等分为 3 块。若对索引表采

用顺序查找法来确定子块，且在确定的子块中也采用顺序查找法，则在等概率情况下，分块查找成功的平均查找长度为（）。

A. 21

B. 23

C. 41

D. 62

19. 为提高查找效率，对有65025个元素的有序顺序表建立索引顺序结构，在最好情况下查找到表中已有元素最多需要执行（）次关键字比较。

A. 10

B. 14

C. 16

D. 21

20.【2010统考真题】已知一个长度为16的顺序表  $L$  ，其元素按关键字有序排列，若采用折半查找法查找一个  $L$  中不存在的元素，则关键字的比较次数最多是（）。

A. 4

B. 5

C. 6

D. 7

21.【2015统考真题】下列选项中，不能构成折半查找中关键字比较序列的是（）。

A. 500, 200, 450, 180

B. 500, 450, 200, 180

C. 180,500,200,450

D. 180, 200, 500, 450

22.【2016统考真题】在有  $n(n > 1000)$  个元素的升序数组A中查找关键字  $\mathbf{x}$  。查找算法的伪代码如下所示。

$k = 0$

while  $(\mathrm{k} <   \mathrm{n}$  且A[k]  $<  x$  ）  $\mathrm{k = k + 3}$

if  $(\mathrm{k} <   \mathrm{n}$  且A[k]  $= = x$  查找成功；

else if  $(k - 1 <   n$  且  $A[k - 1] == x)$  查找成功；

else if  $(k - 2 <   n$  且A[k-2]  $= = x$  查找成功；

else 查找失败；

本算法与折半查找算法相比，有可能具有更少比较次数的情形是（）。

A. 当  $x$  不在数组中

B. 当  $x$  接近数组开头处

C. 当  $x$  接近数组结尾处

D. 当  $x$  位于数组中间位置

23.【2017统考真题】下列二叉树中，可能成为折半查找判定树（不含外部结点）的是（）。

A.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/58996b9c8728c2f27556ebb512145a61ad608799c75d8d7462e97b6ae98d33ce.jpg)


B.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e3bcb2a355a8cf757c73986af908f04742987415e7312b9887383f415a0ab2b1.jpg)


C.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/94b135355a2c70b749a8bf35a6fdb6190238f38cd9b67db13d7079b31253a70d.jpg)


D.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/77b61a059e3ccbd1ca3eda8ffee41c7f11b954c840969b657e36c03ae927942f.jpg)


24.【2023统考真题】对含600个元素的有序顺序表进行折半查找，关键字间的比较次数最多是（）。

A. 9

B. 10

C. 30

D. 300

25.【2024统考真题】下列数据结构中，不适合直接使用折半查找的是（）。

I. 有序链表

II. 无序数组

III. 有序静态链表

IV. 无序静态链表

A. 仅 I、III

B. 仅 II、IV

C. 仅 II、III、IV

D. I、II、III、IV

# 二、综合应用题

01. 若对有  $n$  个元素的有序顺序表和无序顺序表进行顺序查找，试就下列三种情况分别讨论两者在相等查找概率时的平均查找长度是否相同。

1）查找失败。

2）查找成功，且表中只有一个关键字等于给定值k的元素。

3）查找成功，且表中有若干关键字等于给定值k的元素，要求一次查找能找出所有元素。

02. 有序顺序表中的元素依次为017,094,154,170,275,503,509,512,553,612,677,765,897,908。

1）试画出对其进行折半查找的判定树。

2）若查找275或684的元素，将依次与表中的哪些元素比较？

3）计算查找成功的平均查找长度和查找不成功的平均查找长度。

03. 已知一个有序顺序表 A[0...8n-1]的表长为 8n，并且表中没有关键字相同的数据元素。假设按下述方法查找一个关键字值等于给定值 X 的数据元素：首先在 A[7], A[15], A[23], ..., A[8k-1], ..., A[8n-1] 中进行顺序查找，若查找成功，则算法报告成功位置并返回；若不成功，则当 A[8k-1] < X < A[8 × (k+1) - 1] 时，可确定一个缩小的查找范围 A[8k] ~ A[8 × (k+1) - 2]，然后可在这个范围内执行折半查找。特殊情况：若 X > A[8n-1] 的关键字，则查找失败。

1）画出描述上述查找过程的判定树。

2）计算相等查找概率下查找成功的平均查找长度。

04. 写出折半查找的递归算法。初始调用时，low 为 1，high 为 ST.length。

05. 线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱结点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。

06. 已知一个  $n$  阶矩阵  $\mathbf{A}$  和一个目标值  $k$ 。该矩阵无重复元素，每行从左到右升序排列，每列从上到下升序排列。请设计一个在时间上尽可能高效的算法，判断矩阵中是否存在目标值  $k$ 。例如，矩阵为  $\begin{bmatrix} 1 & 4 & 7 \\ 2 & 5 & 8 \\ 3 & 6 & 9 \end{bmatrix}$ ，目标值为8，判断存在。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明你的算法的时间复杂度和空间复杂度。

07.【2013统考真题】设包含4个数据元素的集合  $S = \{\text{do}',\text{for}',\text{repeat}',\text{while}'\}$ ，各元素的查找概率依次为  $p_1 = 0.35, p_2 = 0.15, p_3 = 0.15, p_4 = 0.35$ 。将  $S$  保存在一个长度为4的顺序表中，采用折半查找法，查找成功时的平均查找长度为2.2。

1) 若采用顺序存储结构保存  $S$ ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？

2）若采用链式存储结构保存  $S$  ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？

# 7.2.5 答案与解析

# 一、单项选择题

01. A

顺序查找是指从表的一端开始向另一端查找。它不要求查找表具有随机存取的特性，可以是顺序存储结构或链式存储结构。

02. B

对于顺序查找，不管线性表是有序的还是无序的，成功查找第一个元素的比较次数为1，成

功查找第二个元素的比较次数为2，以此类推，即每个元素查找成功的比较次数只与其位置有关（与是否有序无关），因此查找成功的平均时间两者相同。

# 03. B

在有序单链表上做顺序查找，查找成功的平均查找长度与在无序顺序表或有序顺序表上做顺序查找的平均查找长度相同，都是  $(n + 1) / 2$ 。

# 04. A

在长度为3的顺序表中，查找第一个元素的查找长度为1，查找第二个元素的查找长度为2，查找第三个元素的查找长度为3，所以有

$$
\mathrm {A S L} _ {\text {成 功}} = \frac {1}{2} \times 1 + \frac {1}{3} \times 2 + \frac {1}{6} \times 3 = \frac {5}{3}
$$

# 05. D

二分查找通过下标来定位中间位置元素，所以应采用顺序存储，且二分查找能够进行的前提是查找表是有序的，但具体是从大到小还是从小到大的顺序则不做要求。

# 06.C

折半查找的快体现在一般情况下，在大部分情况下要快，但是对于某些特殊情况，顺序查找可能会快于折半查找。例如，查找一个含1000个元素的有序表中的第一个元素时，顺序查找的比较次数为1次，而折半查找的比较次数却将近10次。

# 07. B

A 显然排除。对于选项 C，考点精析示例中的判定树就不是完全二叉树。由选项 C 也可排除选项 D，且满二叉树对结点数有要求。只可能选择选项 B。事实上，由折半查找的定义不难看出，每次把一个数组从中间结点分割时，总是把数组分为结点数相差最多不超过 1 的两个子数组，从而使得对应的判定树的两棵子树高度差的绝对值不超过 1，所以应是平衡二叉树。

# 08. B

折半查找的性能分析可以用二叉判定树来衡量，平均查找长度和最大查找长度都是  $O(\log_2n)$ ；二叉排序树的查找性能与数据的输入顺序有关，最好情况下的平均查找长度与折半查找相同，但最坏情况即形成单支树时，其查找长度为  $O(n)$ 。

# 09. B

依据折半查找算法的思想，第一次  $\mathrm{mid} = \left\lfloor (1 + 11) / 2 \right\rfloor = 6$ ，第二次  $\mathrm{mid} = \left\lfloor [(6 + 1) + 11] / 2 \right\rfloor = 9$ ，第三次  $\mathrm{mid} = \left\lfloor [(9 + 1) + 11] / 2 \right\rfloor = 10$ ，第四次  $\mathrm{mid} = 11$ 。

# 10. B

开始时 low 指向 13，high 指向 134，mid 指向 50，比较第一次  $90 > 50$ ，所以将 low 指向 62，high 指向 134，mid 指向 90，第二次比较找到 90。

# 11. A

在折半查找算法中，mid取值的方式是确定的，要么采用向上取整，要么采用向下取整，而不能出现两种情况。对于选项A，第1次比较的元素是  $f$ ，为向下取整；第2次比较的元素是  $c$ ，为向下取整；第3次比较的元素是  $b$ ，为向下取整，查找成功，符合二分查找。对于选项B，第1次比较的元素是  $f$ ，为向下取整；第2次比较的元素是  $d$ ，为向上取整，两次mid取值的方式不同，不符合二分查找。对于选项C，第1次比较的元素是  $g$ ，为向上取整；第2次比较的元素是  $c$ ，为向下取整，不符合二分查找。对于选项D，第1次比较的元素是  $g$ ，为向上取整；第2次比较的元素是  $d$ ，为正中间元素；第3次比较的元素为  $b$ ，为向下取整，不符合二分查找。

# 12. A

对  $n$  个结点的判定树，设结点总数  $n = 2^h -1$  ，则  $h = \lceil \log_2(n + 1)\rceil$

【另解】特殊值代入法。直接将  $n = 1$  和  $n = 2$  的情况代入，仅有A满足要求。

# 13. A、B

对于此类题，有两种做法：一种方法是，画出查找过程中构成的判定树，让最小的分支高度对应于最少的比较次数，让最大的分支高度对应于最多的比较次数，出现类似于长度为15的顺序表时，判定树刚好是一棵满树，此时最多比较次数与最少比较次数相等；另一种方法是，直接用公式求出最小的分支高度和最大分支高度，从前面的讲解不难看出最大分支高度为  $H = \lceil \log_2(n + 1) \rceil = 5$ ，这对应的就是最多比较次数，然后因为判定树不是一棵满树，所以至少应该是4（由判定树的各分支高度最多相差1得出）。

注意，若求查找成功或查找失败的平均查找长度，则需要画出判定树来求解。此外，对长度为  $n$  的有序表，采用折半查找时，查找成功和查找失败的最多比较次数相同，均为  $\lceil \log_2(n + 1)\rceil$

# 14. A、D

假设有序表中元素为A[0...11]，不难画出对它进行折半查找的判定树如下图所示，圆圈是查找成功结点，方形是虚构的查找失败结点。从而可以求出查找成功的  $\mathrm{ASL} = (1 + 2\times 2 + 3\times 4 + 4\times 5) / 12 =$  37/12，查找失败的  $\mathrm{ASL} = (3\times 3 + 4\times 10) / 13$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/951095c4bbbb42d19b9827e15bb6f2a190c4199a40163b11a60d5d7967025369.jpg)


# 注意

对于本类题目，应先根据所给  $n$  的值，画出如上图所示的折半查找判定树。另外，查找失败结点的ASL不是到图中的方形结点，而是到方形结点上一层的圆形结点。

# 15. D

折半查找法不仅要求数据元素有序，而且要求必须为顺序存储，选项A错误。折半查找法在最坏情况下的时间性能为  $O(\log_2n)$ ，二叉查找树在最坏情况下的时间性能为  $O(n)$ ，选项B错误。在每个元素查找概率不同的情况下，折半查找法的平均查找长度可能大于顺序查找法，选项C错误。

# 16. B

通常情况下，在分块查找的结构中，不要求每个索引块中的元素个数都相等。

# 17. A

设块长为  $b$  ，索引表包含  $n / b$  项，索引表的  $\mathrm{ASL} = (n / b + 1) / 2$  ，块内的  $\mathrm{ASL} = (b + 1) / 2$  ，总  $\mathrm{ASL} =$  索引表的  $\mathrm{ASL} +$  块内的  $\mathrm{ASL} = (b + n / b + 2) / 2$  ，其中对于  $b + n / b$  ，由均值不等式知  $b = n / b$  时有最小值，此时  $b = \sqrt{n}$  。则最理想块长为  $\sqrt{2500} = 50$  。

# 18. B

根据公式  $\mathrm{ASL} = L_{1} + L_{\mathrm{s}} = \frac{b + 1}{2} +\frac{s + 1}{2} = \frac{s^2 + 2s + n}{2s}$  ，其中  $b = n / s,s = 123 / 3,n = 123$  ，代入不难得出ASL为23。所以选择选项B。另一方面，可根据穷举法来一步步模拟。对于A块中的元素，查找过程的第一步是先找到A块，由于是顺序查找，找到A块只需一步，然后在A块中顺序查找，因此A块内各元素查找长度分别为2,3,4,,42。对于B块，采用类似的方法，但查找到B块要比查找到

A 块多一步, 因此 B 块内各元素查找长度为  $3, 4, 5, \cdots, 43$  。同理, C 块中各个元素查找长度为  $4, 5, 6, \cdots, 44$  。所以平均查找长度为  $(2 + 3 + 4 + \cdots + 42 + 3 + 4 + 5 + \cdots + 43 + 4 + 5 + 6 + \cdots + 44) / 123 = 23$  。

# 19. C

为使查找效率最高，每个索引块的大小应是  $\sqrt{65025} = 255$  ，为每个块建立索引，则索引表中索引项的个数为255。若对索引项和索引块内部都采用折半查找，则查找效率最高，为  $\left\lceil \log_2(255 + 1)\right\rceil +$ $\left\lceil \log_2(255 + 1)\right\rceil = 16$  。

# 20. B

折半查找法在查找不成功时和给定值进行关键字的比较次数最多为树的高度，即  $\lfloor \log_2n\rfloor +1$  或  $\lceil \log_2(n + 1)\rceil$  。在本题中，  $n = 16$  ，所以比较次数最多为5。

# 注意

在折半查找判定树中的方形结点是虚构的，它不计入比较的次数。

# 21. A

画出查找路径图，因为折半查找判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c1c9e579728da0e1a400015b3d0642db8a6648da954c5c01dcf72663a455986c.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c129cf02f187d7dafa8a3067bf1817c7d519de93f20f27e0cddedaeef3e0801e.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f6ba03c477bdd1e28b5b29ab113d27d4438e9d6a1ded2b2e91288e5cce8c3d4a.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/46aa8d7905f6f90a7cf2b89af37f23171e5da315d5ac08dd02dfdcbe4d2a28dc.jpg)


显然，选项A的查找路径不满足。

# 22. B

本题为送分题。

该程序采用跳跃式的顺序查找法查找升序数组中的  $\mathbf{x}$  。显然,  $\mathbf{x}$  越靠前, 比较次数越少。

# 23. A

对于给定的一个有序查找表，其对应的折半查找判定树是确定且唯一的。在折半查找算法中，mid  $=\left\lfloor \left(\text{low} + \text{high}\right) / 2\right\rfloor$  ，因此若表中初始有  $2n + 1$  个元素，则mid分割后，左右子树各有  $n$  个元素；若表中初始有  $2n$  个元素，则mid分割后，左子树有  $n - 1$  个元素，右子树有  $n$  个元素。即左子树的元素个数或者与右子树的元素个数相等，或者比右子树少一个。若令mid  $=\left\lceil \left(\text{low} + \text{high}\right) / 2\right\rceil$  ，不难理解，左子树的元素个数或者与右子树的元素个数相等，或者比右子树多一个。对于选项A，树中每个左子树都与右子树的结点个数相等，或者多一个结点，符合向上取整的规则。对于选项B、C、D，存在有的左子树比右子树多一个结点，有的左子树比右子树少一个结点，不符合折半查找的规则。

# 24. B

用折半查找法查找给定值的比较次数最多不超过折半查找判定树的高度。折半查找判定树的树高  $h = \lceil \log_2(n + 1) \rceil$ ，将  $n = 600$  代入，结果为10。

# 25. D

折半查找必须满足两个条件：①数组（或顺序表），折半查找的上一次查找和本次查找可能相隔很远的距离，如依次查找下标为  $n / 2, n / 4, n / 8, \dots$  的元素，若采用链表（或静态链表），则会使

得时间复杂度非常高。②有序，只有在有序的情况下才能根据上一次的比较情况舍弃一半的序列。

# 二、综合应用题

# 01.【解答】

1）平均查找长度不同。因为有序顺序表查找到其关键字值比要查找值大的元素时就停止查找，并报告失败信息，不必查找到表尾；而无序顺序表必须查找到表尾才能确定查找失败。

2）平均查找长度相同。两者查找到表中元素的关键字值等于给定值时就停止查找。

3）平均查找长度不同。有序顺序表中关键字相等的元素相继排列在一起，只要查找到第一个就可以连续查找到其他关键字相同的元素。而无序顺序表必须查找全部表中的元素才能找出相同关键字的元素，因此所需的时间不同。

# 02.【解答】

1）判定树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/db049740d314f91c8bb593eddfa451c17e902496f73004accd18e7335ab99ce0.jpg)


2）若查找275，依次与表中元素509,154,275进行比较，共比较3次。若查找684，依次与表中元素509,677,897,765进行比较，共比较4次。

3）在查找成功时，会找到图中的某个圆形结点，其平均查找长度为

$$
\mathrm {A S L} _ {\text {成 功}} = \frac {1}{1 4} \sum_ {i = 1} ^ {1 4} C _ {i} = \frac {1}{1 4} (1 + 2 \times 2 + 3 \times 4 + 4 \times 7) = \frac {4 5}{1 4}
$$

在查找失败时，会找到图中的某个方形结点，但这个结点是虚构的，最后一次的比较元素为其父结点（圆形结点），所以其平均查找长度为

$$
\mathrm {A S L} _ {\text {不 成 功}} = \frac {1}{1 5} \sum_ {i = 0} ^ {1 4} C _ {i} ^ {\prime} = \frac {1}{1 5} (3 \times 1 + 4 \times 1 4) = \frac {5 9}{1 5}
$$

# 03.【解答】

1）先在A[7], A[15], ..., A[8n-1]内顺序查找，再在区间内折半查找。相应的判定树如下图所示。其中，每个关键字下的数字为其查找成功时的关键字比较次数。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8a87ec24647651ad51b257daa5c236c24de9d577993cfcbdc6ff220c50ef2de2.jpg)


2）等查找概率下，平均每个关键字查找成功的概率为  $1 / 8n$ ； $0 \sim 7$  之间的关键字，顺序比较1次后，进行折半查找，查找成功的平均查找长度为  $2 + 3 \times 2 + 4 \times 4$ ； $8 \sim 15$  之间的关键字，先顺序比较2次后，再进入折半查找；以此类推， $8(n - 1) \sim 8n - 1$  之间的关键字，先顺序比较  $n$  次，再进入折半查找，如上图所示。因此，查找成功的平均查找长度为

$$
\begin{array}{l} \mathrm {A S L} _ {\text {成 功}} = \frac {1}{8 n} \sum_ {i = 0} ^ {8 n - 1} C _ {i} = \frac {1}{8 n} \left(\sum_ {i = 1} ^ {n} i + \sum_ {i = 2} ^ {n + 1} i + 2 \sum_ {i = 3} ^ {n + 2} i + 4 \sum_ {i = 4} ^ {n + 3} i\right) \\ = \frac {1}{8 n} \left(\sum_ {i = 1} ^ {n} (i + (i + 1) + 2 (i + 2) + 4 (i + 3))\right) \\ = \frac {1}{8 n} \sum_ {i = 1} ^ {n} (8 i + 1 7) = \frac {1}{n} \sum_ {i = 1} ^ {n} i + \frac {1 7}{8} = \frac {n + 1}{2} + \frac {1 7}{8} \\ \end{array}
$$

# 04.【解答】

算法的基本思想：根据查找的起始位置和终止位置，将查找序列一分为二，判断所查找的关键字在哪一部分，然后用新的序列的起始位置和终止位置递归求解。

算法代码如下：

```txt
typedef struct{ //查找表的数据结构ElemType \*elem; //存储空间基址，建表时按实际长度分配，0号留空int length; //表的长度  
} SSTable;  
int BinSearchRec(SSTable ST,ElemType key,int low,int high){if(low>high) return 0; mid=(low+high)/2; //取中间位置if(key>ST.elem[mid]) //向后半部分查找BinSearchRec(ST,key,mid+1,high);else if(key<ST.elem[mid]) //向前半部分查找BinSearchRec(ST,key,low,mid-1);else //查找成功return mid;
```

算法把规模为  $n$  的复杂问题经过多次递归调用转化为规模减半的子问题求解。时间复杂度为  $O(\log_2n)$ ，算法中用到了一个递归工作栈，其规模与递归深度有关，也是  $O(\log_2n)$ 。

# 05.【解答】

算法的基本思想：检索时可先从表头开始向后顺序扫描，若找到指定的结点，则将该结点和其前趋结点（若存在）交换。采用顺序表存储结构的算法实现如下：

```javascript
intSeqSrch(RcTypeR[]，ElemTypek){  
//顺序查找线性表，找到后和其前面的元素交换  
int  $\mathrm{i} = 0$  ·while((R[i].key！  $= k$  &&i<n>)i++; //从前向后顺序查找指定结点if(i<n&&i>0）{ //若找到，则交换temp=R[i]；R[i]=R[i-1]；R[i-1]=temp;return--i; //交换成功，返回交换后的位置}else return-1; //交换失败  
}
```

链表的实现方式请读者自行思考。注意，链表方式实现的基本思想与上述思想相似，但要注意用链表实现时，在交换两个结点之前需要保存指向前一结点的指针。

# 06.【解析】

# 1）算法的基本设计思想：

从矩阵  $A$  的右上角（最右列）开始比较，若当前元素小于目标值，则向下寻找下一个更大的元素；若当前元素大于目标值，则从右往左依次比较，若目标值存在，则只可能在该行中。

# 2）算法的实现：

```txt
bool findkey(int A[][[],int n,int k){ int  $\mathrm{i} = 0,\mathrm{j} = \mathrm{n} - 1$  · while(i<n&&j>=0）{ //离开边界时查找结束 if(A[i][j] == k) return true; //查找成功 else if(A[i][j]>k) j--; //向左移动，在该行内寻找目标值 else i++; //向下移动，查找下一个更大的元素 } return false; //查找失败
```

3）比较次数不超过  $2n$  次，时间复杂度为  $O(n)$  ；空间复杂度为  $O(1)$  。

# 07.【解答】

1）折半查找要求元素有序顺序存储，字符串默认按字典序排序（字典序是一种比较两个字符串大小的方法，它按字母顺序从左到右逐个比较对应的字符，若某一位可比较出大小，则不再继续比较后面的字符，如abd<acd、abc<abcd等)，对本题来说do<for>repeat<while。若各个元素的查找概率不同，折半查找的性能不一定优于顺序查找。采用顺序查找时，元素按其查找概率的降序排列时查找长度最小。

采用顺序存储结构，数据元素按其查找概率降序排列。采用顺序查找方法。

查找成功时的平均查找长度  $= 0.35 \times 1 + 0.35 \times 2 + 0.15 \times 3 + 0.15 \times 4 = 2.1$ 。

此时，显然查找长度比折半查找的更短。

2）答案1：采用链式存储结构时，只能采用顺序查找，其性能和顺序表一样，类似于上题。数据元素按其查找概率降序排列，构成单链表。采用顺序查找方法。

查找成功时的平均查找长度  $= 0.35 \times 1 + 0.35 \times 2 + 0.15 \times 3 + 0.15 \times 4 = 2.1$ 。

答案2：还可以构造成二叉排序树的形式。采用二叉链表的存储结构，构造二叉排序树，元素的存储方式见下图。采用二叉排序树的查找方法。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/adf15fa43177c5bf2ba492fe87e6a3d348c7cd5d177587dfabc499db6cb677f9.jpg)



二叉排序树1



或


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/afae5d5280fe9387e330986cd4f0b97f992ec8303d40c336d4615787c064370a.jpg)



二叉排序树2


查找成功时的平均查找长度  $= 0.15 \times 1 + 0.35 \times 2 + 0.35 \times 2 + 0.15 \times 3 = 2.0$ 。

# 7.3 树形查找

# 7.3.1 二叉排序树（BST）

构造一棵二叉排序树的目的并不是排序，而是提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。

# 1. 二叉排序树的定义

# 命题追踪 二叉排序树的应用（2013）

二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：

1）若左子树非空，则左子树上所有结点的值均小于根结点的值。

2）若右子树非空，则右子树上所有结点的值均大于根结点的值。

3）左、右子树也分别是一棵二叉排序树。

# 命题追踪 二叉排序树中结点值之间的关系（2015、2018、2024）

根据二叉排序树的定义，左子树结点值  $<$  根结点值  $<$  右子树结点值，因此对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，图7.4所示二叉排序树的中序遍历序列为123468。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bbe6217e95ab0b390fc2c3594595e296241c02f0a156c14e1f72da17ff2e0b13.jpg)



图7.4 一棵二叉排序树


# 2. 二叉排序树的查找

二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，若小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。

二叉排序树的非递归查找算法：

```txt
BSTNode \*BST_Search(BiT,ElemType key){ while  $(\mathrm{T}! = \mathrm{NULL}&&\mathrm{key}! = \mathrm{T} - >$  data）{//若树空或等于根结点值，则结束循环 if(key<T->data）T=T->lchild; //小于，则在左子树上查找 else T=T->rchild; //大于，则在右子树上查找 } return T;
```

例如，在图7.4中查找值为4的结点。首先4与根结点6比较。因为4小于6，所以在根结点6的左子树中继续查找。因为4大于2，所以在结点2的右子树中查找，查找成功。

同样，二叉排序树的查找也可用递归算法实现，递归算法比较简单，但执行效率较低。具体的代码实现，留给读者思考。

# 3. 二叉排序树的插入

二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。

插入结点的过程如下：若原二叉排序树为空，则直接插入；否则，若关键字  $\mathbf{k}$  小于根结点值，则插入到左子树，若关键字  $\mathbf{k}$  大于根结点值，则插入到右子树。新插入的结点一定是一个叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。如图7.5所示在一棵二叉排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e6eb726a88607ed1b7d008fc4bf8804acd5a1c347341e2097f61f0fff859a42b.jpg)



图7.5 向二叉排序树中插入结点


二叉排序树插入操作的算法描述如下：

```txt
int BST_insert(BiTree&T,KeyType k){if  $(\mathrm{T} = =\mathrm{NULL})$  { //原树为空，新插入的记录为根结点 $\mathrm{T} = (\mathrm{BiTree})\mathrm{malloc}(\mathrm{sizeof}(\mathrm{BSTNode}))$  · $\mathrm{T - > data = k}$  ： $\mathrm{T - > lchild = T - > rchild = NULL;}$  return1; //返回1，插入成功}else if  $(\mathrm{k} = =\mathrm{T - > data})$  //树中存在相同关键字的结点，插入失败return0;else if  $(\mathrm{k} <   \mathrm{T - > data})$  //插入T的左子树return BSTInsert(T->lchild,k);else//插入T的右子树return BSTInsert(T->rchild,k);
```

# 4. 二叉排序树的构造

# 命题追踪 构造二叉排序树的过程（2020）

从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设插入的关键字序列为{45,24,53,45,12,24}，则生成的二叉排序树如图7.6所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cd2b17dca9f65623b325445a6d2d030232e98ef656b7454639e1e1ae65052500.jpg)



(a) 空树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2c6cc949f14b97096a1ce72696ce76e992a09e288a66ac08bd84a1b71976928a.jpg)



(b) 插入45


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a7254c3b461268aee59c0968742392ea1923dba7631574643fac03dad11595ec.jpg)



(c) 插入24


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/43460e51f5458f2278279914af78a84e5629aed8b6f95e52c7ae963747c13b7a.jpg)



(d) 插入53


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d97e1c3fecb72f5e8d2ba09f3f8aa802ff2d9e33baa668e9057a49a4b5698441.jpg)



(e) 插入12



图7.6 二叉排序树的构造过程


构造二叉排序树的算法描述如下：

```c
void Creat_BST(BiTree &T,KeyType str[], int n) {
    T=NULL; //初始时 T 为空树
    int i = 0;
    while (i < n) { //依次将每个关键字插入二叉排序树
        BST_insert(T, str[i]);
        i++;
    }
}
```

# 5. 二叉排序树的删除

在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：

① 若被删除结点  $z$  是叶结点，则直接删除，不会破坏二叉排序树的性质。

② 若结点  $z$  只有一棵左子树或右子树，则让  $z$  的子树成为  $z$  父结点的子树，替代  $z$  的位置。

③ 若结点  $z$  有左、右两棵子树，则令  $z$  的直接后继（或直接前驱）替代  $z$  ，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。

图7.7显示了在3种情况下分别删除结点45,78,78的过程。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f1206944f39de65956b0b0599a16a432961a8b6e72e192d53e8c4f9e87889ac1.jpg)



图7.7 3种情况下的删除过程


# 命题追踪 二叉排序树中删除并插入某结点的分析（2013）

思考：若在二叉排序树中删除并插入某结点，得到的二叉排序树是否和原来的相同？

# 6. 二叉排序树的查找效率分析

二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差的绝对值不超过1（平衡二叉树，下一节），它的平均查找长度和  $O(\log_2n)$  成正比。在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个只有右孩子的单支树，此时二叉排序树的性能显著变坏，树的高度为  $n$  ，则其平均查找长度为  $(n + 1) / 2$  ，如图7.8(b)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/94a5aa1f076ad2f7ec0ae5660781e36f86b902fc95964780d2aad95edad8e34e.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f3ed73fbb55981e210724962ee2d574a37bc9b2f42144539edbaca8c7833c011.jpg)



图7.8 相同关键字组成的不同二叉排序树


在等概率情况下，图7.8(a)查找成功的平均查找长度为

$$
\mathrm {A S L} _ {\mathrm {a}} = (1 + 2 \times 2 + 3 \times 4 + 4 \times 3) / 1 0 = 2. 9
$$

而图7.8(b)查找成功的平均查找长度为

$$
\mathrm {A S L} _ {\mathrm {b}} = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 1 0) / 1 0 = 5. 5
$$

从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，如图7.8所示。

就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为  $O(\log_2n)$  。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是  $O(n)$  。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。

# 7.3.2 平衡二叉树

# 1. 平衡二叉树的定义

为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced Binary Tree），也称AVL树。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。

# 命题追踪 平衡二叉树的定义（2009）

因此，平衡二叉树可定义为或是一棵空树，或是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。图7.9(a)所示是平衡二叉树，图7.9(b)所示是不平衡的二叉树。结点中的数字为该结点的平衡因子。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7198f95d4a74d0038e2120b99b73f420267cc5bf8cad2b157f8374fc17b54551.jpg)



(a)平衡二叉树


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/13f425e44db0b0aea667225b0a4912ff7e9d01979f0fb6dc3f3c0ace68aa6b46.jpg)



(b) 不平衡的二叉树



图7.9 平衡二叉树和不平衡的二叉树


# 2. 平衡二叉树的插入

二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点  $A$  ，再对以  $A$  为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。

# 命题追踪 平衡二叉树中插入操作的特点（2015）

注意，每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/eb5fc805fc40d5fc4f73904c5e79f889089500dafd4d536c9037869e30d6e13f.jpg)



图7.10 最小不平衡子树示意


# 命题追踪

# 平衡二叉树的插入及调整操作的实例（2010、2019、2021）

平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：

1）LL平衡旋转（右单旋转）。由于在结点  $A$  的左孩子（L）的左子树（L）上插入了新结点， $A$  的平衡因子由1增至2，导致以  $A$  为根的子树失去平衡，需要一次向右的旋转操作。将 $A$  的左孩子  $B$  向右上旋转代替  $A$  成为根结点，将  $A$  向右下旋转成为  $B$  的右孩子，而  $B$  的原右子树则作为  $A$  的左子树。如图7.11所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/afe2f88a952ec38c5afe15a34946b39e973d9ac9496592a85f90d25d660808c7.jpg)



(a) 插入结点前


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c7dffbded30af902112bb65d6745edb3fedc12ee80917b015dad80ab5f9c9b9a.jpg)



(b) 插入结点导致不平衡


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fda0ecb6768ab9ae1aa63e63175413b9481f00f0438f9c0d48103bd745b6242c.jpg)



(c)LL旋转（右单旋转）



图7.11 LL平衡旋转


2）RR平衡旋转（左单旋转）。由于在结点  $A$  的右孩子（R）的右子树（R）上插入了新结点， $A$  的平衡因子由-1减至-2，导致以  $A$  为根的子树失去平衡，需要一次向左的旋转操作。将  $A$  的右孩子  $B$  向左上旋转代替  $A$  成为根结点，将  $A$  向左下旋转成为  $B$  的左孩子，而  $B$  的原左子树则作为  $A$  的右子树，如图7.12所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d43b22210941d74f3af8dfe216183dbcaaf386012789b87cefd5295c4bda66a3.jpg)



(a) 插入结点前


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/73c8b9cf828f54132106acdf5126db26745130e248a7625b0f0e333254ae6201.jpg)



(b) 插入结点导致不平衡


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a955b7b4f8c909b3b30e70022cc6bac455f1a7a8f57baa8de093a805625731f9.jpg)



(c)RR旋转(左单旋转）



图7.12 RR平衡旋转


3）LR平衡旋转（先左后右双旋转)。由于在结点  $A$  的左孩子（L）的右子树（R）上插入新结点，  $A$  的平衡因子由1增至2，导致以  $A$  为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将  $A$  的左孩子  $B$  的右子树的根结点  $C$  向左上旋转提升到  $B$  的位置，

然后把  $C$  向右上旋转提升到  $A$  的位置，如图7.13所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a7c399535299041c48c6f3962a55a106151f4b142b9ea3bf32c339dfb73395f4.jpg)



(a)



(a) 插入结点前


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e07f38a3fc50eb9378c11f3b4a3e900323bf578efa05676526109d379e5aea85.jpg)



(b) 插入结点导致不平衡


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b1b32867f2448824d2d22d622275699ab9b67d40eccd3163c00f76ed554eae47.jpg)



(c) LR旋转(双旋转)



图7.13 LR平衡旋转


4）RL平衡旋转（先右后左双旋转)。由于在结点  $A$  的右孩子（R）的左子树（L）上插入新结点，  $A$  的平衡因子由-1减至-2，导致以  $A$  为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将  $A$  的右孩子  $B$  的左子树的根结点  $C$  向右上旋转提升到  $B$  的位置，然后把  $C$  向左上旋转提升到  $A$  的位置，如图7.14所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c731444427f54a98cbe319c1d02f8ddc3308c69bc6dfe0bebea8904d404bd747.jpg)



(a) 插入结点前


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ec1c085b3fcf076fa8767c5022331f3046a0dfd076a573f59473738791200bff.jpg)



(b) 插入结点导致不平衡


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a947f556d721f0ae5f37b32ee4011d92a30e58dc4c2311f1221ffc54e76b6027.jpg)



(c) RL旋转(双旋转)



图7.14 RL平衡旋转


# 注意

公众号：小兔网盘 免费分享无水印PDF

LR和RL旋转时，新结点究竟是插入  $C$  的左子树还是插入  $C$  的右子树不影响旋转过程，而图7.13和图7.14中以插入  $C$  的左子树中为例。

# 命题追踪

# 构造平衡二叉树的过程（2013）

以关键字序列{15,3,7,10,9,8}构造一棵平衡二叉树的过程为例，图7.15(d)插入7后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的右子树，所以执行LR旋转，先左后右双旋转，调整后的结果如图7.15(e)所示。图7.15(g)插入9后导致不平衡，最小不平衡子树的根为15，插入位置为其左孩子的左子树，所以执行LL旋转，右单旋转，调整后的结果如图7.15(h)所示。图7.15(i)插入8后导致不平衡，最小不平衡子树的根为7，插入位置为其右孩子的左子树，所以执行RL旋转，先右后左双旋转，调整后的结果如图7.15(j)所示。

# 3. 平衡二叉树的删除

与平衡二叉树的插入操作类似，以删除结点  $w$  为例来说明平衡二叉树删除操作的步骤：

1）用二叉排序树的方法对结点  $w$  执行删除操作。

2）若导致了不平衡，则从结点  $w$  开始向上回溯，找到第一个不平衡的结点  $z$  （最小不平衡子树）；  $y$  为结点  $z$  的高度最高的孩子；  $x$  是结点  $y$  的高度最高的孩子。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7389e36658f69810c73e3c837549871931f292a7cae4f63c386c5bab3d15d2d9.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e6caeb3ce13633e3628bf7721046689456bb4f4b564a2033b518b825b236ce20.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c62c03bc87e2441e7420663662ea0e24eb8d024528957b3f852626c543d3cb87.jpg)



(a)空树



(b) 插入15



(c) 插入3


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2f6f3fb25d5ed696aa5887562bb9fdb2a2d1a6b5d77aff175e281d914c1183e8.jpg)



(d) 插入7


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/811305049f73d9cb97a5ccf52301fe08e2ad471843a734744c8b5fccf7faa297.jpg)



(c)L.R旋转


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4f5bcfe6746929f9cf839394e16a87caa84e9b1495f9c071a404b4b9413ef297.jpg)



(f) 插入 10


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/84d64355317deedcdf3d59719e40b10525bafaff3d89f32d92306ea1819aed51.jpg)



(g) 插入9


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5229a78c77773b3d76dff32de93bcd64c508b6ab47beb932f5ce358840cc2995.jpg)



(h) L1 旋转


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/009af0baf075f6da64c2955fd52f2a068a91bd197b7a8bbf97bb12f2e46cbf2b.jpg)



(i) 插入 8


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1ef3d37ead60bcb6e86ac79dab6bea7b1014dd1708a2a40d9bbe860370357761.jpg)



(j)RL旋转



图7.15 平衡二叉树的生成过程


3）然后对以  $z$  为根的子树进行平衡调整，其中  $x$ 、 $y$  和  $z$  可能的位置有4种情况：

-  $y$  是  $z$  的左孩子， $x$  是  $y$  的左孩子（LL，右单旋转）；

-  $y$  是  $z$  的左孩子， $x$  是  $y$  的右孩子（LR，先左后右双旋转）；

-  $y$  是  $z$  的右孩子， $x$  是  $y$  的右孩子（RR，左单旋转）；

-  $y$  是  $z$  的右孩子， $x$  是  $y$  的左孩子（RL，先右后左双旋转）。

这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以  $z$  为根的子树进行平衡调整；而删除操作就不一样，先对以  $z$  为根的子树进行平衡调整，若调整后子树的高度减1，则可能需要对  $z$  的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。

以删除图7.16(a)的结点32为例，由于32为叶结点，直接删除即可，向上回溯找到第一个不平衡结点44（z），z的高度最高的孩子结点为78（y），y的高度最高的孩子结点为50（x），满足RL情况，先右后左双旋转，调整后的结果如图7.16(c)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8eaa9d50a1c6e89e2eaa5a837f30cfd0051a5ef71e6b7b33b4a2da1b40137cf1.jpg)



(a) 删除32前


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/61f5857884deaab054d1af5254490f05f0ebd5535c6409b934883400946afebd.jpg)



(b) 右旋


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1df1278348ad865838e1fd503a0c5d213537a98b4db3c70bd6a8aa010e4a7c0a.jpg)



(c) 左旋



图7.16 平衡二叉树的删除


# 4. 平衡二叉树的查找

# 命题追踪

# 指定条件下平衡二叉树的结点数的分析（2012）

在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，进行关键字的比较次数不超过树的深度。假设以  $n_h$  表示深度为  $h$  的平衡二叉树中含有的最少结点数。显然，有

$n_0 = 0, n_1 = 1, n_2 = 2$ ，并且有  $n_h = n_{h-2} + n_{h-1} + 1$ ，如图7.17所示，依次推出  $n_3 = 4, n_4 = 7, n_5 = 12, \dots$ 。含有  $n$  个结点的平衡二叉树的最大深度为  $O(\log_2 n)$ ，因此平均查找效率为  $O(\log_2 n)$ 。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ce893923cb522cbd57da6e359eb378fce741ddc1d6e1e3ef3af6d13af3eecd27.jpg)



图7.17 结点个数  $n$  最少的平衡二叉树


# 注意

该结论可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数（或树的最大高度）。如在含有12个结点的平衡二叉树中查找某个结点的最多比较次数？

深度为  $h$  的平衡二叉树中含有的最多结点数显然是满二叉树的情况。

# 7.3.3 红黑树

# 1.红黑树的定义

为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构，代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。

一棵红黑树是满足如下红黑性质的二叉排序树：

① 每个结点或是红色，或是黑色的。

② 根结点是黑色的。

③ 叶结点（虚构的外部结点、NULL 结点）都是黑色的。

④ 不存在两个相邻的红结点（红结点的父结点和孩子结点均是黑色的）。

⑤ 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。

与折半查找树和B树类似，为了便于对红黑树的实现和理解，引入了  $n + 1$  个外部叶结点，以保证红黑树中每个结点（内部结点）的左、右孩子均非空。图7.18所示是一棵红黑树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/709b227bf2e6d3b2083cb7bcaa93b7b98db31bb6a09e42706c1c354ab0904ff0.jpg)



图7.18 一棵红黑树


从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh），黑高的概念是由性质⑤确定的。根结点的黑高称为红黑树的黑高。

结论1：从根到叶结点的最长路径不大于最短路径的2倍。

由性质⑤，当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。由性质④，当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和

黑结点的数量相同。图7.18中的6-2和  $6 - 15 - 18 - 20$  就是这样的两条路径。

结论2：有  $n$  个内部结点的红黑树的高度  $h \leqslant 2\log_2(n + 1)$ 。

证明：由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为  $h / 2$  ，于是有  $n\geqslant 2^{h / 2} - 1$  ，即可求得结论。

由结论2也可推出，黑高为  $h$  的红黑树的内部结点数最少是  $2^{h} - 1$  ，最多是  $2^{2h} - 1$  。

可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任意一个结点左右子树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，若插入和删除操作比较少，查找操作比较多，则采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C++中的map和set（Java中的TreeMap和TreeSet）就是用红黑树实现的。

# 2.红黑树的插入

红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。

# 结论3：新插入红黑树中的结点初始着为红色。

假设新插入的结点初始着为黑色，则这个结点所在的路径比其他路径多出一个黑结点（几乎每次插入都破坏性质⑤），调整起来也比较麻烦。若插入的结点是红色的，则此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。

设结点  $z$  为新插入的结点。插入过程描述如下：

1)用二叉查找树插入法插入，并将结点  $z$  着为红色。若结点  $z$  的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树，结束。

2）若结点  $z$  是根结点，则将  $z$  着为黑色（树的黑高增1），结束。

3）若结点  $z$  不是根结点，且  $z$  的父结点  $z.p$  是红色的，则分为下面三种情况，区别在于  $z$  的叔结点  $y$  的颜色不同，因  $z.p$  是红色的，插入前的树是合法的，根据性质②和④，爷结点  $z.p.p$  必然存在且为黑色。性质④只在  $z$  和  $z.p$  之间被破坏了。

情况1：  $z$  的叔结点  $y$  是黑色的，且  $z$  是一个右孩子。

情况2：  $z$  的叔结点  $y$  是黑色的，且  $z$  是一个左孩子。

每棵子树  $T_{1}$  、  $T_{2}$  、  $T_{3}$  和  $T_{4}$  都有一个黑色根结点，且具有相同的黑高。

情况1（LR，先左旋，再右旋），即  $z$  是其爷结点的左孩子的右孩子。先做一次左旋将此情形转变为情况2（变为情况2后再做一次右旋），左旋后  $z$  和父结点  $z.p$  交换位置。因为  $z$  和  $z.p$  都是红色的，所以左旋操作对结点的黑高和性质⑤都无影响。

情况2（LL，右单旋），即  $z$  是其爷结点的左孩子的左孩子。做一次右旋，并交换  $z$  的原父结点和原爷结点的颜色，就可以保持性质⑤，也不会改变树的黑高。这样，红黑树中也不再有连续两个红结点，结束。情况1和情况2的调整方式如图7.19所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/668eea2c93c0b7353b13b4d7041ae9cbbe909194a0ab62e382d6d762f38faf71.jpg)



图7.19 情况1和情况2的调整方式


若父结点  $z.p$  是爷结点  $z.p.p$  的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和RR（左单旋），这里不再赘述。红黑树的调整方法和AVL树的调整方法有异曲同工之妙。

情况3：  $z$  的叔结点  $y$  是红色的。

情况3（z是左孩子或右孩子无影响），z的父结点  $z.p$  和叔结点  $y$  都是红色的，因为爷结点  $z.p.p$  是黑色的，将  $z.p$  和  $y$  都着为黑色，将  $z.p.p$  着为红色，以在局部保持性质④和⑤。然后，把  $z.p.p$  作为新结点  $z$  来重复循环，指针  $z$  在树中上移两层。调整方式如图7.20所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ed98d94255595ee558a7022c85d4f4a03eb3cb072600e5f818949d2ed8518698.jpg)



图7.20 情况3的调整方式


若父结点  $z.p$  是爷结点  $z.p.p$  的右孩子，也还有两种对称的情况，不再赘述。

只要满足情况3的条件，就会不断循环，每次循环指针  $z$  都会上移两层，直到满足2）（表示 $z$  上移到根结点）或情况1或情况2的条件。

可能的疑问：虽然插入的初始位置一定是红黑树的某个叶结点，但因为在情况3中，结点  $z$  存在不断上升的可能，所以对于三种情况，结点  $z$  都有存在子树的可能。

以图7.21(a)中的红黑树为例（虚线表示插入后的状态），先后插入5、4和12的过程如图7.21所示。插入5，为情况3，将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时因为7已是根，所以又重新着为黑色，树的黑高加1，结束。插入4，为情况1的对称情况（RL)，此时特别注意虚构黑色空结点的存在，先对以5为根的子树做右旋；转变为情况2的对称情况(RR)，交换3和4的颜色，再对以4为根的子树做左旋，结束。插入12，父结点是黑色的，无须任何调整，结束。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0d8ef50a437d6223d124c5186adff9e9aa7f666a896b84848a460287f0da3cf5.jpg)



图7.21 红黑树的插入过程


# *3. 红黑树的删除

# 注意

本节难度较大，考查概率较低，读者可根据自身情况决定是否学习或学习的时机。

红黑树的插入操作容易导致连续的两个红结点，破坏性质④。而删除操作容易造成子树黑高的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质⑤。

删除过程也是先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后继结点至多只有一个孩子，这样就转换为待删结点是终端结点或仅有一个孩子的情况。

最终，删除一个结点有以下两种情况：

- 待删结点只有右子树或左子树。

- 待删结点没有孩子。

1）若待删结点只有右子树或左子树，则只有两种情况，如图7.22所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dd907dad1ccaac64c6c535b58274f046b514d8b015010c6ee6c6921fd887118d.jpg)



图7.22 只有右子树或左子树的删除情况


只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质⑤。

2）待删结点无孩子，且该结点是红色的，这时可直接删除，而不需要做任何调整。

3）待删结点无孩子，且该结点是黑色的，这时设待删结点为  $y$  ， $x$  是用来替换  $y$  的结点（注意，当  $y$  是终端结点时， $x$  是黑色的 NULL 结点）。删除  $y$  后将导致先前包含  $y$  的任何路径上的黑结点数量减 1，因此  $y$  的任何祖先都不再满足性质⑤，简单的修正办法就是将替换  $y$  的结点  $x$  视为还有额外一重黑色，定义为双黑结点。也就是说，若将任何包含结点  $x$  的路径上的黑结点数量加 1，则在此假设下，性质⑤得到满足，但破坏了性质①。于是，删除操作的任务就转化为将双黑结点恢复为普通结点。

分为以下四种情况，区别在于  $x$  的兄弟结点  $w$  及  $w$  的孩子结点的颜色不同。

情况1：  $x$  的兄弟结点  $\mathcal{W}$  是红色的。

情况1， $w$  必须有黑色左右孩子和父结点。交换  $w$  和父结点  $x.p$  的颜色，然后对  $x.p$  做一次左旋，而不会破坏红黑树的任何规则。现在， $x$  的新兄弟结点是旋转之前  $w$  的某个孩子结点，其颜色为黑色，这样，就将情况1转换为情况2、3或4处理。调整方式如图7.23所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f357b085cf318c8d3ed1a7b253b87b8d08dd15b13cefa1215bc9c96f8f3ec61f.jpg)



图7.23 情况1的调整方式


情况2：  $x$  的兄弟结点  $\mathcal{W}$  是黑色的，且  $\mathcal{W}$  的右孩子是红色的。

情况3：  $x$  的兄弟结点  $\mathcal{W}$  是黑色的，  $\mathcal{W}$  的左孩子是红色的，  $\mathrm{w}$  的右孩子是黑色的。

情况2（RR，左单旋），即这个红结点是其爷结点的右孩子的右孩子。交换  $w$  和父结点  $x.p$

的颜色，把  $w$  的右孩子着为黑色，并对  $x$  的父结点  $x.p$  做一次左旋，将  $x$  变为单重黑色，此时不再破坏红黑树的任何性质，结束。调整方式如图 7.24 所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d712e7633cd5b47006ad3bab8b41d93facf096a77de34a3f3ef32eaacfb83d8d.jpg)



图7.24 情况2的调整方式


情况3（RL，先右旋，再左旋)，即这个红结点是其爷结点的右孩子的左孩子。交换  $w$  和其左孩子的颜色，然后对  $w$  做一次右旋，而不破坏红黑树的任何性质。现在，  $x$  的新兄弟结点  $w$  的右孩子是红色的，这样就将情况3转换为了情况2。调整方式如图7.25所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/46fb93820e564972a84c40399b6adfc35859bba73e178ba78847ad81b4779400.jpg)



图7.25 情况3的调整方式


情况4：  $x$  的兄弟结点  $\pmb{w}$  是黑色的，且  $\pmb{w}$  的两个孩子结点都是黑色的。

在情况4中，因为  $w$  也是黑色的，所以可从  $x$  和  $w$  上去掉一重黑色，使得  $x$  只有一重黑色而  $w$  变为红色。为了补偿从  $x$  和  $w$  中去掉的一重黑色，把  $x$  的父结点  $x.p$  额外着一层黑色，以保持局部的黑高不变。通过将  $x.p$  作为新结点  $x$  来循环， $x$  上升一层。若是通过情况1进入情况4的，因为原来的  $x.p$  是红色的，将新结点  $x$  变为黑色，终止循环，结束。调整方式如图7.26所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0b018a2eeb8810055f08ebc7eccc64cff04e989c18634cdd3e190c9245e724fd.jpg)



图7.26 情况4的调整方式


若  $x$  是父结点  $x.p$  的右孩子，则还有四种对称的情况，处理方式类似，不再赘述。

归纳总结：在情况4中，因  $x$  的兄弟结点  $w$  及左右孩子都是黑色，可以从  $x$  和  $w$  中各提取一重黑色（以让  $x$  变为普通黑结点），不会破坏性质④，并把调整任务向上“推”给它们的父结点 $xp$  。在情况1、2和3中，因为  $x$  的兄弟结点  $w$  或  $w$  左右孩子中有红结点，所以只能在  $xp$  子树内用调整和重新着色的方式，且不能改变  $x$  原根结点的颜色（否则向上可能破坏性质④)。情况1虽然可能会转换为情况4，但因为新  $x$  的父结点  $xp$  是红色的，所以执行一次情况4就会结束。情况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯

一情况，每执行一次指针  $x$  上升一层，至多  $O(\log_2n)$  次。

以图7.27(a)中的红黑树为例（虚线表示删除前的状态），依次删除5和15的过程如图7.27所示。删除5，用虚构的黑色NULL结点（图中为N结点）替换，视为双黑NULL结点，为情况1，交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4，从双黑NULL结点和10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），因原父结点8是红色，所以将8变为黑色，结束。删除15，为情况3的对称情况（LR)，交换8和10的颜色，对8做左旋；转变为情况2的对称情况（LL)，交换10和12的颜色（两者颜色一样，无变化)，将10的左孩子8着为黑色，对12做右旋，结束。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3ab00d29d7914c779a23a96c33e3ee266c50d0c31347e6f496759e3db54da140.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e14e97b77b610727c16d9dbad984098b0c529a305db4d485384f043eb0e1c407.jpg)



图7.27 红黑树的删除过程


# 7.3.4 本节试题精选

# 一、单项选择题

01. 对于二叉排序树，下面的说法中，（）是正确的。

A. 二叉排序树是动态树表, 查找失败时插入新结点, 会引起树的重新分裂和组合

B. 对二叉排序树进行层序遍历可得到有序序列

C. 用逐点插入法构造二叉排序树, 若先后插入的关键字有序, 二叉排序树的深度最大

D. 在二叉排序树中进行查找, 关键字的比较次数不超过结点数的  $1 / 2$

02. 按（）遍历二叉排序树得到的序列是一个有序序列。

A. 先序

B. 中序

C. 后序

D. 层次

03. 在二叉排序树中进行查找的效率与（）有关。

A. 二叉排序树的深度

B. 二叉排序树的结点的个数

C. 被查找结点的度

D. 二叉排序树的存储结构

04. 在常用的描述二叉排序树的存储结构中，关键字值最大的结点（）。

A. 左指针一定为空

B. 右指针一定为空

C. 左右指针均为空

D. 左右指针均不为空

05. 设二叉排序树中关键字由 1 到 1000 的整数构成，现要查找关键字为 363 的结点，下述关键字序列中，不可能是在二叉排序树上查找的序列是（）。

A. 2, 252, 401, 398, 330, 344, 397, 363

B. 924, 220, 911, 244, 898, 258, 362, 363

C. 925, 202, 911, 240, 912, 245, 363

D. 2,399,387,219,266,382,381,278,363

06. 分别以下列序列构造二叉排序树，与用其他3个序列所构造的结果不同的是（）。

A. (100, 80, 90, 60, 120, 110, 130)

B. (100, 120, 110, 130, 80, 60, 90)

C. (100, 60, 80, 90, 120, 110, 130)

D. (100, 80, 60, 90, 120, 130, 110)

07. 从空树开始，依次插入元素52,26,14,32,71,60,93,58,24和41后构成了一棵二叉排序树。在该树查找60要进行比较的次数为（）。

A. 3

B. 4

C. 5

D. 6

08. 在含有 n 个结点的二叉排序树中查找某个关键字的结点时，最多进行（）次比较。

A.  $n / 2$

B.  $\log_2 n$

C.  $\log_2 n + 1$

D.  $n$

09. 五个不同结点构造的二叉查找树的形态共有（）种。

A. 20

B. 30

C. 32

D. 42

10. 构造一棵具有  $n$  个结点的二叉排序树时，最理想情况下的深度为（）。

A.  $n / 2$

B.  $n$

C.  $\lfloor \log_2(n + 1)\rfloor$

D.  $\left\lceil \log_2(n + 1) \right\rceil$

11. 含有20个结点的平衡二叉树的最大深度为（）。

A. 4

B. 5

C. 6

D. 7

12. 具有5层结点的平衡二叉树至少有（）个结点。

A. 10

B. 12

C. 15

D. 17

13. 高度为 3 的平衡二叉排序树的形态共有（）种。

A. 13

B. 14

C. 16

D. 15

14. 在平衡二叉树的基本操作中，可能发生两次旋转的操作是（）。

A. 添加、删除结点

B. 仅删除结点

C. 仅添加结点

D. 都不会

15. 将关键字  $1,2,3,\cdots,1024$  依次插入到初始为空的平衡二叉树中，假设只有一个根结点的二叉树的高度为 0，则插入结束后的平衡二叉树的高度是（）。

A. 8

B. 9

C. 10

D. 11

16. 下列关于红黑树和AVL树的说法中，不正确的是（）。

I. 一棵含有  $n$  个结点的红黑树的高度至多为  $2\log_2(n + 1)$

II. 若一个结点是红色的，则它的父结点和孩子结点都是黑色的

III. 红黑树的查询效率一般要优于含有相同结点数的AVL树

IV. 若AVL树的某结点的左右孩子的平衡因子都是零，则该结点的平衡因子也是零

A. I、III

B. III

C. II、IV

D. III、IV

17. 下列关于红黑树和AVL树的描述中，不正确的是（）。

A. 两者都属于自平衡的二叉树

B. 两者查找、插入、删除的时间复杂度都相同

C. 红黑树插入和删除过程至多有 2 次旋转操作

D. 红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过 2

18. 下列关于红黑树的说法中，正确的是（）。

A. 红黑树的红结点的数目最多和黑结点的数目相同

B. 若红黑树的所有结点都是黑色的, 则它一定是一棵满二叉树

C. 红黑树的任何一个分支结点都有两个非空孩子结点

D. 红黑树的子树也一定是红黑树

19. 下列四个选项中，满足红黑树定义的是（）。


A.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5158f23265ed681f09394e76fd1022a2d213c0298ea3809880d1c8a1daec9c60.jpg)



B.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b4394426e0bc0d68b2c264c2f3f381e4da0318c0519f7212f355954f1cf2d09d.jpg)



C.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/af2fbd2aa9002d6e512e4d5d844d4817e3e227558279eb87f4f0711796307c0b.jpg)



D.


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/31a759f2dafbb96304ba312a843b18dec3d6e351aadafe402f3c7fa4034a5d61.jpg)


20. 将关键字 1,2,3,4,5,6,7 依次插入初始为空的红黑树  $T$  ，则  $T$  中红结点的个数是（）。

A. 1

B. 2

C. 3

D. 4

21. 将关键字 5,4,3,2,1 依次插入初始为空的红黑树  $T$ ，则  $T$  的最终形态是（）。

A.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/84884b04f810a81b974f68e6b43df575d282f1c74a58a48fd16e23847f589add.jpg)


B.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d495ba09e11062e188987b43362359c35e6ff8f37726a6b4b144d880b357f76d.jpg)


C.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/81671a041bdd7bcbf122ac9715e1a606496e06fc272e22f3f85755bab4a3995d.jpg)


D.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/400bba0631db49fa4d9b26a96d23e40f0734792107aff620bcf9d9041f4ae5b7.jpg)


22. 在下图所示的红黑树中插入结点 2 且染成红色后，则下一步应进行的操作是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e16d023eefd6f495b58a18b0ad77daf1eb816343e1cd055cd170a630cdff5e29.jpg)


A. 左旋

B. 右旋

C. 变色

D. 无须调整

23.【2009统考真题】下列二叉排序树中，满足平衡二叉树定义的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/68cca011512a6da2257c75c8f578812cd012c34837680c5192096ed0b051cff4.jpg)


A.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d5849503aec5f268fb23eb909831e252a8158bcd47b33c75febf3bc4b7c7782e.jpg)


B.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0955253c6038be3b576198cbed02ae9b95186a369e309f3bb05872fe75fd8339.jpg)


C.

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/164ab2838a1c6aa08c7ff0f6cc7fe369920ef7af0774821d11ccec73d53d1db6.jpg)


D.

24.【2010统考真题】在下图所示的平衡二叉树中插入关键字48后得到一棵新平衡二叉树，在新平衡二叉树中，关键字37所在结点的左、右子结点中保存的关键字分别是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9b02e365bd2c4f3f71665f38b3e5a30b706430a482a688dae32d873f28cfbcf4.jpg)


A. 13,48

B. 24, 48

C. 24, 53

D. 24, 90

25.【2011统考真题】对下列关键字序列，不可能构成某二叉排序树中一条查找路径的是（）。

A. 95, 22, 91, 24, 94, 71

B. 92, 20, 91, 34, 88, 35

C. 21, 89, 77, 29, 36, 38

D. 12, 25, 71, 68, 33, 34

26.【2012统考真题】若平衡二叉树的高度为6，且所有非叶结点的平衡因子均为1，则该平衡二叉树的结点总数为（）。

A. 12

B. 20

C. 32

D. 33

27.【2013统考真题】在任意一棵非空二叉排序树  $T_{1}$  中，删除某结点  $\nu$  之后形成二叉排序树 $T_{2}$ ，再将  $\nu$  插入  $T_{2}$  形成二叉排序树  $T_{3}$  。下列关于  $T_{1}$  与  $T_{3}$  的叙述中，正确的是（）。

I. 若  $v$  是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  不同

II. 若  $v$  是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  相同

III. 若  $v$  不是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  不同

IV. 若  $v$  不是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  相同

A. 仅 I、III

B. 仅 I、IV

C. 仅 II、III

D. 仅 II、IV

28.【2013统考真题】若将关键字1,2,3,4,5,6,7依次插入初始为空的平衡二叉树  $T$  ，则  $T$  中平衡因子为0的分支结点的个数是（）。

A. 0

B. 1

C. 2

D. 3

29.【2015统考真题】现有一棵无重复关键字的平衡二叉树（AVL），对其进行中序遍历可得到一个降序序列。下列关于该平衡二叉树的叙述中，正确的是（）。

A. 根结点的度一定为 2

B. 树中最小元素一定是叶结点

C. 最后插入的元素一定是叶结点

D. 树中最大元素一定是无左子树

30.【2018统考真题】已知二叉排序树如下图所示，元素之间应满足的大小关系是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c99be07e47a8f7f22f60a88d1895fda1a994960766dc67da04da3eee69182b9f.jpg)


A.  $x_{1} <   x_{2} <   x_{5}$

B.  $x_{1} <   x_{4} <   x_{5}$

C.  $x_{3} <   x_{5} <   x_{4}$

D.  $x_{4} <   x_{3} <   x_{5}$

31.【2019统考真题】在任意一棵非空平衡二叉树（AVL树）  $T_{1}$  中，删除某结点  $\nu$  之后形成平衡二叉树  $T_{2}$ ，再将  $\nu$  插入  $T_{2}$  形成平衡二叉树  $T_{3}$ 。下列关于  $T_{1}$  与  $T_{3}$  的叙述中，正确的是（）。

I. 若  $v$  是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  可能不相同

II. 若  $v$  不是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  一定不相同

III. 若  $v$  不是  $T_{1}$  的叶结点，则  $T_{1}$  与  $T_{3}$  一定相同

A. 仅 I

B. 仅 II

C. 仅 I、II

D. 仅 I、III

32.【2020统考真题】下列给定的关键字输入序列中，不能生成右边二叉排序树的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/86a2a525cb568679829a7e268ac5ae3197012e6e88aef2a6ff3749d3d90b9402.jpg)


A. 4,5,2,1,3

B. 4, 5, 1, 2, 3

C.  $4,2,5,3,1$

D.  $4,2,1,3,5$

33.【2021统考真题】给定平衡二叉树如下图所示，插入关键字23后，根中的关键字是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a65724aa97ea0568551b60425156d13d6dfbcf5a6ea9c3208231c60f12e2b2ba.jpg)


A. 16

B. 20

C. 23

D. 25

34.【2024统考真题】一棵二叉搜索树如下图所示， $k_{1}$ 、 $k_{2}$ 、 $k_{3}$ 分别是对应结点中保存的关键字。子树  $T$  的任一结点中保存的关键字  $x$  满足的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/53e69224b0fd3a8cd0c0dc0657542f5593218b9ef893db041c605aee6845c0dc.jpg)


A.  $x < k_{1}$

B.  $x > k_{2}$

C.  $k_{1} <   x <   k_{3}$

D.  $k_{3} <   x <   k_{2}$

# 二、综合应用题

01. 一棵二叉排序树按先序遍历得到的序列为(50,38,30,45,40,48,70,60,75,80)，试画出该二叉排序树，并求出等概率下查找成功和查找失败的平均查找长度。

02. 按照序列(40, 72, 38, 35, 67, 51, 90, 8, 55, 21)建立一棵二叉排序树，画出该树，并求出在等概率的情况下，查找成功的平均查找长度。

03. 依次把结点(34,23,15,98,115,28,107)插入初始状态为空的平衡二叉排序树，使得在每次插入后保持该树仍然是平衡二叉树。请依次画出每次插入后所形成的平衡二叉排序树。

04. 给定一个关键字集合  $\{25, 18, 34, 9, 14, 27, 42, 51, 38\}$ ，假定查找各关键字的概率相同，请画出其最佳二叉排序树。

05. 试编写一个算法，判断给定的二叉树是否是二叉排序树。

06. 设计一个算法，求出指定结点在给定二叉排序树中的层次。

07. 利用二叉树遍历的思想编写一个判断二叉树是否是平衡二叉树的算法。

08. 设计一个算法，求出给定二叉排序树中最小和最大的关键字。

09. 设计一个算法，从大到小输出二叉排序树中所有值不小于  $k$  的关键字。

10. 编写一个递归算法，在一棵有  $n$  个结点的、随机建立起来的二叉排序树上查找第  $k$  （ $1 \leqslant k \leqslant n$ ）小的元素，并返回指向该结点的指针。要求算法的平均时间复杂度为  $O(\log_2 n)$  。二叉排序树的每个结点中除 data、lchild、rchild 等数据成员外，增加一个 count 成员，保存以该结点为根的子树上的结点个数。

# 7.3.5 答案与解析

# 一、单项选择题

01. C

二叉排序树插入新结点时不会引起树的分裂组合。对二叉排序树进行中序遍历可得到有序序列。当插入的关键字有序时，二叉排序树会形成一个长链，此时深度最大。在此种情况下进行查找，有可能需要比较每个结点的关键字，超过总结点数的1/2。

# 02. B

由二叉排序树的定义不难得出中序遍历二叉树得到的序列是一个有序序列。

# 03. A

二叉排序树的查找路径是自顶向下的，其平均查找长度主要取决于树的高度。

# 04. B

在二叉排序树的存储结构中，每个结点由三部分构成，其中左（或右）指针指向比该结点的关键字值小（或大）的结点。关键字值最大的结点位于二叉排序树的最右位置，因此它的右指针一定为空（有可能不是叶结点）。还可用反证法，若右指针不为空，则右指针上的关键字肯定比原关键字大，所以原关键字结点一定不是值最大的，与条件矛盾，所以右指针一定为空。

# 05.C

在二叉排序树上查找时，先与根结点值进行比较，若相同，则查找结束，否则根据比较结果，沿着左子树或右子树向下继续查找。根据二叉排序树的定义，有左子树结点值  $\leqslant$  根结点值  $\leqslant$  右子树结点值。C序列中，比较911关键字后，应转向其左子树比较240，左子树中不应出现比911更大的数值，但240竟有一个右孩子结点值为912，所以不可能是正确的序列。

# 06.C

按照二叉排序树的构造方法，不难得到A,B,D序列的构造结果相同。

# 07. A

以第一个元素为根结点，依次将元素插入树，生成的二叉排序树如下图所示。进行查找时，先与根结点比较，然后根据比较结果，继续在左子树或右子树上进行查找。比较的结点依次为52,71,60。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2710952e9f0635d85444560d0fdf7ecc13f716fbe7eeb4cfcfbe9c3f1d2d89e4.jpg)


# 08. D

当输入序列是一个有序序列时，构造的二叉排序树是一个单支树，当查找一个不存在的关键字值或最后一个结点的关键字值时，需要  $n$  次比较。

# 09. D

五个不同结点构造的二叉查找树，中序序列是确定的。先序序列的个数为  $n = 5$  的卡特兰数，加上中序序列和先序序列能唯一确定一棵二叉树，因此二叉排序树的形态共有  $\mathrm{Catalan}(5) = 42$  种。

# 10. D

当二叉排序树的叶结点全部都在相邻的两层内时，深度最小。理想情况是从第一层到倒数第二层为满二叉树。类比完全二叉树，可得深度为  $\lceil \log_2(n + 1)\rceil$

# 11. C

平衡二叉树结点数的递推公式为  $n_0 = 0$ ， $n_1 = 1$ ， $n_2 = 2$ ， $n_h = 1 + n_{h-1} + n_{h-2}$ （ $h$  为平衡二叉树高度， $n_h$  为构造此高度的平衡二叉树所需的最少结点数）。通过递推公式可得，构造5层平衡二叉树至少需12个结点，构造6层至少需要20个结点。

# 12. B

设  $n_h$  表示高度为  $h$  的平衡二叉树中含有的最少结点数，则有  $n_1 = 1, n_2 = 2, n_h = n_{h-1} + n_{h-2} + 1$ ，由

此求出  $n_5 = 12$ ，对应的AVL如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a046da01190cc0e7df46ffa708e059df56ade3c65fa0158197e4237301ebc170.jpg)


# 13. D

高度为3的平衡二叉树的左右子树的高度共有三种情况：①左右子树都是高度为2的平衡二叉树；②左子树是高度为1的平衡二叉树，右子树是高度为2的平衡二叉树；③左子树是高度为2的平衡二叉树，右子树是高度为1的平衡二叉树。高度为1的平衡二叉树只有1种形态，即单个结点，如图1所示；高度为2的平衡二叉树有3种形态，如图2所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/76142384290b95c4e701c37d4a6a2121f47ab46c3d4610b6ff010231df16bcf5.jpg)



图1


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f8168d4f22a31aba9ccd8d5129f7bb16c08db64460e5fe813938a237ec5af90a.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cc5e991dab22e2fee7382e1d20c27877a1a87f0c80a103b46db7e54757fa2a2c.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7cd5178593c7203cea288d8129fbd6a1945a891bc0b476b8e3de43ea87377158.jpg)



图2


因此，对于情况①，共有  $3 \times 3 = 9$  种树形态；对于情况②，共有  $1 \times 3 = 3$  种树形态；情况③和情况②类似，也有3种树形态，所以共有  $9 + 3 + 3 = 15$  种树形态。

# 14. A

插入和删除结点都有可能引起 LR 平衡旋转或者 RL 平衡旋转，发生两次旋转操作。

# 15. C

当按关键字有序的顺序插入初始为空的平衡二叉树时，若关键字个数  $n = 2^k - 1$  时，则该平衡二叉树一定是一棵满二叉树（可以用  $1 \sim 3$  、  $1 \sim 7$  手工验证）。当插入关键字1023时，平衡二叉树正好是一棵满二叉树，高度是9。因此，插入关键字1024后，平衡二叉树的高度是10。

# 16. D

I和II都是红黑树的性质。AVL是高度平衡的二叉查找树，红黑树是适度平衡的二叉查找树，从这一点也可以看出AVL的查询效率往往更优，III错误。AVL的某结点的左右孩子的平衡因子都是零，并不能说明左右子树的高度相等，因此该结点的平衡因子不一定为零，IV错误。

# 17. C

自平衡的二叉排序树是指在插入和删除时能自动调整以保持其所定义的平衡性，两者都属于自平衡二叉树，选项A正确。两者的查找、插入、删除操作的时间复杂度都为  $O(\log_2n)$ ，选项B正确。在红黑树中删除结点时，情况1可能变为情况2、3或4，情况2会变为情况3，可能会出现旋转次数超过2次的情况，选项C错误。从任一结点到每个叶结点的所有路径都包含相同数目的黑结点，没有两个连续的红结点，且叶结点是黑色的，这意味着在任一结点到其左右子树中最远和最近的叶结点之间，红结点的数目小于或等于黑结点的数目，路径长度之比不超过2，选项D正确。

# 18. B

红黑树的红结点数目最大可以是黑结点数目的2倍（如一棵有3个结点的红黑树，第1层为黑色，第2层为红色），选项A错误。从根结点出发到所有叶结点的黑结点数是相同的，若所有结

点都是黑色，则一定是满二叉树，选项B正确。考虑某个黑结点，它可以有一个空叶结点孩子和一个非空红结点孩子，选项C错误。红黑树中可能存在红结点，根结点为红色的子树不是红黑树，选项D错误。

19. A

红黑树是一种特殊的二叉排序树，选项B不满足二叉排序树的性质。选项C中，结点2的左右黑结点数不同。在选项D中，结点3的左右黑结点数不同。只有选项A满足红黑树的定义。

20. C

关键字1,2,3,4,5,6,7依次插入红黑树后的形态变化如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8d85cbeee5373132610fed34787de38e12da71c4df082ea882a6080c380493ad.jpg)


21. D

关键字5,4,3,2,1依次插入红黑树后的形态变化如下：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0201de8ac32c86ce39d1fd504593606470273037230e742cba67415236099902.jpg)


22. B

插入结点2且将其染成红色后违反不红红原则，并且叔结点是黑色，应进行LL旋转，将结点3右旋旋转到结点5的位置，结点2和结点5分别成为结点3的左、右孩子，然后将结点3染成黑色，结点2和结点5染成红色。因此，下一步应进行右旋操作。

23. B

根据平衡二叉树的定义，任意结点的左、右子树高度差的绝对值不超过1。而其余3个答案均可以找到不满足条件的结点。答题时可以把每个非叶结点的平衡因子都写出来。

24. C

插入48以后，该二叉树根结点的平衡因子由-1变为-2，在最小不平衡子树根结点的右子树（R）的左子树（L）中插入新结点引起的不平衡属于RL型平衡旋转（先右旋后左旋）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d26c28a45ea913dc57d706cdb6706322e53cb3baa840d0722d33bf8295d32c95.jpg)


调整后，关键字37所在结点的左、右子结点中保存的关键字分别是24、53。

# 25. A

在二叉排序树中，左子树结点值小于根结点，右子树结点值大于根结点。在选项A中，当查找到91后再向24查找，说明这一条路径（左子树）之后查找的数都要比91小，而后面却查找到了94（解题过程中，建议配合画图），因此错误。

画图法：各选项对应的查找过如下图，选项B、C、D对应的查找树都是二叉排序树，选项A对应的查找树不是二叉排序树，因为在91为根的左子树中出现了比91大点的结点94。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8f2f0c4a8de90526d4bb3da3d324f6d3cebda4caa93bdb92926e167696ae54eb.jpg)



(a) 选项A的查找过程


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2731c68fa5f5d4e86fa78b3594704a32c91236082905912ee8d55f376602a1a5.jpg)



(b) 选项B的查找过程


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/17ffa2316dbe0a4ab97cc05a80fd29dd54cfc1146d20c2c06f2772aa57c97000.jpg)



(c) 选项C的查找过程


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3eb0260decf1716d4278a68224f971016897bf6dee9c3cb54141f938962cf789.jpg)



(d) 选项D的查找过程


# 26. B

所有非叶结点的平衡因子均为1，即平衡二叉树满足平衡的最少结点情况，如下图所示。对于高度为  $n$  、左右子树的高度分别为  $n - 1$  和  $n - 2$  、所有非叶结点的平衡因子均为1的平衡二叉树，计算总结点数的公式为  $C_{n} = C_{n - 1} + C_{n - 2} + 1, C_{1} = 1, C_{2} = 2, C_{3} = 2 + 1 + 1 = 4$  ，可推出  $C_6 = 20$  。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/80952e2a52af85b776e9156992060ee37099731b7ebd7486f5fbf11c8f1d5889.jpg)


画图法：先画出  $T_{1}$  和  $T_{2}$  ；然后新建一个根结点，连接  $T_{2}$  、  $T_{1}$  构成  $T_{3}$  ；新建一个根结点，连接  $T_{3}$  、  $T_{2}$  构成  $T_{4}$  ……直到画出  $T_{6}$  ，可知  $T_{6}$  的结点数为20。

排除法：对于选项A，高度为6、结点数为12的树怎么也无法达到平衡。对于选项C，结点较多时，考虑较极端的情形，即第6层只有最左叶子的完全二叉树刚好有32个结点，虽然满足平衡的条件，但显然再删去部分结点依然不影响平衡，不是最少结点的情况。同理，选项D错误。

# 27. C

由于在二叉排序树中插入结点的位置是一个新的叶结点，若删除的是叶结点，则重新插入后得到的二叉排序树与原来的二叉排序树相同。若删除的是非叶结点，在删除过程中会找其他结点

填补，重新插入后变成叶结点，则得到的二叉排序树与原来的二叉排序树不同。

# 28. D

利用7个关键字构建平衡二叉树  $T$  ，平衡因子为0的分支结点个数为3，构建的平衡二叉树及构造与调整过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dc9c3f0ad21a45ea5a2fd8b35fd49a8dd3ad139680190a18eea3fb4ebbb13959.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d543347f341b7387a2a43758406102a996a05812708d2c8270f9ac7c1b628837.jpg)


# 29. D

大多数教材将平衡二叉树定义为一种高度平衡的二叉排序树，二叉排序树的中序序列是一个升序序列，而题意正好相反。由此可知，命题老师认为平衡二叉树仅为一棵满足高度平衡的二叉树，不一定是二叉排序树。只有两个结点的平衡二叉树的根结点的度为1，选项A错误。中序遍历后得到一个降序序列（与二叉排序树正好相反），树中最大元素一定无左子树（可能有右子树），这与二叉排序树也正好相反，也因此不一定是叶结点，选项B错误，选项D正确。最后插入的结点可能会导致平衡调整，而不一定是叶结点，选项C错误。

# 30. C

根据二叉排序树的特性：中序遍历（LNR）得到的是一个递增序列。图中二叉排序树的中序遍历序列为  $x_{1}, x_{3}, x_{5}, x_{4}, x_{2}$ ，可知  $x_{3} < x_{5} < x_{4}$ 。

# 31. A

在非空平衡二叉树中插入结点，在失去平衡调整前，一定插入在叶结点的位置。

若删除的是  $T_{1}$  的叶结点，则删除后平衡二叉树可能不会失去平衡，即不会发生调整，再插入此结点得到的二叉平衡树  $T_{1}$  与  $T_{3}$  相同；若删除后平衡二叉树失去平衡而发生调整，再插入结点得到的二叉平衡树  $T_{3}$  与  $T_{1}$  可能不同。说法I正确。例如，如下图所示，删除结点0，平衡二叉树失衡调整，再插入结点0后，平衡二叉树和以前不同。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b2730ece766a2ecef5141b7ebe2132da7e69d5a4a02cdd10680550d5d7cf25f6.jpg)


对于比较绝对的说法 II 和 III，通常只需举出反例即可。

若删除的是  $T_{1}$  的非叶结点，且删除和插入操作均没有导致平衡二叉树的调整（这时可以首先想到删除的结点只有一个孩子的情况），则该结点从非叶结点变成了叶结点， $T_{1}$  与  $T_{3}$  显然不同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树和以前不同。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3fcf3a664353dbc92bd46848262018eb8049a84851d9e86bff8025f41ef00e45.jpg)


若删除的是  $T_{1}$  的非叶结点，且删除和插入操作后导致了平衡二叉树的调整，则该结点有可能通过旋转后继续变成非叶结点， $T_{1}$  与  $T_{3}$  相同。例如，如下图所示，删除结点2，用右孩子结点3填补，再插入结点2，平衡二叉树失衡调整，调整后的平衡二叉树和以前相同。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0e4ffda1fcaaaf696403bbc09424c7b86bd797169d0447506844949b3b34e127.jpg)


# 32. B

每个选项都逐一验证，选项B生成二叉排序树的过程如下图所示，显然错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/aa2fffe52539b54488bbe125c05aa925fcecc85b2d4933b6937f00a429dca5fd.jpg)


# 33. D

关键字23的插入位置为25的左孩子，此时破坏了平衡的性质，需要对平衡二叉树进行调整。最小不平衡子树就是该树本身，插入位置在根结点的右子树的左子树上，因此需要进行RL旋转，RL旋转过程如下图所示，旋转完成后根结点的关键字为25，所以选择选项D。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/31f87c4c0d4a66002860e61df5a8ca29e1d699dd7eeb70d9b2fe0b4048dbdb14.jpg)


# 34. D

在二叉搜索树中，每个结点的左子树中的所有关键字都小于该结点的关键字，右子树中的所有关键字都大于该结点的关键字。  $k_{2}$  、  $k_{3}$  所在结点都在  $k_{1}$  所在结点的右子树中，因此  $k_{2} > k_{1}$  、  $k_{3} > k_{1}$  ；  $k_{3}$  所在结点在  $k_{2}$  所在结点的左子树中，因此  $k_{3} < k_{2}$  ；子树  $T$  是  $k_{3}$  所在结点的右子树，因此子树  $T$  中任意结点的关键字  $x$  满足  $x > k_{3}$  。综合可得，  $k_{3} < x < k_{2}$  。

# 二、综合应用题

# 01.【解答】

先序序列为(50, 38, 30, 45, 40, 48, 70, 60, 75, 80)，二叉树的中序序列是一个有序序列，所以为(30, 38, 40, 45, 48, 50, 60, 70, 75, 80)，由先序序列和中序序列可以构造出对应的二叉树，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e2ccf258687f4152980bb215f51ef435b35c383af4f679e8ca71270da8f47ed8.jpg)


查找成功的平均查找长度为

$$
\mathrm {A S L} = (1 \times 1 + 2 \times 2 + 3 \times 4 + 4 \times 3) / 1 0 = 2. 9
$$

图中的方块结点为虚构的查找失败结点，其查找路径为从根结点到其父结点（圆形结点）的结点序列，所以对应的查找失败平均长度为

$$
\mathrm {A S L} = (3 \times 5 + 4 \times 6) / 1 1 = 3 9 / 1 1
$$

# 02.【解答】

根据二叉排序树的定义，该序列所对应的二叉排序树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2f01f1c0166ecb475b0d0d114b4423d7813b3a04a1e456b1b5fdb5ee7942bb89.jpg)


平均查找长度为  $\mathrm{ASL} = (1 + 2\times 2 + 3\times 3 + 4\times 2 + 5\times 2) / 10 = 3.2$

# 03.【解答】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/778520445fd22c429ae2962f9cd0aa00885a376ab841dd465e212ad8c9182664.jpg)


第一步：插入结点34,23,15后，需要根结点34的子树做LL调整。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5f80af0774d9a4679d5757813b1a49b9cd2ca49ce25b877ef3aa2646a781d3f4.jpg)


第二步：插入结点98,115后，需要根结点34的子树做RR调整。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/694df5e02d01853993336019c4d033e4e9cc0829a2dc659f7f1eacc387310adf.jpg)


第三步：插入结点28后，需要根结点23的子树做RL调整。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/99a9db4bbf7a3ff03bfbc46eff0abbcecca7a2cf83f90afae42041cfb8b4e690.jpg)


第四步：插入结点107后，需要根结点98的子树做RL调整。

# 04.【解答】

当各关键字的查找概率相等时，最佳二叉排序树应是高度最小的二叉排序树。构造过程分两步走：首先对各关键字按值从小到大排序，然后仿照折半查找的判定树的构造方法构造二叉排序树。这样得到的就是最佳二叉排序树，结果如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fbedc782d01b8ab547ce36251d651893a9104f556a5520febb0630929b4bd0c7.jpg)


# 05.【解答】

对二叉排序树来说，其中序遍历序列为一个递增有序序列。因此，对给定的二叉树进行中序遍历，若始终能保持前一个值比后一个值小，则说明该二叉树是一棵二叉排序树。算法实现如下：

```txt
KeyType predt=-32767; //predt为全局变量，保存当前结点中序前驱的值，初值为  $-\infty$   
int JudgeBST(BiTree bt){  
    int b1,b2;  
    if (bt==NULL) //空树  
        return 1;  
    else{  
        b1=JudgeBST(bt->lchild); //判断左子树是否是二叉排序树  
        if (b1==0 || predt>=bt->data) //若左子树返回值为0或前驱大于或等于当前结点  
            return 0; //则不是二叉排序树  
            predt=bt->data; //保存当前结点的关键字  
            b2=JudgeBST(bt->rchild); //判断右子树  
            return b2; //返回右子树的结果  
    }
```

# 06.【解答】

算法思想：设二叉树采用二叉链表存储结构。在二叉排序树中，查找一次就下降一层。因此，查找该结点所用的次数就是该结点在二叉排序树中的层次。采用二叉排序树非递归查找算法，用  $n$  保存查找层次，每查找一次，  $n$  就加1，直到找到相应的结点。算法如下：

```c
int level(BiTree bt,BSTNode \*p){ int  $n = 0$  //统计查找次数 BiTree t=bt; if(bt!=NULL）{ n++; while(t->data!=p->data）{ if(p->data<t->data) //在左子树中查找 t=t->lchild;
```

```txt
else //在右子树中查找  
t=t->rchild;  
n++; //层次加1  
}  
}  
return n;
```

# 07.【解答】

设置二叉树的平衡标记 balance，以标记返回二叉树 bt 是否为平衡二叉树，若为平衡二叉树，则返回 1，否则返回 0；h 为二叉树 bt 的高度。采用后序遍历的递归算法：

1）若bt为空，则高度为0，balance  $= 1$

2）若bt仅有根结点，则高度为1，balance  $= 1$

3）否则，对bt的左、右子树执行递归运算，返回左、右子树的高度和平衡标记，bt的高度为最高子树的高度加1。若左、右子树的高度差大于1，则balance  $= 0$  ；若左、右子树的高度差小于或等于1，且左、右子树都平衡时，balance  $= 1$  ，否则balance  $= 0$  。

算法如下：

```txt
void Judge_AVL(BiTree bt,int &balance,int  $\& h$  {intbl=0,br=0,hl=0,hr=0; //左、右子树的平衡标记和高度if(bt==NULL){ //空树，高度为0h=0;balance  $= 1$  ·}else if(bt->lchild  $= =$  NULL&&bt->rchild  $\equiv =$  NULL）{//仅有根结点，则高度为1h=1;balance  $= 1$  ·}else{Judge_AVL(bt->lchild,bl,hl); //递归判断左子树Judge_AVL(bt->rchild,br,hr); //递归判断右子树 $\mathrm{h} = (\mathrm{hl} > \mathrm{hr}? \mathrm{hl}: \mathrm{hr}) + 1;$  if(abs(h1-hr)<2）//若子树高度差的绝对值  $<  2$  ，则看左、右子树是否都平衡balance  $\equiv$  bl&&br; //&&为逻辑与，即左、右子树都平衡时，二叉树平衡elsebalance  $= 0$  ·}
```

# 08.【解答】

在一棵二叉排序树中，最左下结点即关键字最小的结点，最右下结点即关键字最大的结点，本算法只要找出这两个结点即可，而不需要比较关键字。算法如下：

```c
KeyType MinKey(BSTNode *bt) {
    while (bt->lchild != NULL)
        bt = bt->lchild;
    return bt->data;
} 
KeyType MaxKey(BSTNode *bt) {
    //求出二叉排序树中最大关键字结点
    while (bt->rchild != NULL)
        bt = bt->rchild;
    return bt->data;
}
```

# 09.【解答】

由二叉排序树的性质可知，右子树中所有的结点值均大于根结点值，左子树中所有的结点值

均小于根结点值。为了从大到小输出，先遍历右子树，再访问根结点，后遍历左子树。算法如下：

```c
voidOutPut(BSTNode \*bt,KeyType k)   
{//本算法从大到小输出二叉排序树中所有值不小于k的关键字 if(bt==NULL) return; if(bt->rchild!=NULL) OutPut(bt->rchild,k); //递归输出右子树结点 if(bt->data>=k) printf("%d",bt->data); //只输出大于或等于k的结点值 if(bt->lchild!=NULL) OutPut(bt->lchild,k); //递归输出左子树的结点
```

本题也可采用中序遍历加辅助栈的方法实现。

# 10.【解答】

设二叉排序树的根结点为\*t，根据结点存储的信息，有以下几种情况：

当  $t->1$  child 为空时，情况如下：

1）若  $t->rchild$  非空且  $k == 1$  ，则  $\star t$  即第  $k$  小的元素，查找成功。

2）若  $t->rchild$  非空且  $k!=1$ ，则第  $k$  小的元素必在  $^{\star}t$  的右子树。

当  $t->lchild$  非空时，情况如下：

1）t->lchild->count == k-1，*t即第k小的元素，查找成功

2)  $t->lchild->count>k-1$ ，第  $k$  小的元素必在  $*t$  的左子树，继续到  $*t$  的左子树中查找。

3)  $t->lchild->count < k - 1$ ，第  $k$  小的元素必在右子树，继续搜索右子树，寻找第  $k-(t->lchild->count + 1)$  小的元素。

对左右子树的搜索采用相同的规则，递归实现的算法描述如下：

```c
BSTNode \*Search_Small(BSTNode\*t,int k){ //在以  $t$  为根的子树上寻找第  $\mathrm{k}$  小的元素，返回其所在结点的指针。k从11开始计算 //在树结点中增加一个count数据成员，存储以该结点为根的子树的结点个数 if  $(\mathrm{k} <   1||\mathrm{k} > t - > count)$  return NULL; if(t->lchild  $\equiv =$  NULL){ if  $(\mathrm{k} == 1)$  return t; else return Search_Small(t->rchild,k-1); } else{ if(t->lchild->count  $\equiv =$  k-1) return t; if(t->lchild->count>k-1) return Search_Small(t->lchild,k); if(t->lchild->count<k-1) return Search_Small(t->rchild,k-(t->lchild->count+1)); }
```

最大查找长度取决于树的高度。由于二叉排序树是随机生成的，其高度应是  $O(\log_2n)$ ，算法的时间复杂度为  $O(\log_2n)$ 。

# 7.4 B树①和B+树

考研大纲对B树和  $\mathrm{B + }$  树的要求各不相同，重点在于考查B树，不仅要求理解B树的基本特点，还要求掌握B树的建立、插入和删除操作，而对  $\mathrm{B + }$  树则只考查基本概念。

# 7.4.1 B树及其基本操作

所谓  $m$  阶B树是所有结点的平衡因子均等于0的  $m$  路平衡查找树。

# 命题追踪 B树的定义和特点（2009）

一棵  $m$  阶B树或为空树，或为满足如下特性的  $m$  叉树：

1）树中每个结点至多有  $m$  棵子树，即至多有  $m - 1$  个关键字。

2）若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字。

3）除根结点外的所有非叶结点至少有  $\lceil m / 2\rceil$  棵子树，即至少有  $\lceil m / 2\rceil -1$  个关键字。

4）所有非叶结点的结构如下：

<table><tr><td>n</td><td>P0</td><td>K1</td><td>P1</td><td>K2</td><td>P2</td><td>...</td><td>Kn</td><td>Pn</td></tr></table>

其中，  $K_{i}$  （  $i = 1,2,\dots ,n$  ）为结点的关键字，且满足  $K_{1} < K_{2} < \dots < K_{n};P_{i}$  （  $i = 0,1,\dots ,n$  ）为指向子树根结点的指针，且指针  $P_{i - 1}$  所指子树中所有结点的关键字均小于  $K_{i},P_{i}$  所指子树中所有结点的关键字均大于  $K_{i};n$  （  $\lceil m / 2\rceil -1\leqslant n\leqslant m - 1$  ）为结点中关键字的个数。

5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的失败结点，实际上这些结点并不存在，指向这些结点的指针为空）。

# 命题追踪 B树中关键字数和结点数的分析（2013、2014、2018、2021）

图7.28所示为一棵5阶B树，可以借助该实例来分析上述性质：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e80055c77d6a601bda8f2dcec3e87dfb4739b2a5a39581dec56d5e674e013c50.jpg)



图7.28 一棵5阶B树的实例


1）结点的孩子个数等于该结点中关键字个数加1。

2）若根结点没有关键字就没有子树，则此时B树为空；若根结点有关键字，则其子树个数必然大于或等于2，因为子树个数等于关键字个数加1。

3）除根结点外的所有非叶结点至少有  $\lceil m / 2\rceil = \lceil 5 / 2\rceil = 3$  棵子树（至少有  $\lceil m / 2\rceil -1 = \lceil 5 / 2\rceil -1 = 2$  个关键字)；至多有5棵子树（至多有4个关键字）。

4）结点中的关键字从左到右递增有序，关键字两侧均有指向子树的指针，左侧指针所指子树的所有关键字均小于该关键字，右侧指针所指子树的所有关键字均大于该关键字。或者看成下层结点的关键字总是落在由上层结点的关键字所划分的区间内，如第二层最左结点的关键字划分成了3个区间：  $(- \infty, 5)$ ，(5,11)， $(11, + \infty)$ ，该结点中的3个指针所指子树的关键字均分别落在这3个区间内。

5）所有叶结点均在第4层，代表查找失败的位置。

# 1. B 树的查找

在B树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，在每个结

点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。

B 树的查找包含两个基本操作：① 在 B 树中找结点；② 在结点内找关键字。B 树常存储在磁盘上，因此前一查找操作是在磁盘上进行的，而后一查找操作是在内存中进行的，即在磁盘上找到目标结点后，先将结点信息读入内存，然后再采用顺序查找法或折半查找法。因此，在磁盘上进行查找的次数即目标结点在 B 树上的层数次，决定了 B 树的查找效率。

在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找（例如，在图7.28中查找关键字42，首先从根结点开始，根结点只有一个关键字，且  $42 > 22$  ，若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而  $36 < 42 < 45$  ，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查找成功)。查找到叶结点时（对应指针为空)，则说明树中没有对应的关键字，查找失败。

# 2. B 树的高度（磁盘存取次数）

由上一节得知，B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。

下面来分析B树在不同情况下的高度。当然，首先应该明确B树的高度不包括最后的不带任何信息的叶结点所处的那一层（有些书对B树的高度的定义中，包含最后的那一层）。

若  $n \geqslant 1$  ，则对任意一棵包含  $n$  个关键字、高度为  $h$  、阶数为  $m$  的B树：

1）若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。因为B树中每个结点最多有  $m$  棵子树， $m - 1$  个关键字，所以在一棵高度为  $h$  的  $m$  阶B树中关键字的个数应满足  $n \leqslant (m - 1)(1 + m + m^2 + \dots + m^{h - 1}) = m^h - 1$ ，因此有

$$
h \geqslant \log_ {m} (n + 1)
$$

2）若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。第一层至少有1个结点；第二层至少有2个结点；除根结点外的每个非叶结点至少有  $\lceil m / 2\rceil$  棵子树，则第三层至少有  $2\lceil m / 2\rceil$  个结点……第  $h + 1$  层至少有  $2(\lceil m / 2\rceil)^{h - 1}$  个结点，注意到第  $h + 1$  层是不包含任何信息的叶结点。对于关键字个数为  $n$  的B树，叶结点即查找不成功的结点为  $n + 1$  ，由此有  $n + 1\geqslant 2(\lceil m / 2\rceil)^{h - 1}$  ，即  $h\leqslant \log_{\lceil m / 2\rceil}((n + 1) / 2) + 1$  。

例如，假设一棵3阶B树共有8个关键字，则其高度范围为  $2 \leqslant h \leqslant 3.17$  ，取整数。

# 3. B 树的插入

# 命题追踪 通过插入操作构造一棵初始为空的B树（2020）

与二叉排序树的插入操作相比，B 树的插入操作要复杂得多。在 B 树中查找到插入的位置后，并不能简单地将其添加到终端结点（最底层的非叶结点）中，因为此时可能会导致整棵树不再满足 B 树定义中的要求。将关键字 key 插入 B 树的过程如下：

1）定位。利用前述的B树查找算法，找出插入该关键字的终端结点（在B树中查找key时，会找到表示查找失败的叶结点，因此插入位置一定是最底层的非叶结点）。

2）插入。每个非根结点的关键字个数都在  $\lceil m / 2\rceil -1,m - 1\rceil$  。若结点插入后的关键字个数小于  $m$  ，可以直接插入；若结点插入后的关键字个数大于  $m - 1$  ，必须对结点进行分裂。

分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置（ $\lceil m / 2 \rceil$ ）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（ $\lceil m / 2 \rceil$ ）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。

对于  $m = 3$  的B树，所有结点中最多有  $m - 1 = 2$  个关键字，若某结点中已有两个关键字，则结点已满，如图7.29(a)所示。插入一个关键字60后，结点内的关键字个数超过了  $m - 1$  ，如图7.29(b)所示，此时必须进行结点分裂，分裂的结果如图7.29(c)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/8af72cb6836947133638d66bb31f35720f80c27f6cd64bfcbb0ab6ad1ccf49b3.jpg)



图7.29 结点的“分裂”示意


# 4. B 树的删除

B 树的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数  $\geqslant \lceil m / 2\rceil -1$  ，因此将涉及结点的“合并”问题。

# 命题追踪 B树的删除操作的实例（2012、2022）

当被删关键字  $k$  不在终端结点中时，可以用  $k$  的前驱（或后继） $k'$ ，即  $k$  的左侧子树中“最右下”的元素（或右侧子树中“最左下”的元素），来替代  $k$ ，然后在相应的结点中删除  $k'$ ，关键字  $k'$  必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30的4阶B树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/77ec42566c1babf8cd6d54cf1f708e8dd859e9705c715aa6cfe72f1be44566bd.jpg)



图7.30 B树中删除非终端结点关键字的取代


因此只需讨论被删关键字在终端结点中的情形，有下列三种情况：

1）直接删除关键字。若被删关键字所在结点删除前的关键字个数  $\geqslant \lceil m / 2\rceil$  ，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。

2）兄弟够借。若被删关键字所在结点删除前的关键字个数  $= \lceil m / 2\rceil -1$  ，且与该结点相邻的右（或左）兄弟结点的关键字个数  $\geqslant \lceil m / 2\rceil$  ，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。在图7.31(a)中删除4阶B树的关键字65，右兄弟关键字个数  $\geqslant \lceil m / 2\rceil = 2$  ，将71取代原65的位置，将74调整到71的位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a018a67fc60d9d99ac879deeb0d5a5777e55a7b34c3b872fb039f876f7c1ccc9.jpg)



(a)兄弟够借


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6e81819692571c2147b421f4998b606f17247127037cd6c747339f2f7356e0a7.jpg)



(b)兄弟不够借



图7.314阶B树中删除终端结点关键字的示意图


3）兄弟不够借。若被删关键字所在结点删除前的关键字个数  $= \lceil m / 2\rceil -1$  ，且此时与该结点相邻的左、右兄弟结点的关键字个数都  $= \lceil m / 2\rceil -1$  ，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在图7.31(b)中删除4阶B树的关键字5，它及其右兄弟结点的关键字个数  $= \lceil m / 2\rceil -1 = 1$  ，所以在5删除后将60合并到65结点中。

# 命题追踪 非空B树的查找、插入、删除操作的特点（2023）

在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树)，则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到  $\lceil m / 2\rceil -2$  ，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。

# 7.4.2 B+树的基本概念

# 命题追踪 B+树的应用场合（2017）

B+树是应数据库所需而出现的一种B树的变形树。

一棵  $m$  阶  $\mathrm{B}+$  树应满足下列条件：

1）每个分支结点最多有  $m$  棵子树（孩子结点）。

2）非叶根结点至少有两棵子树，其他每个分支结点至少有  $\lceil m / 2\rceil$  棵子树。

3）结点的子树个数与关键字个数相等。

4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）。

5）所有分支结点（可视为索引的索引）中仅包含它的各个子结点（下一级的索引块）中关键字的最大值及指向其子结点的指针。

# 命题追踪 B树和B+树的差异的分析（2016）

$m$  阶B+树与  $m$  阶B树的主要差异如下：

1）在B+树中，具有  $n$  个关键字的结点只含有  $n$  棵子树，即每个关键字对应一棵子树；而在B树中，具有  $n$  个关键字的结点含有  $n + 1$  棵子树。

2）在B+树中，每个结点（非根内部结点）的关键字个数  $n$  的范围是  $\lceil m / 2\rceil \leqslant n\leqslant m$  （非叶根结点：  $2\leqslant n\leqslant m)$  ；而在B树中，每个结点(非根内部结点)的关键字个数  $n$  的范围是  $\lceil m / 2\rceil -1$ $\leqslant n\leqslant m - 1$  （根结点：  $1\leqslant n\leqslant m - 1)$  。

3）在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。

4）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快。

5）在B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表。

图7.32所示为一棵4阶B+树。可以看出，分支结点的关键字是其子树中最大关键字的副本。通常在B+树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对B+树进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/779e6b49b9e1f06171402cb1ce86f089e3bf303d4f7fbac021a25dea9541c834.jpg)



图7.32 B+树结构示意图


B+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。因此，在B+树中查找成功或失败（ $\leq$ 最大关键字）时，每次查找都是一条从根结点到叶结点的路径。

# 7.4.3 本节试题精选

# 一、单项选择题

01. 下图所示是一棵（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4a9e18e94ae15ddc61dae5d6602bda8fa6bf7c43157dfb3d4e50e91eb3184fe2.jpg)


A. 4 阶 B 树

B. 3 阶 B 树

C. 4 阶  $\mathrm{B}+$  树

D. 无法确定

02. 下列关于  $m$  阶B树的说法中，错误的是（）。

A. 根结点至多有  $m$  棵子树

B. 所有叶结点都在同一层次上

C. 非叶结点至少有  $m / 2$  （ $m$  为偶数）或  $(m + 1) / 2$  （ $m$  为奇数）棵子树

D. 根结点中的数据是有序的

03. 下列关于高度为 3 的 3 阶 B 树的说法中,正确的是 (   )。

I. 每个结点至少有两棵非空子树

II. 树中每个结点至多有 2 个关键字

III. 树中最多能存储 26 个关键字

IV. 插入一个元素引起 B 树结点分裂后，树的高度变为 4

A. I、II

B. II、III

C. III、IV

D. I、II、IV

04. 在一棵  $m$  阶 B 树中做插入操作前，若一个结点中的关键字个数等于（），则插入操作后必须分裂成两个结点；在一棵  $m$  阶 B 树中做删除操作前，若一个结点中的关键字个数等于（），则删除操作后可能需要同它的左兄弟或右兄弟结点合并成一个结点。

A.  $m, \lceil m / 2 \rceil - 2$

B.  $m - 1, \lceil m / 2 \rceil - 1$

C.  $m + 1, \lceil m / 2 \rceil$

D.  $m / 2, \lceil m / 2 \rceil + 1$

05. 具有  $n$  个关键字的  $m$  阶 B 树，应有（）个叶结点。

A.  $n + 1$

B.  $n - 1$

C.  ${mn}$

D. nm/2

06. 高度为5的3阶B树至少有（）个结点，至多有（）个结点。

A. 32

B. 31

C. 120

D. 121

07. 含有  $n$  个非叶结点的  $m$  阶 B 树中至少包含 ( ) 个关键字。

A.  $n(m + 1)$

B.  $n$

C.  $n(\lceil m / 2\rceil -1)$

D.  $(n - 1)(\lceil m / 2\rceil -1) + 1$

08. 已知一棵 5 阶 B 树中共有 53 个关键字，则树的最大高度为（），最小高度为（）。

A. 2

B. 3

C. 4

D. 5

09. 已知一棵3阶B树中共有2047个关键字，则树的最大高度为（），最小高度为（）。

A. 11

B. 10

C. 8

D. 7

10. 在7阶B树中搜索第2016个关键字，若根结点已读入内存，则最多需启动（）次I/O。

A. 4

B. 5

C. 6

D. 7

11. 在一棵高度为  $h$  的B树中插入一个新关键字，假设在插入过程中读入的结点一直在内存中，根结点的高度为1，且初始时未读入内存，则下列叙述中错误的是（）。（注意，本

题中的新结点是指新产生的结点，如一次分裂才产生一个新结点。)

A. 若插入操作导致树的高度变为  $h + 1$  ，则本次插入一定导致了根结点的分裂

B. 若插入操作导致旧结点的分裂, 则树的高度一定会变为  $h + 1$

C. 由于本次插入操作而产生的新结点的个数最多为  $h + 1$

D. 由于本次插入操作而产生的读/写磁盘的次数最多为  $3h + 1$

12. 下列关于B树和  $\mathrm{B + }$  树的叙述中，错误的是（）。

A. B 树和  $\mathrm{B}+$  树都能有效地支持顺序查找

B. B 树和  $\mathrm{B}+$  树都能有效地支持随机查找

C. B 树和  $\mathrm{B}+$  树都是平衡的多叉树

D. B 树和  $\mathrm{B}+$  树都可以用于文件索引结构

13. 下列关于B树和  $\mathrm{B + }$  树的查找操作的叙述中，错误的是（）。

A. B 树查找成功时，不一定需要查找到最后一层的内部结点

B. B 树查找失败时，一定需要查找到叶结点

C. B+树查找成功时，不一定需要查找到叶结点

D. B+树查找成功时，每次查找的长度都相等

14.【2009统考真题】下列叙述中，不符合  $m$  阶B树定义要求的是（）。

A. 根结点至多有  $m$  棵子树

B. 所有叶结点都在同一层上

C. 各结点内关键字均升序或降序排列

D. 叶结点之间通过指针链接

15.【2012统考真题】已知一棵3阶B树，如下图所示。删除关键字78得到一棵新B树，其最右叶结点中的关键字是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6dd08930d07a82a86188eb4c39d2bbcc1425912f820c1bc73c5d87044648cc3a.jpg)


A. 60

B. 60, 62

C. 62, 65

D. 65

16.【2013统考真题】在一棵高度为2的5阶B树中，所含关键字的个数至少是（）。

A. 5

B. 7

C. 8

D. 14

17.【2014统考真题】在一棵有15个关键字的4阶B树中，含关键字的结点个数最多是（）。

A. 5

B. 6

C. 10

D. 15

18.【2016统考真题】B+树不同于B树的特点之一是（）。

A. 能支持顺序查找

B. 结点中含有关键字

C. 根结点至少有两个分支

D. 所有叶结点都在同一层上

19.【2017统考真题】下列应用中，适合使用B+树的是（）。

A. 编译器中的词法分析

B. 关系数据库系统中的索引

C. 网络中的路由表快速查找

D. 操作系统的磁盘空闲块管理

20.【2018统考真题】高度为5的3阶B树含有的关键字个数至少是（）。

A. 15

B. 31

C. 62

D. 242

21.【2020统考真题】依次将关键字5，6，9，13，8，2，12，15插入初始为空的4阶B树后，根结点中包含的关键字是（）。

A. 8

B. 6, 9

C. 8, 13

D. 9, 12

22.【2021统考真题】在一棵高度为3的3阶B树中，根为第1层，若第2层中有4个关键

字，则该树的结点数最多是（）。

A. 11

B. 10

C. 9

D. 8

23.【2022统考真题】在下图所示的5阶B树  $T$  中，删除关键字260之后需要进行必要的调整，得到新的B树  $T_{1}$  。下列选项中，不可能是  $T_{1}$  根结点中关键字序列的是（）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6c69bc386c7c4188ce83282e7c586846ae9d33eb038f42031159e936af15b1c5.jpg)


A. 60, 90, 280

B. 60, 90, 350

C. 60, 85, 110, 350

D. 60, 90, 110, 350

24.【2023统考真题】下列关于非空B树的叙述中，正确的是（）。

I. 插入操作可能增加树的高度

II. 删除操作一定会导致叶结点的变化

III. 查找某关键字总是要查找到叶结点

IV. 插入的新关键字最终位于叶结点中

A. 仅 I

B. 仅 I、II

C. 仅 III、IV

D. 仅 I、II、IV

# 二、综合应用题

01. 给定一组关键字  $\{20, 30, 50, 52, 60, 68, 70\}$ ，给出创建一棵3阶B树的过程。

02. 对如下图所示的3阶B树，依次执行下列操作，画出各步操作的结果。

1）插入90

2）插入25

3）插入45

4）删除60

5）删除80

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a245a06f4aadcf036f79e8be4232348c11b890ca3bb70dbd395e0c37b331f7ad.jpg)


03. 利用B树做文件索引时，若假设磁盘页块的大小是4000B（实际应是2的次幂，此处是为了计算方便），指示磁盘地址的指针需要5B。现有20000000个记录构成的文件，每个记录为200B，其中包括关键字5B。

试问在这个采用B树作索引的文件中，B树的阶数应为多少？假定文件数据部分未按关键字有序排列，则索引部分需要占用多少磁盘页块？

# 7.4.4 答案与解析

# 一、单项选择题

01. D

关键字数目比子树数目少1，首先可排除  $\mathrm{B + }$  树。对于4阶B树，根结点至少有2棵子树（关键字数至少为1)，其他非叶结点至少有  $\lceil n / 2\rceil = 2$  棵子树（关键字数至少为1）、至多有4棵子树（关键字数至多为3）。5阶B树和6阶B树的分析也类似。题目所示的B树，同时满足4阶B树、5阶B树和6阶B树的要求，因此不能确定是哪种类型的B树。

02.C

除根结点外的所有非叶结点至少有  $\lceil m / 2\rceil$  棵子树。对于根结点，最多有  $m$  棵子树，若其不是叶结点，则至少有2棵子树。

03.B

每个非根的内部结点必须至少有  $\lceil m / 2\rceil$  棵子树，而本题中的根结点不是叶结点，也至少要有

两棵子树，选项I正确。每个结点至多有  $m - 1 = 2$  个关键字，选项II正确。在高度为  $h$  的  $m$  阶B树中，关键字个数至多为  $(m - 1)(1 + m + m^2 +\dots +m^{h - 1}) = m^h -1$  ，代入  $m = 3$  ，  $h = 3$  ，即树中最多能存储26个关键字，选项III正确。对于选项IV，插入一个元素引起B树结点分裂后，只要从根结点到该元素插入位置的路径上至少有一个结点未满，B树就不会长高，如图1所示；只有当结点的分裂传到根结点，并使根结点也分裂时，才会导致树高增1，如图2所示，选项IV错误。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0a5cd3355a03123d786ef0933652c5fedb722a3cb595409f4eb33f1a82255a26.jpg)



图1结点分裂不导致树高增1（3阶B树）


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5d264cae3b4382f901a0d7ed787144f53352dd1fa4358960fd6475b949e4698b.jpg)



图2结点分裂导致树高增1（3阶B树）


# 04. B

因为B树每个结点内的关键字个数最多为  $m - 1$  ，所以当关键字个数大于  $m - 1$  时，则应该分裂。每个结点内的关键字个数至少为  $\lceil m / 2\rceil -1$  个，所以当关键字个数少于  $\lceil m / 2\rceil -1$  时，则可能与其他结点合并（除非只有根结点）。若将本题题干改为B+树，请读者思考上述问题的解答。

# 05. A

B 树的叶结点对应查找失败的情况，对有  $n$  个关键字的查找集合进行查找，失败可能性有  $n + 1$  种。

# 06. B、D

由  $m$  阶B树的性质可知，根结点至少有2棵子树；根结点外的所有非终端结点至少有  $\lceil m / 2\rceil$  棵子树，结点数最少时，3阶B树形状至少类似于一棵满二叉树，即高度为5的B树至少有  $2^{5} - 1 = 31$  个结点。因为每个结点最多有  $m$  棵子树，所以当结点数最多时，3阶B树形状类似于满三叉树，结点数为  $(3^{5} - 1) / 2 = 121$  （注意，这里求的是结点数而非关键字数，若求的是关键字数，则还应把每个结点中关键字数的上下界确定出来）。

# 07. D

除根结点外， $m$  阶B树中的每个非叶结点至少有  $\lceil m / 2\rceil -1$  个关键字，根结点至少有一个关键字，所以总共包含的关键字最少个数  $= (n - 1)(\lceil m / 2\rceil -1) + 1$ 。

# 注意

由以上题目可知B树和  $\mathrm{B + }$  树的定义与性质尤为重要，需要熟练掌握。

# 08. C、B

5阶B树中共有53个关键字，由最大高度公式  $H\leqslant \log_{\lceil m / 2\rceil}((n + 1) / 2) + 1$  得最大高度  $H\leqslant \log_3[(53 + 1) / 2] + 1 = 4$  ，即最大高度为4；由最小高度公式  $h\geqslant \log_m(n + 1)$  得最小高度  $h\geqslant \log_554\approx 2.5$  从而最小高度为3。

# 09. A、D

利用前面的公式即最小高度  $h \geqslant \log_{m}(n + 1)$  和最大高度  $H \leqslant \log_{\lceil m / 2\rceil}[(n + 1) / 2] + 1$  ，易算出最大高度  $H \leqslant \log_2[(2047 + 1) / 2] + 1 = 11$  ，最小高度  $h \geqslant \log_32048 = 6.9$  ，从而最小高度取7（注意，有些

辅导书针对本题算出的高度要比这里给出的答案多1，因为它们在对B树的高度定义中，把最底层不包含任何关键字的叶结点也算进去了）。

# 10. B

本题要计算的是最坏情况下第2016个关键字在7阶B树中的最大深度，即考查B树结点中关键字数最少的情况。按照B树的定义，根结点至少有1个关键字，第二层至少有2个结点，即 $2\times 3$  个关键字；第三层至少有  $2\times 4$  个结点，即  $2\times 4\times 3$  个关键字；第四层至少有  $2\times 4^{2}$  个结点，即  $2\times 4^{2}\times 3$  个关键字；以此类推，第  $h$  层至少有  $2\times 4^{h - 2}$  个结点，即  $2\times 4^{h - 2}\times 3$  个关键字，故前  $h$  层的关键字总数  $n = 1 + 2\times 3\times (1 + 4 + \dots +4^{h - 2}) = 1 + 2\times (4^{h - 1} - 1)$  。故当  $h = 5$  时，  $n = 511$  ；当  $h = 6$  时，  $n = 2047$  ，说明5层高的7阶B树最少有511个关键字，而6层高的7阶B树最少有2047个关键字，故最坏情况下第2016个关键字在7阶B树的第6层，需启动5次I/O操作。

# 11. B

考虑最坏情况，在待插入结点中插入一个关键码后，导致结点分裂，在该层分裂成2个结点，因此需要2次写磁盘操作；分裂操作逐层向上传导，导致每层都有结点分裂，因为结点分裂而导致的写磁盘操作共有  $2h$  次，加上最后一次结点分裂形成新根结点也需要1次写磁盘操作，写磁盘的总次数为  $2h + 1$  ，即由于本次插入而产生的新结点个数为  $h + 1$  ，加上寻找插入位置而引起的 $h$  次的读磁盘操作，整个过程中读/写磁盘的总次数为  $3h + 1$  次，选项C、D正确。若插入操作导致了B树的高度增加，则分裂操作一定是从最底层传导至根结点的，即前面分析的最坏情况，选项A正确。若分裂操作没有传导至根结点，则B树的高度不变，选项B错误。

# 12. A

B树和  $\mathrm{B + }$  树的差异主要体现在：  $①$  结点关键字和子树的个数；  $②\mathrm{B}+$  树非叶结点仅起索引作用；  $③\mathrm{B}$  树叶结点关键字和其他结点包含的关键字是不重复的；  $④\mathrm{B + }$  树支持顺序查找和随机查找，而B树仅支持随机查找。  $\mathrm{B + }$  树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找。B树和  $\mathrm{B + }$  树都可用于文件索引结构，但  $\mathrm{B + }$  树更适合做数据库索引和文件索引，因为它的磁盘读/写代价更低。

# 13. C

在B树的查找操作中，若目标元素在某个内部结点中，则查找结束，不需要进入叶结点；查找失败时，叶结点是所有路径的终点，选项A、B正确。B+树中仅叶结点包含信息，非叶结点仅起到索引作用，查找成功时一定会找到相应的叶结点，所经过的路径长度都相等，选项C错误，选项D正确。

# 14. D

$m$  阶B树不要求将各叶结点之间用指针链接。选项D描述的实际上是  $\mathrm{B}+$  树。

# 15. D

对于图中所示的3阶B树，被删关键字78所在的结点在删除前的关键字个数  $= 1 = \lceil 3 / 2\rceil -1$  且其左兄弟结点的关键字个数  $= 2\geqslant \lceil 3 / 2\rceil$  ，属于“兄弟够借”的情况，因此要把该结点的左兄弟结点中的最大关键字上移到双亲结点中，同时把双亲结点中大于上移关键字的关键字下移到要删除关键字的结点中，这样就达到了新的平衡，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a042e70a747700d729011ed08ef75e5449d46107dd96b16f01abedf733a13d33.jpg)


# 16. A

对于5阶B树，根结点的分支数最少为2（关键字数最少为1)，其他非叶结点的分支数最少为  $\lceil n / 2\rceil = 3$  （关键字数最少为2)，因此关键字个数最少的情况如下图所示（叶结点不计入高度）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b175879cb0ecd3889545eacf339cf67624eb6fda1e1fe9b850f3d92058148dd9.jpg)


# 注意

一般对于某个具体的B树图形，并不能确定是几阶B树。对于本题所述的5阶B树，不要误认为：“存在至少有一个含关键字结点中的关键字达到4”才符合5阶B树的要求，因为5阶B树中各个结点包含的关键字个数最少为2（ $\lceil 5 / 2 \rceil - 1 = 2$ ），最多为  $4(5 - 1 = 4)$  。当5阶B树中各个结点包含的关键字个数为2时，也满足5阶B树的要求。

# 17. D

关键字数量不变，要求结点数量最多，即要求每个结点中含关键字的数量最少。根据4阶B树的定义，根结点最少含1个关键字，非根结点中最少含  $\lceil 4 / 2\rceil -1 = 1$  个关键字，所以每个结点中关键字数量最少都为1个，即每个结点都有2个分支，类似于排序二叉树，而15个结点正好可以构造一个4层的4阶B树，使得终端结点全在第四层，符合B树的定义。

# 18. A

B+树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，因此可以进行顺序查找，而B树不支持顺序查找（只支持多路查找）。

# 19. B

B+树是应文件系统所需而产生的B树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者的磁盘读/写代价更低，查询效率更加稳定。编译器中的词法分析使用有穷自动机和语法树。网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。系统一般使用空闲空间链表管理磁盘空闲块。

# 20. B

$m$  阶B树的基本性质：根结点以外的非叶结点最少含有  $\lceil m / 2\rceil -1$  个关键字，代入  $m = 3$  得到每个非叶结点中最少包含1个关键字，而根结点含有1个关键字，因此所有非叶结点都有两个孩子。此时其树形与  $h = 5$  的满二叉树相同，可求得关键字最少为31个。

# 21. B

一个4阶B树的任意非叶结点至多含有  $m - 1 = 3$  个关键字，在关键字依次插入的过程中，会导致结点的不断分裂，插入过程如下图所示。得到根结点包含的关键字为6,9。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/62882677298c267739ef6ea5a4765c477cc7cb672ebb358c684ca38be271b390.jpg)


# 22. A

在阶为3的B树中，每个结点至多含有2个关键字（至少1个），至多有3棵子树。本题规定第二层有4个关键字，欲使B树的结点数达到最多，则这4个关键字包含在3个结点中，B树树形如下图所示，其中A, B, C, …, M表示关键字，最多有11个结点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9509c617f0e370feb48af4377d6048bc382ec3ce66a423b31f0720307346934f.jpg)


# 23. D

在5阶B树中，除根结点外的非叶结点的关键字数  $k$  需要满足  $2 \leqslant k \leqslant 4$  。当被删关键字  $\mathbf{x}$  不在终端结点（最底层非叶结点）时，可以用  $\mathbf{x}$  的前驱（或后继）关键字y来替代  $\mathbf{x}$ ，然后在相应结点中删除y。情况①：删除260，将其前驱110放入260处，删除110后的结点  $< 100>$  不满足5阶B树定义，从左兄弟中借85，将85放入根中，将根中的90移入结点  $< 100>$  变为  $< 90, 100>$  。情况②：删除260，将其后继280放入260处，结点  $< 300>$  不满足5阶B树定义且左右兄弟都不够借，结点  $< 300>$  可以和左兄弟  $< 100, 110>$  以及关键字280合并成一个新的结点  $< 100, 110, 280, 300>$  。情况③：在情况②中，结点  $< 300>$  也可以和右兄弟  $< 400, 500>$  以及关键字350合并成一个新的结点  $< 300, 350, 400, 500>$  。综上， $T_{1}$  根结点中的关键字序列可能是  $< 60, 85, 110, 350>$  或  $< 60, 90, 350>$  或  $< 60, 90, 280>$ ，仅选项D不可能。

快速解法：假如选项D的60,90,110,350作为根结点，则在90和110之间只有100这一个数据，显然不符合5阶B树的定义，因此选项D不可能。

# 24. B

B 树的插入操作可能导致叶结点分裂，叶结点分裂可能导致父结点分裂，甚至会传导到根结点，从而导致 B 树高度增 1，选项 I 正确。若被删结点是叶结点，则显然会导致叶结点变化；若被删结点不是叶结点，则要先将被删结点和它的前驱或后继交换，最终转换为删除叶结点，还是导致叶结点变化，选项 II 正确。若在非叶结点中查找到了给定的关键字，则不用向下继续查找，选项 III 错误。插入关键字的初始位置是最底层叶结点，但可能因结点分裂而被转移到父结点中，选项 IV 错误。

# 注意

由本题可知，与大多数教材不同，统考真题中称最底层终端结点为叶结点。

# 二、综合应用题

# 01.【解答】

$m = 3$  ，因此除根结点外，非叶结点关键字个数为  $1\sim 2$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c7b3d048a4aa3dfb6316e31b7ea7ed4b48cd382e7289e4119e57a243f78745a3.jpg)


如上图所示，首先插入20,30，结点内关键字个数不超过  $m - 1 = 2$  ，不会引起分裂；插入50，插入20,30所在的结点，引起分裂，结点内第「  $m / 2$  个关键字30上升为父结点。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0521ca9fa1028ffc4023bf1c7f02860cd3b595b8a38386e81c7fc20bd7fc1f1b.jpg)


如上图所示，插入52，插入50所在的结点，不会引起分裂；继续插入60，插入50,52所在的结点，引起分裂，52上升到父结点中，不会引起父结点的分裂。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2b73c404212b9db09d8d32207e110e2eb869e538782913425e8b78fbf0ba8e82.jpg)


如上图所示，插入68，插入60所在的结点，不会引起分裂；继续插入70，插入60,68所在的结点，引起分裂，68上升为新的父结点，68上升到30,52所在的结点后，会继续引起该结点的分裂，所以52上升为新的根结点。最后得到的B树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/36efaab6142876231efcbac6cf94a3e3201b0fccf1a0966a251c0ec2abcb25a6.jpg)


# 02.【解答】

1）插入90：将90插入100所在的结点，插入90后该结点中的元素个数不超过  $\lceil 3 / 2\rceil = 2$  不会引起结点的分裂，插入后的B树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/92225f7d2d9d7bf3ef871d7cbd71969ad6d70ec886d8431f9df650f53344febe.jpg)


2）插入25：将25插入8,20所在的结点，插入后结点内的元素个数为3，引起分裂。所以将结点内的中间元素20上升到父结点中，此时父结点中的元素个数为2（元素20和30），不会引起继续分裂，插入25后的B树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ebbae5ef271c5436f4b9cce07c89acb11527b948b1be556f4083f5885ae09670.jpg)


3）插入45：将45插入35，40所在的结点，引起分裂，中间元素40上升到父结点（20，30所在的结点）中，引起父结点分裂，中间元素30上升到父结点（50所在的结点）中，两次分裂后的B树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/00e51578eafb14234a47aa43c7ddf68b7ecd7a1e1b653578e789295b836a171e.jpg)


4）删除60：删除60后，其所在的结点元素为空，从而导致借用右兄弟结点的元素，调整后的B树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d5796fed23e743f080780585c97f30529fa3158bcb21109dfcfe84d2b6360091.jpg)


5）删除80：删除80后，导致80所在结点的父结点与其右兄弟结点合并，这时父结点元素个数为0，再次对父结点进行调整。将50与40合并成一个新结点，则90,100所在结点为这个结点的子结点。从而构造的B树如下图所示。注意，这次调整的过程实际上包含多次调整过程，希望读者对照考点讲解中的删除过程仔细思考。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/17a17bfe3d88b9abf58b5c017d5f45b98b4d018743f62a8f980143bad5dc0e98.jpg)


# 注意 公众号：小兔网盘 免费分享无水印PDF

B 树中结点的插入、删除操作（特别是插入、删除后的结点分裂与合并）是本节的重点，也是难点，请读者务必熟练掌握。

# 03.【解答】

根据B树的概念，一个索引结点应适应操作系统一次读/写的物理记录大小，其大小应取不超过但最接近一个磁盘页块的大小。假设B树为  $m$  阶，一个B树结点最多存放  $m - 1$  个关键字（5B）和对应的记录地址（5B）、 $m$  个子树指针（5B）和1个指示结点中的实际关键字个数的整数（2B），则有

$$
(2 \times (m - 1) + m) \times 5 + 2 \leqslant 4 0 0 0
$$

计算结果为  $m \leqslant 267$

一个索引结点最多可以存放  $m - 1 = 266$  个索引项，最少可以存放  $\lceil m / 2\rceil -1 = 133$  个索引项。全部有  $n = 20000000$  个记录，每个记录占用空间200B，每个页块可以存放  $4000 / 200 = 20$  个记录，则全部记录分布在  $20000000 / 20 = 1000000$  个页块中，最多需要占用  $1000000 / 133 = 7519$  个磁盘页块作为B树索引，最少需要占用  $1000000 / 266 = 3760$  个磁盘页块作为B树索引（注意B树与  $\mathrm{B + }$  树的不同，B树所有对数据记录的索引项分布在各个层次的结点中，  $\mathrm{B + }$  树所有对数据记录的索引项都在叶结点中）。

# 7.5 散列（Hash）表

# 7.5.1 散列表的基本概念

在前面介绍的线性表和树表的查找中，查找记录需进行一系列的关键字比较，记录在表中的位置与记录的关键字之间不存在映射关系，因此在这些表中的查找效率取决于比较的次数。

散列函数（也称哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为  $\mathrm{Hash(key) = Addr}$  （这里的地址可以是数组下标、索引或内存地址等）。

散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生冲突的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，因为这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。

散列表（也称哈希表）：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

理想情况下，对散列表进行查找的时间复杂度为  $O(1)$ ，即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。

# 7.5.2 散列函数的构造方法

在构造散列函数时，必须注意以下几点：

1）散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小。

2）散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。

3）散列函数应尽量简单，能在较短的时间内计算出任意一个关键字对应的散列地址。

下面介绍常用的散列函数。

# 1. 直接定址法

直接取关键字的某个线性函数值为散列地址，散列函数为

$$
H (\mathrm {k e y}) = \mathrm {k e y} \text {或} H (\mathrm {k e y}) = a \times \mathrm {k e y} + b
$$

式中， $a$  和  $b$  是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

# 2. 除留余数法

这是一种最简单、最常用的方法，假定散列表表长为  $m$  ，取一个不大于  $m$  但最接近或等于  $m$  的质数  $p$  ，利用以下公式把关键字转换成散列地址。散列函数为

$$
H(\text{key}) = \text{key}\% p
$$

除留余数法的关键是选好  $p$  ，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。

# 3. 数字分析法

设关键字是  $r$  进制数（如十进制数），而  $r$  个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

# 4. 平方取中法

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况。

# 7.5.3 处理冲突的方法

应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。用  $H_{l}$  表示处理冲突

中第  $i$  次探测得到的散列地址，假设得到的另一个散列地址  $H_{1}$  仍然发生冲突，只得继续求下一个地址  $H_{2}$ ，以此类推，直到  $H_{k}$  不发生冲突为止，则  $H_{k}$  为关键字在表中的地址。

# 1. 开放定址法

所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为

$$
H _ {i} = \left(H (\text {key}) + d _ {i}\right) \% m
$$

式中，  $H(\mathrm{key})$  为散列函数；  $i = 1,2,\dots ,k$  （  $k\leqslant m - 1$  ）；  $m$  表示散列表表长；  $d_{i}$  为增量序列。

取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：

# 命题追踪 堆积现象导致的结果（2014）

1）线性探测法，也称线性探测再散列法。  $d_{i} = 1,2,\dots ,m - 1$  。它的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址  $m - 1$  时，下一个探测地址是表首地址0)，直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。

线性探测法可能使第  $i$  个散列地址的同义词存入第  $i + 1$  个散列地址，这样本应存入第  $i + 1$  个散列地址的元素就争夺第  $i + 2$  个散列地址的元素的地址……从而造成大量元素在相邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。

2）平方探测法，也称二次探测法。  $d_{i} = 1^{2}, -1^{2}, 2^{2}, -2^{2}, \dots, k^{2}, -k^{2}$ ，其中  $k \leqslant m / 2$ ，散列表长度  $m$  必须是一个可以表示成  $4k + 3$  的素数。

平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。

3）双散列法。  $d_{i} = i \times \mathrm{Hash}_{2}(\mathrm{key})$  。需要使用两个散列函数，当通过第一个散列函数  $H(\mathrm{key})$  得到的地址发生冲突时，则利用第二个散列函数  $\mathrm{Hash}_{2}(\mathrm{key})$  计算该关键字的地址增量。它的具体散列函数形式如下：

$$
H _ {i} = \left(H (\text {key}) + i \times \operatorname {Hash} _ {2} (\text {key})\right) \% m
$$

初始探测位置  $H_0 = H(\mathrm{key})\% m$  。  $i$  是冲突的次数，初始为0。

4）伪随机序列法。  $d_{i} =$  伪随机数序列。

# 命题追踪 散列表中删除部分元素后的查找效率分析（2023）

# 注意

采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径，删除元素时可以做一个删除标记，进行逻辑删除，具体举例见本书配套课程。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。

# 2. 拉链法（链接法，chaining）

显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为  $i$  的同义词链表的头指针存放在散列表的第  $i$  个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。

例如，关键字序列为{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数  $H(\mathrm{key}) = \mathrm{key}\% 13$ ，用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可尝试计算本例的平均ASL）。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6a3b6cc2f2c9099ad0ecb2b7191893236a146de8cd1f3f707f2ec81c061dccd2.jpg)



图7.33 拉链法处理冲突的散列表


# 7.5.4 散列查找及性能分析的应用

# 命题追踪 散列表的构造及查找效率的分析（2010、2018、2019、2024）

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字 key，根据散列函数可以计算出其散列地址，执行步骤如下：

初始化：Addr = Hash(key);

① 检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与key的值，若相等，则返回查找成功标志，否则执行步骤②。

② 用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤①。

例如，关键字序列{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}按散列函数  $\mathrm{H}(\mathrm{key}) = \mathrm{key}\% 13$  和线性探测处理冲突构造所得的散列表L如图7.34所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/476df88226a03d8f7b2bb87a9f2856175d4327be0d69ac769c8967715544558d.jpg)



图7.34 用线性探测法得到的散列表L


给定值84的查找过程为：首先求得散列地址  $\mathrm{H}(84) = 6$  ，因L[6]不空且  $\mathrm{L}[6]\neq 84$  ，则找第一次冲突处理后的地址  $\mathrm{H}_{1} = (6 + 1)\% 16 = 7$  ，而L[7]不空且  $\mathrm{L}[7]\neq 84$  ，则找第二次冲突处理后的地址  $\mathrm{H}_2 = (6 + 2)\% 16 = 8$  ，L[8]不空且  $\mathrm{L}[8] = 84$  ，查找成功，返回记录在表中的序号8。

给定值38的查找过程为：先求散列地址  $\mathrm{H}(38) = 12$  ，L[12]不空且L[12]≠38，则找下一地址  $\mathrm{H}_{1} = (12 + 1)\% 16 = 13$  ，因为L[13]是空记录，所以表中不存在关键字为38的记录。

查找各关键字的比较次数如图7.35所示。

<table><tr><td>关键字</td><td>14</td><td>01</td><td>68</td><td>27</td><td>55</td><td>19</td><td>20</td><td>84</td><td>79</td><td>23</td><td>11</td><td>10</td></tr><tr><td>比较次数</td><td>1</td><td>2</td><td>1</td><td>4</td><td>3</td><td>1</td><td>1</td><td>3</td><td>9</td><td>1</td><td>1</td><td>3</td></tr></table>

图7.35 查找各关键字的比较次数

平均查找长度ASL为

$$
\mathrm {A S L} = (1 \times 6 + 2 + 3 \times 3 + 4 + 9) / 1 2 = 2. 5
$$

对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同，本例与上节采用拉链法的平均查找长度不同。

从散列表的查找过程可见：

1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，

使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程，因此仍然需要以平均查找长度作为衡量散列表的查找效率的度量。

# 命题追踪 影响散列表查找效率的因素（2011、2022）

2）散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。

装填因子。散列表的装填因子一般记为  $\alpha$  ，定义为一个表的装满程度，即

$$
\alpha = \frac {\text {表 中 记 录 数} n}{\text {散 列 表 长 度} m}
$$

散列表的平均查找长度依赖于散列表的装填因子  $\alpha$  ，而不直接依赖于  $n$  或  $m$  。直观地看， $\alpha$  越大，表示装填的记录越“满”，发生冲突的可能性越大；反之发生冲突的可能性越小。

读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。

# 7.5.5 本节试题精选

# 一、单项选择题

01. 只能在顺序存储结构上进行的查找方法是（）。

A. 顺序查找法

B. 折半查找法

C. 树形查找法

D. 散列查找法

02. 散列查找一般适用于（）的情况下的查找。

A. 查找表为链表

B. 查找表为有序表

C. 关键字集合比地址集合大得多

D. 关键字集合与地址集合之间存在对应关系

03. 下列关于散列表的说法中，正确的是（）。

I. 若散列表的填装因子  $\alpha < 1$  ，则可避免碰撞的产生

II. 散列查找中不需要任何关键字的比较

III. 散列表在查找成功时平均查找长度仅与表长有关

IV. 若在散列表中删除一个元素，不能简单地将该元素删除

A. I 和 IV

B. II 和 III

C. III

D. IV

04. 在开放定址法中散列到同一个地址而引起的“堆积”问题是由（）引起的。

A. 同义词之间发生冲突

B. 非同义词之间发生冲突

C. 同义词之间或非同义词之间发生冲突

D. 散列表 “溢出”

05. 下列关于散列冲突处理方法的说法中，正确的有（）。

I. 采用平方探测法处理冲突时不易产生聚集

II. 采用线性探测法处理冲突时，所有同义词在散列表中一定相邻

III. 采用链地址法处理冲突时，若限定在链首插入，则插入任意一个元素的时间相同

IV. 采用链地址法处理冲突易引起聚集现象

A. I 和 III

B. I、II 和 III

C. III 和 IV

D. I 和 IV

06. 设有一个含有 200 个元素的散列表，用线性探测法解决冲突，按关键字查询时找到一个表项的平均探测次数不超过 1.5，则散列表应能够容纳（）个元素（设查找成功的平均查找长度为  $\mathrm{ASL} = [1 + 1 / (1 - \alpha)] / 2$  ，其中  $\alpha$  为装填因子）。

A. 400

B. 526

C. 624

D. 676

07. 假定有  $K$  个关键字互为同义词，若用线性探测法把这  $K$  个关键字填入散列表，至少要进行（）次探测。

A.  $K - 1$

B.  $K$

C.  $K + 1$

D.  $K(K + 1) / 2$

08. 对包含  $n$  个元素的散列表进行查找，平均查找长度（）。

A. 为  $O(\log_2 n)$

B. 为  $O(1)$

C. 不直接依赖于  $n$

D. 直接依赖于表长  $m$

09. 采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（）。

A. 数据元素过多

B. 负载因子过大

C. 散列函数选择不当

D. 解决冲突的方法选择不当

10. 当用线性探测再散列法解决冲突时，计算出的一系列“下一个空位”的要求是（）。

A. 必须大于或等于原散列地址

B. 必须小于或等于原散列地址

C. 可以大于或小于但不等于原散列地址

D. 对地址在何处没有限制

11. 一组记录的关键字为{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，用链地址法构造散列表，散列函数为 H(key) = key mod 13，散列地址为 1 的链中有（）个记录。

A. 1

B. 2

C. 3

D. 4

12. 在采用链地址法处理冲突所构成的散列表上查找某一关键字，则在查找成功的情况下，所探测的这些位置上的关键字值（）；若采用线性探测法，则（）。

A. 一定都是同义词

B. 不一定都是同义词

C. 都相同

D. 一定都不是同义词

13. 若采用链地址法构造散列表，散列函数为 H(key) = key mod 17，则需（①）个链表。这些链的链首指针构成一个指针数组，数组的下标范围为（②）。

$①$  A.17

B. 13

C. 16

D. 任意

$②$  A.  $0\sim 17$

B.  $1 \sim  {17}$

C.  $0 \sim 16$

D.  $1 \sim 16$

14. 设散列表长  $m = 14$ ，散列函数为 H(key) = key%11，表中仅有 4 个结点 H(15) = 4，H(38) = 5，H(61) = 6，H(84) = 7，若采用线性探测法处理冲突，则关键字为 49 的结点地址是（）。

A. 8

B. 3

C. 5

D. 9

15. 现有长度为 17、初始为空的散列表 HT，散列函数 H(key) = key%17，用线性探查法解决冲突。将关键字序列 26, 25, 72, 38, 8, 18, 59 依次插入 HT 后，则查找 59 需探查（）次。

A. 2

B. 3

C. 4

D. 5

16. 现有长度为 17、初始为空的散列表 HT，散列函数 H(key) = key%17，用平方探测法解决冲突：H_i(key) = (H(key) ± i^2)%17。将关键字序列 6, 22, 7, 26, 9, 23 依次插入 HT 后，则关键字 23 存放在散列表中的位置是（）。

A. 0

B. 2

C. 6

D. 15

17. 将 10 个元素散列到 100000 个单元的散列表中，则（）产生冲突。

A. 一定会

B. 一定不会

C. 仍可能会

D. 不确定

18.【2011统考真题】为提高散列表的查找效率，可以采取的正确措施是（）。

I.增大装填（载）因子

II. 设计冲突（碰撞）少的散列函数

III. 处理冲突（碰撞）时避免产生聚集（堆积）现象

A. 仅 I

B. 仅 II

C. 仅 I、II

D. 仅 II、III

19.【2014统考真题】用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中，会受堆积现象直接影响的是（）。

A. 存储效率

B. 散列函数

C. 装填（装载）因子

D. 平均查找长度

20.【2018统考真题】现有长度为7、初始为空的散列表HT，散列函数  $\mathrm{H(k) = k\%7}$ ，用线性探测再散列法解决冲突。将关键字22,43,15依次插入HT后，查找成功的平均查找长度是（）。

A. 1.5

B. 1.6

C. 2

D. 3

21.【2019统考真题】现有长度为11且初始为空的散列表HT,散列函数是H(key)=key%7，采用线性探查（线性探测再散列）法解决冲突。将关键字序列87,40,30,6,11,22,98,20依次插入HT后，HT查找失败的平均查找长度是（）。

A. 4

B. 5.25

C. 6

D. 6.29

22.【2022统考真题】下列因素中，影响散列（哈希）方法平均查找长度的是（）。

I. 装填因子

II. 散列函数

III. 冲突解决策略

A. 仅 I、II

B. 仅 I、III

C. 仅 II、III

D. I、II、III

23.【2023统考真题】现有长度为5、初始为空的散列表HT，散列函数  $\mathrm{H(k) = (k + 4)\%5}$  用线性探查再散列法解决冲突。若将关键字序列2022,12,25依次插入HT，然后删除关键字25，则HT中查找失败的平均查找长度为（）。

A. 1

B. 1.6

C. 1.8

D. 2.2

# 二、综合应用题

01. 若要在散列表中删除一个记录，应如何操作？为什么？按照处理冲突的方法为开放地址法和拉链法分别说明。

02. 假定把关键字 key 散列到有  $n$  个表项（从 0 到  $n - 1$  编址）的散列表中。对于下面的每个函数 H(key)（key 为整数），这些函数能够当作散列函数吗？若能，它是一个好的散列函数吗？说明理由。设函数 random(n) 返回一个 0 到  $n - 1$  之间的随机整数（包括 0 与  $n - 1$  在内）。

1）H(key)  $=$  key/n。

2）H(key)  $= 1$

3）H(key) = (key + random(n)) % n。

4）H(key) = key%p(n)；其中 p(n) 是不大于  $n$  的最大素数。

03. 使用散列函数 H(key) = key % 11，把一个整数值转换成散列表下标，散列表的长度为 11，现在要把数据 {1, 13, 12, 34, 38, 33, 27, 22} 依次插入散列表。

1）使用线性探测法来构造散列表。

2）使用链地址法构造散列表。

试针对这两种情况，分别确定查找成功所需的平均查找长度，及查找不成功所需的平均查找长度。

04. 已知一组关键字为  $\{26, 36, 41, 38, 44, 15, 68, 12, 6, 51, 25\}$ ，用链地址法解决冲突，假设装填因子  $\alpha = 0.73$ ，散列函数的形式为  $H(key) = key \% P$ ， $P$  为不大于表长的最大素数，请回答以下问题：

1）构造出散列函数。

2）分别计算出等概率情况下查找成功和查找失败的平均查找长度（查找失败的计算中只将与关键字的比较次数计算在内即可）。

05. 设散列表为 HT[0...12]，即表的大小为  $m = 13$  。现采用双散列法解决冲突，散列函数和再散列函数分别为：

$\mathrm{H}_0(\mathrm{key}) = \mathrm{key}\% 13$  注：  $\%$  是取模运算（  $= \mathrm{mod}$  ）

$\mathrm{H}_{t} = (\mathrm{H}_{t - 1} + \mathrm{REV}(\mathrm{key} + 1)\% 11 + 1)\% 13;\quad i = 1,2,3,\dots ,m - 1$

其中，函数  $\mathrm{REV}(x)$  表示颠倒十进制数  $x$  的各位，如  $\mathrm{REV}(37) = 73$  ，  $\mathrm{REV}(7) = 7$  等。若插入的关键码序列为(2,8,31,20,19,18,53,27)，请回答：

1）画出插入这8个关键码后的散列表。

2）计算查找成功的平均查找长度ASL。

06.【2010统考真题】将关键字序列(7,8,30,11,18,9,14)散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组，散列函数为  $\mathrm{H}(\mathrm{key}) = (\mathrm{key}\times 3)\mod 7$  ，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7。

1）请画出所构造的散列表。

2）分别计算等概率情况下，查找成功和查找不成功的平均查找长度。

07.【2024统考真题】将关键字序列20,3,11,18,9,14,7依次存储到初始为空、长度为11的散列表HT中，散列函数  $H(\mathrm{key}) = (\mathrm{key}\times 3)\% 11$  。  $H(\mathrm{key})$  计算出的初始散列地址为  $H_{0}$  ，发生冲突时探查地址序列是  $H_{1},H_{2},H_{3},\dots$  ，其中，  $H_{k} = (H_{0} + k^{2})\% 11$  ，  $k = 1,2,3,\dots$

请回答下列问题：

1）画出所构造的HT，并计算HT的装填因子。

2）给出在HT中查找关键字14的关键字比较序列。

3）在HT中查找关键字8，确认查找失败时的散列地址是多少？

# 7.5.6 答案与解析

# 一、单项选择题

# 01. B

顺序查找可以是顺序存储或链式存储；折半查找只能是顺序存储且要求关键字有序；树形查找法要求采用树的存储结构，既可以采用顺序存储也可以采用链式存储；散列查找中的链地址法解决冲突时，采用的是顺序存储与链式存储相结合的方式。

# 02. D

关键字集合与地址集合之间存在对应关系时，通过散列函数表示这种关系。这样，查找以计算散列函数而非比较的方式进行查找。

# 03. D

冲突（碰撞）是不可避免的，与装填因子无关，因此需要设计处理冲突的方法，选项I错误。散列查找的思想是计算出散列地址来进行查找，然后比较关键字以确定是否查找成功，选项II错误。散列查找成功的平均查找长度与装填因子有关，与表长无直接关系，选项III错误。在开放定址的情形下，不能随便删除散列表中的某个元素，否则可能会导致搜索路径被中断（因此通常的做法是在要删除的地方做删除标记，而不是直接删除），选项IV正确。

# 04. C

在开放定址法中散列到同一个地址而产生的“堆积”问题，是同义词冲突的探查序列和非同义词之间不同的探查序列交织在一起，导致关键字查询需要经过较长的探测距离，降低了散列的效率。因此要选择好的处理冲突的方法来避免“堆积”。

# 05. A

平方探测法采用的增量序列是非线性的，它可以跳过一些已被占用的单元，而不是顺序地探测下一单元，这样能减小冲突的概率，选项I正确。散列地址  $i$  的关键字，和为解决冲突形成的某次探测地址为  $i$  的关键字，都争夺地址  $i, i + 1, \dots$  ，因此不一定相邻，选项II错误。选项III正确。同义词冲突不等于聚集，链地址法处理冲突时将同义词放在同一个链表中，不会引起聚集现象，选项IV错误。

# 06. A

若有200个元素要放入散列表，采用线性探测法解决冲突，限定查找成功的平均查找长度不超过1.5，则

$$
\mathrm {A S L} _ {\text {成 功}} = \frac {1}{2} \left(1 + \frac {1}{1 - \alpha}\right) \leqslant 1. 5 \Rightarrow \alpha = \frac {2 0 0}{m} \leqslant \frac {1}{2} \Rightarrow m \geqslant 4 0 0
$$

# 07. D

$K$  个关键字在依次填入的过程中，只有第一个不会发生冲突，所以探测次数为  $1 + 2 + 3 + \dots + K = K(K + 1) / 2$ 。

# 08. C

散列表的平均查找长度与装填因子  $\alpha$  直接相关，表的查找效率不直接依赖于表中已有表项个数  $n$  或表长  $m$  。若表中存放的记录全是某个地址的同义词，则平均查找长度为  $O(n)$  而非  $O(1)$  。

# 09. D

聚集是因选取不当的处理冲突的方法，而导致不同关键字的元素对同一散列地址进行争夺的现象。用线性探查法时，容易引发聚集现象。

# 10. C

“下一个空位”可以大于或小于但不等于原散列地址，等于原散列地址是没有意义的。

# 11. D

由散列函数计算可知，14,1,27,79散列后的地址都是1，所以有4个记录。

# 12. A, B

因为在链地址法中，映射到同一地址的关键字都会链到与此地址相对应的链表上，所以探测过程一定是在此链表上进行的，从而这些位置上的关键字均为同义词；但在线性探测法中出现两个同义关键字时，会把该关键字对应地址的下一个地址也占用掉，两个地址分别记为Addr、Addr+1，查找一个满足H(key) = Addr + 1的关键字key时，显然首次探测到的不是key的同义词。

# 13. A, C

H的取值有17种可能，对应到不同的链表中，所以链表的个数应为17。因为H(key)的取值范围是  $0\sim 16$  ，所以数组下标为  $0\sim 16$  。

# 14. A

线性探测法的公式为  $\mathrm{H}_i = (\mathrm{H}(\mathrm{key}) + \mathrm{d}_i) \% \mathrm{m}$ ，其中  $d_i = 1,2,\dots,m-1$ 。 $\mathrm{H}(49) = 49 \% 11 = 5$ ，有冲突； $\mathrm{H}_1 = (\mathrm{H}(49) + 1) \% 14 = 6$ ，有冲突； $\mathrm{H}_2 = (\mathrm{H}(49) + 2) \% 14 = 7$ ，有冲突； $\mathrm{H}_3 = (\mathrm{H}(49) + 3) \% 14 = 8$ ，无冲突。

# 15. C

插入过程如下：  $\mathrm{H}(26) = 9$  ，不冲突；  $\mathrm{H}(25) = 8$  ，不冲突；  $\mathrm{H}(72) = 4$  ，不冲突；  $\mathrm{H}(38) = 4$  中冲突，冲突处理后的地址为5；  $\mathrm{H}(8) = 8$  ，冲突，冲突处理后的地址为10；  $\mathrm{H}(18) = 1$  ，不冲突； $\mathrm{H}(59) = 8$  ，冲突，冲突处理后的地址为11。因此，在表中查找59需要探查4次。

# 16. B

插入过程如下： $6\% 17 = 6$ ； $22\% 17 = 5$ ； $7\% 17 = 7$ ； $26\% 17 = 9$ ； $9\% 17 = 9$ ，冲突，平方探测法探测10（无冲突）； $23\% 17 = 6$ ，冲突，平方探测法探测7（冲突），探测5（冲突），探测10（冲突），探测2（无冲突）。因此，关键字23应放在位置2。构造的散列表如下表所示。

<table><tr><td>地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td></tr><tr><td>元素</td><td></td><td></td><td>23</td><td></td><td></td><td>22</td><td>6</td><td>7</td><td></td><td>26</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>

17. C

由于散列函数的选取，仍然有可能产生地址冲突，冲突不能绝对地避免。

18. D

散列表的查找效率取决于散列函数、处理冲突的方法和装填因子。显然，冲突的产生概率与装填因子（表中记录数与表长之比）的大小成正比，选项I与题意相反。选项II显然正确。采用合适的冲突处理方法可避免聚集现象，也将提高查找效率，选项III正确。例如，用链地址法处理冲突时不存在聚集现象，用线性探测法处理冲突时易引起聚集现象。

19. D

堆积现象因冲突而产生，它对存储效率、散列函数和装填因子均不会有影响，而平均查找长度会因为堆积现象而增大。散列函数是指将关键字映射到哈希地址的函数。存储效率和装填（装载）因子的定义相同，指哈希表中已存储的元素个数与哈希表长度的比值。这些因素都与堆积现象无关，而只与哈希表的结构和设计有关。

20. C

根据题意，得到的HT如下：

<table><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td></td><td>22</td><td>43</td><td>15</td><td></td><td></td><td></td></tr></table>

$$
\mathrm {A S L} _ {\text {成 功}} = (1 + 2 + 3) / 3 = 2 。
$$

21. C

采用线性探查法计算每个关键字的存放情况如下表所示。

<table><tr><td>散列地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr><tr><td>关键字</td><td>98</td><td>22</td><td>30</td><td>87</td><td>11</td><td>40</td><td>6</td><td>20</td><td></td><td></td><td></td></tr></table>

由于  $\mathrm{H}(\mathrm{key}) = 0\sim 6$  ，查找失败时可能对应的地址有7个，对于计算出地址为0的关键字key0，只有比较完  $0\sim 8$  号地址后才能确定该关键字不在表中，比较次数为9；对于计算出地址为1的关键字key1，只有比较完  $1\sim 8$  号地址后才能确定该关键字不在表中，比较次数为8；以此类推。需要特别注意的是，散列函数不可能计算出地址7，因此有

$$
\mathrm {A S L} _ {\text {失 败}} = (9 + 8 + 7 + 6 + 5 + 4 + 3) / 7 = 6
$$

22. D

原题再现。填装因子越大，说明哈希表中存储的元素越满，发生冲突的可能性就越高，导致平均查找长度越大。散列函数、冲突解决策略也会影响发生冲突的可能性。选项I、II、III都正确。

23. C

当采用开放定址法时，不能随便物理删除表中的已有元素，因为若删除元素，则可能截断其他具有相同散列地址的元素的查找地址。因此，当要删除一个元素时，可给它做一个删除标记。依次将2022,12,25插入散列表，然后删除25，得到的散列表如下：

<table><tr><td>地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>关键字</td><td></td><td>2022</td><td>12</td><td></td><td>25（删除）</td></tr><tr><td>查找失败次数</td><td>1</td><td>3</td><td>2</td><td>1</td><td>2</td></tr></table>

当查找位置是删除标记时，应继续往后查找。

查找失败的平均查找长度为  $(1 + 3 + 2 + 1 + 2) / 5 = 1.8$

# 二、综合应用题

# 01. 【解答】

在散列表中删除一个记录，在拉链法情况下可以物理地删除。但在开放定址法情况下，不能物理地删除，只能做删除标记。该地址可能是该记录的同义词查找路径上的地址，物理地删除就中断了查找路径，因为查找时碰到空地址就认为是查找失败。

# 02.【解答】

1）不能作为散列函数，因为  $\mathrm{key} / n$  可能大于  $n$  ，这样就无法找到适合的位置。

2）能够作为散列函数，但不是一个好的散列函数，因为所有关键字都映射到同一位置，造成大量的冲突机会。

3）不能当作散列函数，因为该函数的返回值不确定，这样无法进行正常的查找。

4）能够作为散列函数，是一个好的散列函数。

# 03.【解答】

由散列函数可知散列地址的范围为  $0\sim 10$

采用线性探测法构造散列表时，首先应计算出关键字对应的散列地址，然后检查散列表中对应的地址是否已经有元素。若没有元素，则直接将该关键字放入散列表对应的地址中；若有元素，则采用线性探测的方法查找下一个地址，从而决定该关键字的存放位置。

采用链地址法构造散列表时，在直接计算出关键字对应的散列地址后，将关键字结点插入此散列地址所在的链表。

具体解答如下。

# 1）线性探测法。

$\mathrm{H}(1) = 1$  ，无冲突，地址1存放关键字  $1_{\circ}\mathrm{H}(13) = 2$  ，无冲突，地址2存放关键字  $13_{\circ}\mathrm{H}(12) = 1$  发生冲突，根据线性探测法：  $\mathrm{H}_{1} = 2$  ，发生冲突，继续探测  $\mathrm{H}_2 = 3$  ，无冲突，于是12存放在地址为3的表项中。  $\mathrm{H}(34) = 1$  ，发生冲突，根据线性探测法：  $\mathrm{H}_{1} = 2$  ，发生冲突，  $\mathrm{H}_2 = 3$  ，发生冲突，  $\mathrm{H}_3 = 4$  没有冲突，于是34存放在地址为4的表项中。

同理，可以计算其他的数据存放情况，最后结果如下表所示。

<table><tr><td>散列地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr><tr><td>关键字</td><td>33</td><td>1</td><td>13</td><td>12</td><td>34</td><td>38</td><td>27</td><td>22</td><td></td><td></td><td></td></tr><tr><td>冲突次数</td><td>0</td><td>0</td><td>0</td><td>2</td><td>3</td><td>0</td><td>1</td><td>7</td><td></td><td></td><td></td></tr></table>

下面计算平均查找长度：

查找成功时，显然查找每个元素的概率都是1/8。对于33，因为冲突次数为0，所以仅需1次比较便可查找成功；对于22，因为计算出的地址为0，但需要8次比较才能查找成功，所以22的查找长度为8；其他元素的分析类似。因此有

$$
\mathrm {A S L} _ {\text {成 功}} = (1 + 1 + 1 + 3 + 4 + 1 + 2 + 8) / 8 = 2 1 / 8
$$

查找失败时，H(key)  $= 0\sim 10$  ，因此对每个位置查找的概率都是1/11，对于计算出的地址为0的关键字key0，只有探测完  $0\sim 8$  号地址后才能确定该元素不在表中，比较次数为9；对于计算出的地址为1的关键字key1，只有探测完  $1\sim 8$  号地址后，才能确定该元素不在表中，比较次数为8，以此类推。而对于计算出的地址为8,9,10的关键字，这些单元中没有存放元素，所以只需比较1次便可确定查找失败，因此有

$$
\mathrm {A S L} _ {\text {失 败}} = (9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 1 + 1) / 1 1 = 4 7 / 1 1
$$

# 2）链地址法构造的表如下：

在链地址表中查找成功时，查找关键字为33的记录需进行1次比较，查找关键字为22的记录需进行2次比较，以此类推。因此有

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cc93c2bdfc674ca1ae5e2c911ac3ed3f9058d5c92f8187bf09b7c65c8f2e0add.jpg)


查找失败时，对于地址0，比较3次后确定元素不在表中（空指针算1次），所以其查找长度为3；对于地址1，其查找长度为4；对于地址2，查找长度为2；以此类推。因此有

$$
\mathrm {A S L} _ {\text {失 败}} = (3 + 4 + 2 + 1 + 1 + 3 + 1 + 1 + 1 + 1 + 1) / 1 1 = 1 9 / 1 1
$$

# 注意

求查找失败的平均查找长度时有两种观点：其一，认为比较到空结点才算失败，所以比较次数等于冲突次数加1；其二，认为只有与关键字的比较才算比较次数。

# 04.【解答】

由装填因子的计算公式  $\alpha = n / N$  （  $n$  为关键字个数，  $N$  为表长），不难得出表长，而根据散列函数的选择要求，  $P$  应该取不大于表长的最大素数，从而可以确定  $P$  的大小，也就构造出了散列函数。采用链地址法解决冲突。具体解答如下。

1）由  $\alpha = n / N$  得  $N = n / \alpha$  ，即  $N = n / \alpha \approx 15$  ，从而  $P = 13$  。因此散列函数为  $\mathrm{H}(\mathrm{key}) = \mathrm{key}\% 13$

2）由1）求出的散列函数，计算各关键字对应的散列地址如下表所示。

<table><tr><td>关键字</td><td>26</td><td>36</td><td>41</td><td>38</td><td>44</td><td>15</td><td>68</td><td>12</td><td>6</td><td>51</td><td>25</td></tr><tr><td>散列地址</td><td>0</td><td>10</td><td>2</td><td>12</td><td>5</td><td>2</td><td>3</td><td>12</td><td>6</td><td>12</td><td>12</td></tr></table>

由此构造的链地址法处理冲突的散列表为

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/eb6774b2fe959a42fe0368b964b7b24f8c0ea077e8236d80b55a084de9778c92.jpg)


由上图不难计算出

$$
\mathrm {A S L} _ {\text {成 功}} = (1 \times 7 + 2 \times 2 + 3 \times 1 + 4 \times 1) / 1 1 = 1 8 / 1 1
$$

$$
\mathrm {A S L} _ {\text {失 败}} = (1 + 0 + 2 + 1 + 0 + 1 + 1 + 0 + 0 + 0 + 1 + 0 + 4) / 1 3 = 1 1 / 1 3
$$

05.【解答】

1） $\mathrm{H_0(2)} = 2$ ， $\mathrm{H_0(8)} = 8$ ， $\mathrm{H_0(31)} = 5$ ， $\mathrm{H_0(20)} = 7$ ， $\mathrm{H_0(19)} = 6$ ，没有冲突。 $\mathrm{H_0(18)} = 5$ ，发生冲突， $\mathrm{H_1(18)} = (\mathrm{H_0(18)} + \mathrm{REV}(18 + 1) \%11 + 1) \%13 = (5 + 3 + 1) \%13 = 9$ ，没有冲突。 $\mathrm{H_0(53)} = 1$ ，没有冲突。 $\mathrm{H_0(27)} = 1$ ，发生冲突， $\mathrm{H_1(27)} = (\mathrm{H_0(27)} + \mathrm{REV}(27 + 1) \%11 + 1) \%13 = (1 + 5 + 1) \%13 = 7$ ，发生冲突， $\mathrm{H_2(27)} = (\mathrm{H_1(27)} + \mathrm{REV}(27 + 1) \%11 + 1) \%13 = 0$ ，没有冲突。构造的散列表如下：

<table><tr><td>散列地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td>关键字</td><td>27</td><td>53</td><td>2</td><td></td><td></td><td>31</td><td>19</td><td>20</td><td>8</td><td>18</td><td></td><td></td><td></td></tr><tr><td>比较次数</td><td>3</td><td>1</td><td>1</td><td></td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td></td><td></td><td></td></tr></table>

2）由1）中散列表的构造过程，各个关键字查找成功的比较次数如上表所示，所以有

$$
\mathrm {A S L} _ {\text {成 功}} = (3 + 1 + 1 + 1 + 1 + 1 + 1 + 2) / 8 = 1 1 / 8
$$

06.【解答】

1）由装填因子0.7和数据总数7，得一维数组大小为  $7 / 0.7 = 10$ ，数组下标为  $0\sim 9$  。所构造的散列函数值如下所示：

<table><tr><td>key</td><td>7</td><td>8</td><td>30</td><td>11</td><td>18</td><td>9</td><td>14</td></tr><tr><td>H (key)</td><td>0</td><td>3</td><td>6</td><td>5</td><td>5</td><td>6</td><td>0</td></tr></table>

采用线性探测再散列法处理冲突，所构造的散列表为

<table><tr><td>地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>关键字</td><td>7</td><td>14</td><td></td><td>8</td><td></td><td>11</td><td>30</td><td>18</td><td>9</td><td></td></tr></table>

2）查找成功时，在等概率情况下，查找每个表中元素的概率是相等的。因此，根据表中元素的个数来计算平均查找长度，各关键字的比较次数如下所示：

<table><tr><td>key</td><td>7</td><td>8</td><td>30</td><td>11</td><td>18</td><td>9</td><td>14</td></tr><tr><td>比较次数</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>2</td></tr></table>

所以  $\mathrm{ASL}_{\text{成功}} =$  查找次数/元素个数  $= (1 + 2 + 1 + 1 + 1 + 3 + 3) / 7 = 12 / 7$

在计算查找失败时的平均查找长度时，要特别注意防止思维定式，在查找失败的情况下既不是根据表中的元素个数，也不是根据表长来计算平均查找长度的。

查找失败时，在等概率情况下，经过散列函数计算后只可能映射到表中的  $0\sim 6$  位置，且映射到  $0\sim 6$  中任意一个位置的概率是相等的。因此，是根据散列函数（mod后面的数字）来计算平均查找长度的。在等概率情况下，查找失败的比较次数如下所示：

<table><tr><td>H(key)</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>比较次数</td><td>3</td><td>2</td><td>1</td><td>2</td><td>1</td><td>5</td><td>4</td></tr></table>

所以  $\mathrm{ASL}_{\text{不成功}} =$  查找次数/散列后的地址个数  $= (3 + 2 + 1 + 2 + 1 + 5 + 4) / 7 = 18 / 7$ 。

07.【解答】

1）①  $H(20) = 5$ ，装入地址5；②  $H(3) = 9$ ，装入地址9；③  $H(11) = 0$ ，装入地址0；④  $H(18) = 10$ ，装入地址10；⑤  $H(9) = 5$ ，冲突，  $H_{1}(9) = (5 + 1)\% 11 = 6$ ，装入地址6；⑥  $H(14) = 9$ ，冲突，  $H_{1}(14) = (9 + 1)\% 11 = 10$ ，冲突，  $H_{2}(14) = (9 + 4)\% 11 = 2$ ，装入地址2。散列表如下。

<table><tr><td>散列地址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr><tr><td>关键字</td><td>11</td><td></td><td>14</td><td>7</td><td></td><td>20</td><td>9</td><td></td><td></td><td>3</td><td>18</td></tr></table>

装填因子  $\alpha = 7 / 11$

2） $H(14) = 9$ ，和关键字3比较，不命中； $H_{1}(14) = (9 + 1)\% 11 = 10$ ，和18比较，不命中； $H_{2}(14) = (9 + 4)\% 11 = 2$ ，和14比较，命中。因此，关键字比较序列是3,18,14。

3）  $H(8) = 2$  ，和关键字14比较，不命中；  $H_{1}(8) = (2 + 1)\% 11 = 3$  ，和7比较，不命中；  $H_{2}(8) = (2 + 4)\% 11 = 6$  ，和9比较，不命中；  $H_{3}(8) = (2 + 9)\% 11 = 0$  ，和11比较，不命中；  $H_{4}(8) = (2 + 16)\% 11 = 7$  ，是空位置，确认查找失败。因此，确认查找失败时的散列地址是7。

# 归纳总结

本章的核心考查点是求平均查找长度（ASL），以度量各种查找算法的性能。查找算法本身依托于查找结构，查找结构又是由相同数据类型的记录或结点构成的，所以最终落脚于数据结构类型的区别。不管是何种查找算法，其平均查找长度的计算公式都是一样的。

查找成功的平均查找长度  $\mathrm{ASL}_{\text{成功}} = \sum_{i=1}^{n} p_i c_i$ 。

查找失败的平均查找长度  $\mathrm{ASL}_{\text{不成功}} = \sum_{j=0}^{n} q_j c_j$ 。

设一个查找集合中已有  $n$  个数据元素，每个元素的查找概率为  $p_i$  ，查找成功的数据比较次数为  $c_{i}(i = 1,2,\dots ,n)$  ；不在此集合中的数据元素分布在由这  $n$  个元素的间隔构成的  $n + 1$  个子集合内，每个子集合元素的查找概率为  $q_{j}$  ，查找不成功的数据比较次数为  $c_{j}(j = 0,1,\dots ,n)$  。因此，对某一特定查找算法的查找成功的  $\mathrm{ASL}_{\text{成功}}$  和查找失败的  $\mathrm{ASL}_{\text{不成功}}$  ，是综合考虑还是分开考虑呢？

若综合考虑，即  $\sum_{i=1}^{n} p_{i} + \sum_{j=0}^{n} q_{j} = 1$  ，若所有元素查找概率相等，则有  $p_{i} = q_{j} = \frac{1}{2n+1}$  ；若分开考虑，即  $\sum_{i=1}^{n} p_{i} = 1$  ， $\sum_{j=0}^{n} q_{j} = 1$  ，若所有元素查找概率相等，则有  $p_{i} = \frac{1}{n}$ ， $q_{j} = \frac{1}{n+1}$ 。

虽然综合考虑更为理想，但在实际应用中多数是分开考虑的，因为对于查找不成功的情况，很多场合下没有明确给出，往往会被忽略掉。不过读者仍要注意的是，这两种考虑的计算结果是不同的，考试中一定要仔细阅读题目的要求，以免失误。

# 思维拓展

本章介绍了几种基本的查找算法，在实际中又会碰到怎样的查找问题呢？

题目：数组中有一个数字出现的次数超过了数组长度的一半，请找出这个数字。读者也许会想到先进行排序，位于位置  $(n + 1) / 2$  的数即要找的数，这样最小时间复杂度就为  $O(n\log_2n)$ ；若进行散列查找，数字的范围又未知，则应如何将时间复杂度控制在  $O(n)$  内呢？

# 提示

出现的次数超过数组长度的一半，表明这个数字出现的次数比其他数字出现的次数的总和还多。所以我们可以考虑每次删除两个不同的数，则在剩下的数中，待查找数字出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除其他的数字，最终剩下的都为同一个数字，即要找的数字。

# 排序

# 【考纲内容】

（一）排序的基本概念

（二）插入排序

直接插入排序；折半插入排序；希尔排序（shell sort）

（三）交换排序

冒泡排序（bubble sort）：快速排序

（四）选择排序

简单选择排序；堆排序

（五）二路归并排序（merge sort）

（六）基数排序

（七）外部排序

（八）排序算法的分析和应用

# 【知识框架】

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/309c40a9b426a228de4f9c89c07ddcd6ec54f446ee056942d60eccb6a3a91285.jpg)


# 【复习提示】

堆排序、快速排序和归并排序是本章的重难点。读者应深入掌握各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等），通常以选择题的形式考查不同算法之间的对比。此外，对于一些常用排序算法的关键代码，要达到熟练编写的程度；看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。


扫一扫


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/aa177c26495718f5adda6441cdeda84af70fd48e9df0609c59dff1f2d3eb0563.jpg)



视频讲解


# 8.1 排序的基本概念

# 8.1.1 排序的定义

排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下：

输入：  $n$  个记录  $R_{1}, R_{2}, \dots, R_{n}$ ，对应的关键字为  $k_{1}, k_{2}, \dots, k_{n}$ 。

输出：输入序列的一个重排  $R_1', R_2', \dots, R_n'$ ，使得  $k_1' \leqslant k_2' \leqslant \dots \leqslant k_n'$  （其中“ $\leqslant$ ”可以换成其他的比较大小的符号）。

算法的稳定性。若待排序表中有两个元素  $R_{i}$  和  $R_{j}$ ，其对应的关键字相同，即  $\mathrm{key}_i = \mathrm{key}_j$ ，且在排序前  $R_{i}$  在  $R_{j}$  的前面，若使用某一排序算法排序后， $R_{i}$  仍然在  $R_{j}$  的前面，则称这个排序算法是稳定的，否则称这个排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。若待排序表中的关键字不允许重复，排序结果是唯一的，则对于排序算法的选择，稳定与否无关紧要。

# 注意

对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。

在排序过程中，根据数据元素是否完全存放在内存中，可将排序算法分为两类：①内部排序，是指在排序期间元素全部存放在内存中的排序；②外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较操作。

每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。

# 注意

大多数的内部排序算法都更适用于顺序存储的线性表。

# 8.1.2 本节试题精选

# 单项选择题

01. 下述排序算法中，不属于内部排序算法的是（）。

A. 插入排序

B. 选择排序

C. 拓扑排序

D. 冒泡排序

02. 排序算法的稳定性是指（）。

A. 经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变

B. 经过排序后，能使关键字相同的元素保持原顺序中的绝对位置不变

C. 排序算法的性能与被排序元素个数关系不大

D. 排序算法的性能与被排序元素的个数关系密切

03. 下列关于排序的叙述中，正确的是（）。

A. 稳定的排序算法优于不稳定的排序算法

B. 对同一线性表使用不同的排序算法进行排序，得到的排序结果可能不同

C. 排序算法都是在顺序表上实现的, 在链表上无法实现排序算法

D. 在顺序表上实现的排序算法在链表上也可以实现

# 8.1.3 答案与解析

# 单项选择题

# 01. C

拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于我们这里所提到的内部排序范畴，也不满足前面排序的定义。

# 02. A

注意，这里的绝对位置是指若在排序前元素  $R$  在位置  $i$  ，则绝对位置就是  $i$  ，即排序后  $R$  的位置不发生变化，显然选项B是不对的。选项C、D与题目要求无关。

# 03. B

算法的稳定性与算法优劣无关，选项A排除。使用链表也可以进行排序，只是有些排序算法不再适用，因为这时定位元素只能顺序逐链查找，如折半插入排序。

# 8.2 插入排序

插入排序是一种简单直观的排序算法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。

# 8.2.1 直接插入排序①

根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表 L[1...n] 在某次排序过程中的某一时刻状态如下：

<table><tr><td>有序序列 L[1..i-1]</td><td>L(i)</td><td>无序序列 L[i+1..n]</td></tr></table>

要将元素L(i)插入已有序的子序列L[1...i-1]，需要执行以下操作（为避免混淆，下面用L[]表示一个表，而用L()表示一个元素）：

1）查找出  $\mathbb{L}(i)$  在  $\mathbb{L}[1\dots i - 1]$  中的插入位置k。

2）将  $\mathsf{L}[\mathsf{k}\dots \mathsf{i} - 1]$  中的所有元素依次后移一个位置。

3）将  $\mathsf{L}(\mathrm{i})$  复制到  $\mathsf{L}(\mathbf{k})$  。

为了实现对  $\mathsf{L}[1\dots \mathsf{n}]$  的排序，可以将  $\mathsf{L}(2)\sim \mathsf{L}(\mathsf{n})$  依次插入前面已排好序的子序列，初始  $\mathsf{L}[1]$  可以视为一个已排好序的子序列。上述操作执行  $n - 1$  次就能得到一个有序的表。插入排序在实现上通常采用原地排序（空间复杂度为  $O(1)$ ），因而在从后往前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。

下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）。

```javascript
void InsertSort(ElemType A[],int n){  
    int i, j;  
    for(i = 2; i <= n; i++) //依次将A[2]~A[n]插入前面已排序序列  
        if(A[i] < A[i-1]) { //若A[i]关键码小于其前驱，将A[i]插入有序表  
            A[0] = A[i]; //复制为哨兵，A[0]不存放元素  
            for(j = i-1; A[0] < A[j]; --j) //从后往前查找待插入位置  
                A[j+1] = A[j]; //向后挪位  
                A[j+1] = A[0]; //复制到插入位置  
        }  
}
```

假定初始序列为49,38,65,97,76,13,27, $\overline{49}$ ，初始时49可以视为一个已排好序的子序列，按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c74818788f3323e067cd0510055701bb8807ea0c3b93805a2e0a43ca0225bf80.jpg)



图8.1 直接插入排序示例


直接插入排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，因而空间复杂度为  $O(1)$ 。

时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了  $n - 1$  趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。

在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为  $O(n)$ 。

在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大，总的时间复杂度为  $O(n^{2})$ 。

平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为  $n^2 / 4$ 。

因此，直接插入排序算法的时间复杂度为  $O(n^{2})$

稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序算法。

适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。

# 8.2.2 折半插入排序

从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：①从前面的有序子表中查找出待插入元素应该被插入的位置；②给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半

查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。

折半插入排序算法的排序过程举例见本书配套课程，其代码如下：

```c
void InsertSort(ElemType A[],int n){  
    int i,j,low,high,mid;  
    for(i=2;i<=n;i++) { //依次将A[2]~A[n]插入前面的已排序序列  
        A[0]=A[i]; //将A[i]暂存到A[0]  
        low=1;high=i-1; //设置折半查找的范围  
        while(low<=high) { //折半查找(默认递增有序)  
            mid=(low+high)/2; //取中间点  
            if(A[mid]>A[0]) high=mid-1; //查找左半子表  
                else low=mid+1; //查找右半子表  
            }  
        for(j=i-1;j>=high+1;--j)  
            A[j+1]=A[j]; //统一后移元素，空出插入位置  
            A[high+1]=A[0]; //插入操作  
    }
```

# 命题追踪 直接插入排序和折半插入排序的比较（2012）

从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为  $O(n\log_2n)$  该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数  $n$  ；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为  $O(n^{2})$  ，但对于数据量不算很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。

折半插入排序仅适用于顺序存储的线性表。

# 8.2.3 希尔排序

从前面的分析可知，直接插入排序算法的时间复杂度为  $O(n^{2})$  ，但若待排序列为“正序”时，其时间效率可提高至  $O(n)$  ，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，也称缩小增量排序。

# 命题追踪 希尔排序中各子序列采用的排序算法（2015）

希尔排序的基本思想是：先将待排序表分割成若干形如  $\mathrm{L}[i,i + d,i + 2d,\dots ,i + kd]$  的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

# 命题追踪 根据希尔排序的中间过程判断所采用的增量（2014、2018）

希尔排序的过程如下：先取一个小于  $n$  的增量  $d_{1}$ ，把表中的全部记录分成  $d_{1}$  组，所有距离为  $d_{1}$  的倍数的记录放在同一组，在各组内进行直接插入排序；然后取第二个增量  $d_{2} < d_{1}$ ，重复上述过程，直到所取到的  $d_{t} = 1$ ，即所有记录已放在同一组中，再进行直接插入排序，此时已经具有较好的局部有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以8.2.1节的关键字为例，假定第一趟取增量  $d_{1} = 5$ ，将该序列分成5个子序列，即图中第2行至第6行，分别对各子序列进行直接插入排序，结果如第7行所示；假定第二趟取增量  $d_{2} = 3$ ，分别对三个子序列进行直接插入排序，结果如第11行所示；最后对整个序列进行一趟直接插入排序，整个排序过程如图8.2所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/b4d2ccad90c636f80c109276801cd76edc0e493b8cb60a011afc996a07da4c44.jpg)



图8.2 希尔排序示例


希尔排序算法的代码如下：

```txt
void ShellSort(ElemType A[],int n){  
//A[0]只是暂存单元，不是哨兵，当  $j<=0$  时，插入位置已到  
int dk,i,j;  
for  $(dk = n / 2; dk >= 1; dk = dk / 2)$  //增量变化（无统一规定）  
for(i=dk+1;i<=n++;++)  
if(A[i]<A[i-dk]) { //需将A[i]插入有序增量子表  
A[0]=A[i]; //暂存在A[0]  
for(j=i-dk;j>0&&A[0]<A[j];j-=dk)  
A[j+dk]=A[j]; //记录后移，查找插入的位置  
A[j+dk]=A[0]; //插入  
}
```

希尔排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，因而空间复杂度为  $O(1)$ 。

时间效率：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当  $n$  在某个特定范围时，希尔排序的时间复杂度约为  $O(n^{1.3})$ 。在最坏情况下希尔排序的时间复杂度为  $O(n^2)$ 。

稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序算法。例如，图8.2中49与  $\overline{49}$  的相对次序已发生了变化。

适用性：希尔排序仅适用于顺序存储的线性表。

# 8.2.4 本节试题精选

# 一、单项选择题

01. 对5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（）。

A. 8

B. 10

C. 15

D. 25

02. 在待排序的元素序列基本有序的前提下，效率最高的排序算法是（）。

A. 直接插入排序

B. 简单选择排序

C. 快速排序

D. 归并排序

03. 在图书馆中，计算机类书籍区共有 12 列书架，书架上的书都是按照编号排列好的，其

中有些书被读者放错了地方，但通常不超过一个书架。未来将这些书重新放回正确的位置，应该采用何种排序算法？（）。

A. 堆排序

B. 直接插入排序

C. 归并排序

D. 简单选择排序

04. 对有  $n$  个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是（），在最好情况下所需的比较次数是（）。

A.  $n - 1$

B.  $n + 1$

C.  $n / 2$

D.  $n(n - 1) / 2$

05. 数据序列  $\{8,10,13,4,6,7,22,2,3\}$  只能是（）两趟排序后的结果。

A. 简单选择排序

B. 冒泡排序

C. 直接插入排序

D. 堆排序

06. 用直接插入排序算法对下列4个表进行（从小到大）排序，比较次数最少的是（）。

A. 94, 32, 40, 90, 80, 46, 21, 69

B. 21, 32, 46, 40, 80, 69, 90, 94

C. 32, 40, 21, 46, 69, 94, 90, 80

D. 90, 69, 80, 46, 21, 32, 94, 40

07. 在下列算法中，（）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。

A. 堆排序

B. 冒泡排序

C. 直接插入排序

D. 快速排序

08. 希尔排序属于（）。

A. 插入排序

B. 交换排序

C. 选择排序

D. 归并排序

09. 对序列  $\{15, 9, 7, 8, 20, -1, 4\}$  采用希尔排序，经一趟后序列变为  $\{15, -1, 4, 8, 20, 9, 7\}$ ，则该次采用的增量是（）。

A. 1

B. 4

C. 3

D. 2

10. 若序列  $\{15, 9, 7, 8, 20, -1, 4\}$  经一趟排序后变成  $\{9, 15, 7, 8, 20, -1, 4\}$ ，则采用的是（）方法。

A. 选择排序

B. 快速排序

C. 直接插入排序

D. 冒泡排序

11. 对序列  $\{98, 36, -9, 0, 47, 23, 1, 8, 10, 7\}$  采用希尔排序，下列序列（）是增量为4的一趟排序结果。

A.  $\{10,7, - 9,0,47,23,1,8,98,36\}$

B.  $\{-9,0,36,98,1,8,23,47,7,10\}$

C.  $\{36, 98, -9, 0, 23, 47, 1, 8, 7, 10\}$

D. 以上都不对

12. 对序列  $\{\mathrm{E},\mathrm{A},\mathrm{S},\mathrm{Y},\mathrm{Q},\mathrm{U},\mathrm{E},\mathrm{S},\mathrm{T},\mathrm{I},\mathrm{O},\mathrm{N}\}$  按照字典顺序排序，采用增量  $d = 6,3,1$  的希尔排序算法。则前两趟排序后，关键字的总比较次数为（）。

A. 15

B. 17

C. 16

D. 18

13. 已知输入序列  $\{13, 24, 7, 1, 8, 9, 11, 56, 34, 51, 2, 77, 5\}$ ，增量序列  $d = 5, 3, 1$ ，采用希尔排序算法进行排序，则两趟排序后的结果为（）。

A. 1,7,8,9,13,24,11,34,51,2,5,56,77

B. 1,7,5,2,8,9,24,11,34,51,13,77,56

C. 2, 11, 5, 1, 8, 9, 24, 7, 34, 51, 13, 77, 56

D. 2,5,11,1,8,9,7,24,34,13,51,77,56

14. 折半插入排序算法的时间复杂度为（）。

A.  $O(n)$

B.  $O\left(n \log_2 n\right)$

C.  $O(n^{2})$

D.  $O\left(n^{3}\right)$

15. 有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（）算法不会出现此种情况。

A. 希尔排序

B. 堆排序

C. 冒泡排序

D. 快速排序

16. 以下排序算法中，不稳定的是（）。

A. 冒泡排序

B. 直接插入排序

C. 希尔排序

D. 归并排序

17. 以下排序算法中，稳定的是（）。

A. 快速排序

B. 堆排序

C. 直接插入排序

D. 简单选择排序

18.【2012统考真题】对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是（）。

A. 排序的总趟数

B. 元素的移动次数

C. 使用辅助空间的数量

D. 元素之间的比较次数

19.【2014统考真题】用希尔排序算法对一个数据序列进行排序时，若第一趟排序结果为9,1,4,13,7,8,20,23,15，则该趟排序采用的增量（间隔）可能是（）。

A. 2

B. 3

C. 4

D. 5

20.【2015统考真题】希尔排序的组内排序采用的是（）。

A. 直接插入排序

B. 折半插入排序

C. 快速排序

D. 归并排序

21.【2018统考真题】对初始数据序列(8,3,9,11,2,1,4,7,5,10,6)进行希尔排序。若第一趟排序结果为(1,3,7,5,2,6,4,9,11,10,8)，第二趟排序结果为(1,2,6,4,3,7,5,8,11,10,9)，则两趟排序采用的增量（间隔）依次是（）。

A. 3,1

B. 3,2

C. 5,2

D. 5, 3

# 二、综合应用题

01. 给出关键字序列  $\{4,5,1,2,6,3\}$  的直接插入排序过程。

02. 给出关键字序列  $\{50, 26, 38, 80, 70, 90, 8, 30, 40, 20\}$  的希尔排序过程（取增量序列为  $d = \{5, 3, 1\}$ ，排序结果为从小到大排列）。

# 8.2.5 答案与解析

# 一、单项选择题

01. B

直接插入排序在最坏的情况下要做  $n(n - 1) / 2$  次关键字的比较，当  $n = 5$  时，关键字的比较次数为10。注意不考虑与哨兵的比较。

02. A

序列初始基本有序，因此使用直接插入排序算法的时间复杂度接近  $O(n)$ ，而使用其他算法的时间复杂度均大于  $O(n)$ 。

03. B

大部分图书都是有序的，因此采用直接插入排序比较合适。

04. D、A

待排序表为反序时，直接插入排序需要进行  $n(n - 1) / 2$  次比较（从前往后依次需要比较  $1,2,\dots ,n - 1$  次）；待排序表为正序时，只需进行  $n - 1$  次比较。注意本题不考虑与哨兵的比较。

05.C

冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插入排序经过两趟排序后，前三个元素应该是局部有序的。只可能是插入排序。

# 注意

在排序过程中，每趟都能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。

# 06. B

越接近正序的序列，直接插入排序的比较次数就越少。选项B和C是比较接近正序的，然后分别判断两个序列的比较次数，以选项B为例：第一趟，插入32，比较1次；第二趟，插入46，比较1次；第三趟，插入40，因为40比46小但比32大，所以比较2次；第四趟，插入80，比较1次；第五趟，插入69，比较2次；以此类推，共比较9次。同理求出选项C的比较次数为11次。所以选择选项B。

# 07. C

在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终位置上。

# 08. A

希尔排序是对直接插入排序算法改进后提出来的，本质上仍属于插入排序的范畴。

# 09. B

希尔排序将序列分成若干组，记录只在组内进行交换。由观察可知，经过一趟后9和-1交换，7和4交换，可知增量为4。

# 10. C

前两个元素已经局部有序，很明显一趟直接插入排序算法有效。再排除其他算法即可。

# 11. A

增量为4意味着所有相距为4的记录构成一组，然后在组内进行直接插入排序，经观察，只有选项A满足要求。

# 12. B

第一趟：EE为一组，比较；AS为一组，比较；ST为一组，比较；YI为一组，比较后交换；QO为一组，比较后交换；UN为一组，比较后交换，结果为EASONESTYQU。第二趟：EIEY为一组，用直接插入排序需要依次比较I和E、E和I、E和E、Y和I；AOSQ为一组，依次比较O和A、S和O、Q和S、Q和O；SNTU为一组，依次比较N和S、T和S、U和T。第一趟比较次数为6，第二趟比较次数为11，总比较次数为17。

# 13. B

第一趟增量  $d = 5$  ，第一趟排序后，结果为2,11,5,1,8,9,24,7,34,51,13,77,56。第二趟增量  $d = 3$  ，第二趟排序后，结果为1,7,5,2,8,9,24,11,34,51,13,77,56。

# 14.C

虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发生变化，时间复杂度仍为  $O(n^{2})$ 。

# 15. A

因为希尔排序是基于插入排序算法提出的，所以它不一定在每趟排序过程后将某一元素放置到最终位置上。

# 16. C

希尔排序是一种复杂的插入排序算法，它是一种不稳定的排序算法。

# 17. C

基于插入、交换、选择的三类排序算法中，通常简单方法是稳定的（直接插入、折半插入、冒泡），但有一个例外就是简单选择，复杂方法都是不稳定的（希尔排序、快速排序、堆排序）。

# 18. D

折半插入排序与直接插入排序都将待插入元素插入前面的有序子表，区别是：确定当前记录在前面有序子表中的位置时，直接插入排序采用顺序查找法，而折半插入排序采用折半查找法。

排序的总趟数取决于元素个数  $n$ ，两者都是  $n - 1$  趟。元素的移动次数都取决于初始序列，两者相同。使用辅助空间的数量也都是  $O(1)$  。折半插入排序的比较次数与序列初态无关，时间复杂度为  $O(n\log_2n)$ ；而直接插入排序的比较次数与序列初态有关，时间复杂度为  $O(n)\sim O(n^{2})$ 。

# 19. B

首先，第二个元素为1，是整个序列中的最小元素，可知该希尔排序为从小到大排序。然后考虑增量问题，若增量为2，则第  $1 + 2$  个元素4明显比第1个元素9要小，排除选项A。若增量为3，则第  $i, i + 3, i + 6 (i = 1, 2, 3)$  个元素都为有序序列，符合希尔排序的特点。若增量为4，则第1个元素9比第  $1 + 4$  个元素7要大，排除选项C。若增量为5，则第1个元素9比第  $1 + 5$  个元素8要大，排除选项D。

# 20. A

希尔排序的思想是：先将待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

# 21. D

如下图所示。

初始序列：8.3，9，11、2、1，4.7，5，10、6

第一趟：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/102050b33d2600f9e19e39c60bc54ce73a0613b195aac13c6b2ec5fd2aca49ba.jpg)


第二趟：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5e63626e0f836543e50f39b419fdc86b39f3e229f3ec15f84299914d2362f337.jpg)


第一趟分组：8,1,6；3,4；9,7；11,5；2,10；间隔为5，排序后组内递增。

第二趟分组：1,5,4,10；3,2,9,8；7,6,11；间隔为3，排序后组内递增。

因此，选择选项D。

# 二、综合应用题

# 01.【解答】

直接插入排序过程如下。

初始序列： 4,5,1,2,6,3

第一趟： 4,5,1,2,6,3 （将5插入{4}）

第二趟： 1,4,5,2,6,3 （将1插入{4,5}）

第三趟： 1,2,4,5,6,3 （将2插入{1,4,5}）

第四趟： 1,2,4,5,6,3 （将6插入{1,2,4,5}）

第五趟： 1,2,3,4,5,6 （将3插入{1,2,4,5,6}）

# 02.【解答】

原始序列： 50,26,38,80,70,90,8,30,40,20

第一趟（增量5）： 50,8,30,40,20,90,26,38,80,70

第二趟（增量3）： 26,8,30,40,20,80,50,38,90,70

第三趟（增量1）： 8,20,26,30,38,40,50,70,80,90

# 8.3 交换排序

所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，一般很少直接考查，通常会重点考查快速排序算法的相关内容。

# 8.3.1 冒泡排序

冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序(A[i-1]  $\rightharpoondown$  A[i])，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般逐渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置……这样最多做  $n - 1$  趟冒泡就能把所有元素排好序。

图8.3所示为冒泡排序的过程，第一趟冒泡时：  $27 < \overline{49}$  ，不交换；  $13 < 27$  ，不交换；  $76 > 13$  ，交换；  $97 > 13$  ，交换；  $65 > 13$  ，交换；  $38 > 13$  ，交换；  $49 > 13$  ，交换。通过第一趟冒泡后，最小元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/335938be77db9943eca79492caf53c99922fe4ce18079ba5e6774f8263932e23.jpg)



图8.3 冒泡排序示例


冒泡排序算法的代码如下：

```txt
void BubbleSort(ElemType A[],int n){  
    for(int i=0;i<n-1;i++) {  
        bool flag=false; //表示本趟冒泡是否发生交换的标志  
        for(int j=n-1;j>i;j--) //一趟冒泡过程  
            if(A[j-1]>A[j]) { //若为逆序 swap(A[j-1],A[j]); //使用封装的 swap 函数交换①  
            flag=true;  
        }  
    ifflag=false)  
        return; //本趟遍历后没有发生交换，说明表已经有序}
```

冒泡排序的性能分析如下：

空间效率：仅使用了常数个辅助单元，因而空间复杂度为  $O(1)$ 。

时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false(本趟没有元素交换)，

从而直接跳出循环，比较次数为  $n - 1$ ，移动次数为0，从而最好情况下的时间复杂度为  $O(n)$ ；当初始序列为逆序时，需要进行  $n - 1$  趟排序，第  $i$  趟排序要进行  $n - i$  次关键字的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下，

比较次数  $= \sum_{i = 1}^{n - 1}(n - i) = \frac{n(n - 1)}{2}$  移动次数  $= \sum_{i = 1}^{n - 1}3(n - i) = \frac{3n(n - 1)}{2}$

从而，最坏情况下的时间复杂度为  $O(n^{2})$  ，平均时间复杂度为  $O(n^{2})$  。

稳定性：  $i > j$  且  $\mathsf{A}[i] = \mathsf{A}[j]$  时，不会发生交换，因此冒泡排序是一种稳定的排序算法。

适用性：冒泡排序适用于顺序存储和链式存储的线性表。

# 注意

冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。

# 8.3.2 快速排序

# 命题追踪 快速排序的思想（2024）

快速排序的基本思想：在待排序表 L[1...n]中任取一个元素 pivot 作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分 L[1...k-1]和 L[k+1...n]，使得 L[1...k-1]中的所有元素小于 pivot，L[k+1...n]中的所有元素大于或等于 pivot，则 pivot 放在了其最终位置 L(k) 上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。

一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针i和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。

指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4e23c38873af48bd9fd9fb6b6b4f7158f05b60007c521133392d337238232bf1.jpg)


指针i从low往后搜索找到第一个大于枢轴的元素65，将65交换到j所指位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ef97666b9db59ac631f3bb2d28eeedd70013c5599b4f94f960d2327c56ba1c3d.jpg)


指针j继续往前搜索找到小于枢轴的元素13，将13交换到i所指位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/aaf1006c3c77d06ec0fb5628dd266ef59e783f6a9e9727efa6eb61b884f5568b.jpg)


指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cf391073c00f71da66dd4f51a67e6c3decca7654243140d1951daa94b1fdfc0f.jpg)


指针j继续往前搜索小于枢轴的元素，直至  $\mathrm{i} = =\mathrm{j}$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/766152f4af91fae147eba4bb2d2c045f463671815ea7999d723660fab389bc38.jpg)


# 命题追踪 快速排序的中间过程的分析（2014、2019、2023）

此时，指针i（ $==j$ ）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放在  $i$  所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。

第一趟后： {27 38 13} 49 {76 97 65 49}

按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。

<table><tr><td>第二趟后:</td><td>\( \{ {13}\} \)</td><td>27</td><td>\( \{ {38}\} \)</td><td>49</td><td>\( \{ \overline{49}\} \)</td><td>65</td><td>76</td><td>\( \{ {97}\} \)</td></tr><tr><td>第三趟后:</td><td>13</td><td>27</td><td>38</td><td>49</td><td>\( \overline{49} \)</td><td>\( \{ {65}\} \)</td><td>76</td><td>97</td></tr><tr><td>第四趟后:</td><td>13</td><td>27</td><td>38</td><td>49</td><td>\( \overline{49} \)</td><td>65</td><td>76</td><td>97</td></tr></table>

用二叉树的形式描述这个快速排序示例的递归调用过程，如图8.4所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6edf6d23044fc04bffe8c4cd4c7ecb8f647ceea60f64f7707f45b9a6ef8273cd.jpg)



(a)第一层快排处理后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/83ef936cd4b1548ae7155b48fcc07f6f4c663aa90dada6d5998e614976d03e4a.jpg)



(b)第二层快排处理后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bd8666aac445f8633f1e09c6ed7e5b4668904a49562364d6c65101d1fa44de56.jpg)



(c)第三层快排处理后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/cdd99e5230ed2ba904b4fe44a58d2c9dd5c32749dbc9dcf62196280afddf4301.jpg)



(d)第四层快排处理后：最终结果



图8.4 快速排序的递归执行过程


假设划分算法已知，记为 Partition()，返回的是上述的 k，则 L(k) 已放在其最终位置。因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：

```javascript
void QuickSort(ElemType A[],int low,int high){if(low<high){//递归跳出的条件//Partition()就是划分操作，将表A[low…high]划分为满足上述条件的两个子表int pivotpos=Partition(A,low,high); //划分QuickSort(A,low,pivotpos-1);//依次对两个子表进行递归排序QuickSort(A,pivotpos+1,high);1}
```

# 命题追踪 （算法题）快速排序中划分操作的应用（2016）

快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟 Partition() 操作后，表中的元素被枢轴一分为二。代码如下：

```txt
int Partition(ElemType A[], int low, int high) { //一趟划分ElemType pivot=A[low]; //将当前表中第一个元素设为枢轴，对表进行划分
```

```javascript
while(low<high){ //循环跳出条件 while(low<high&&A[high]  $\coloneqq$  pivot）--high; A[low]=A[high]; //将比枢轴小的元素移动到左端 while(low<high&&A[low]  $<   =$  pivot）++low; A[high]=A[low]；//将比枢轴大的元素移动到右端 } A[low]=pivot; //枢轴元素存放到最终位置 return low; //返回存放枢轴的最终位置
```

快速排序算法的性能分析如下：

# 命题追踪 快速排序中递归次数的影响因素分析（2010）

空间效率：快速排序是递归的，因此需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大层数一致。最好情况下为  $O(\log_2n)$  ；最坏情况下，要进行  $n - 1$  次递归调用，因此栈的深度为  $O(n)$  ；平均情况下，栈的深度为  $O(\log_2n)$  。

时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含  $n - 1$  个元素和0个元素时，这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为  $O(n^{2})$ 。

有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。

在最理想的状态下，即 Partition() 能做到最平衡的划分，得到的两个子问题的大小都不可能大于  $n / 2$ ，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为  $O(n\log_2n)$ 。好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。

稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序算法。例如，表  $L = \{3,2,2\}$ ，经过一趟排序后  $L = \{2,2,3\}$ ，最终排序序列也是  $L = \{2,2,3\}$ ，显然，2与2的相对次序已发生了变化。

# 命题追踪 快速排序适合采用的存储方式（2011）

适用性：快速排序仅适用于顺序存储的线性表。

# 注意

在快速排序算法中，并不产生有序子序列，但每一趟排序后会将上一趟划分的各个无序子表的枢轴（基准）元素放到其最终的位置上。

# 8.3.3 本节试题精选

# 一、单项选择题

01. 对  $n$  个不同的元素利用冒泡法从小到大排序，在（）情况下元素交换的次数最多。

A. 从大到小排列好的

B. 从小到大排列好的

C. 元素无序

D. 元素基本有序

02. 若用冒泡排序算法对序列{10, 14, 26, 29, 41, 52}从大到小排序，则需进行（）次比较。

A. 3

B. 10

C. 15

D. 25

03. 用某种排序算法对线性表{25,84,21,47,15,27,68,35,20}进行排序时，元素序列的变化情况如下：

1）25,84,21,47,15,27,68,35,20

2）20,15,21,25,47,27,68,35,84

3）15,20,21,25,35,27,47,68,84

4）15,20,21,25,27,35,47,68,84

则所采用的排序算法是（）。

A. 选择排序

B. 插入排序

C. 二路归并排序

D. 快速排序

04. 一组记录的关键码为(46, 79, 56, 38, 40, 84)，则利用快速排序算法，以第一个记录为基准，从小到大得到的一次划分结果为（）。

A. (38, 40, 46, 56, 79, 84)

B. (40, 38, 46, 79, 56, 84)

C. (40, 38, 46, 56, 79, 84)

D. (40, 38, 46, 84, 56, 79)

05. 快速排序算法在（）情况下最不利于发挥其长处。

A. 要排序的数据量太大

B. 要排序的数据中含有多个相同值

C. 要排序的数据个数为奇数

D. 要排序的数据已基本有序

06. 就平均性能而言，目前最好的内部排序算法是（）。

A. 冒泡排序

B. 直接插入排序

C. 希尔排序

D. 快速排序

07. 数据序列  $F = \{2, 1, 4, 9, 8, 10, 6, 20\}$  只能是下列排序算法中的（）两趟排序后的结果。

A. 快速排序

B. 冒泡排序

C. 选择排序

D. 插入排序

08. 对元素序列  $\{8, 9, 10, 4, 5, 6, 20, 1, 2\}$  采用冒泡排序（从后往前次序进行，要求升序），需要进行元素交换的趟数至少是（）（不考虑无元素交换的最后一趟）。

A. 3

B. 4

C. 5

D. 8

09. 双向冒泡排序是指对一个序列在正反两个方向交替进行扫描，第一趟把最大值放在序列的最右端，第二趟把最小值放在序列的最左端，之后在缩小的范围内进行同样的扫描，放在次右端、次左端，直至序列有序。对数组{4,7,8,3,5,6,10,9,1,2}进行双向冒泡排序，则排序趟数是（）。（第一趟从左往右开始，从左往右或从右往左都称为一趟。）

A. 7

B. 6

C. 8

D. 9

10. 对下列关键字序列用快速排序进行排序时，每次选取的基准元素都为待处理序列的第一个元素，速度最快的情形是（），速度最慢的情形是（）。

A.  $\{21, 25, 5, 17, 9, 23, 30\}$

B.  $\{25, 23, 30, 17, 21, 5, 9\}$

C.  $\{21, 9, 17, 30, 25, 23, 5\}$

D.  $\{5, 9, 17, 21, 23, 25, 30\}$

11. 对下列4个序列，以第一个关键字为基准用快速排序算法进行排序，在第一趟过程中移动记录次数最多的是（）。

A. 92, 96, 88, 42, 30, 35, 110, 100

B. 92, 96, 100, 110, 42, 35, 30, 88

C. 100, 96, 92, 35, 30, 110, 88, 42

D. 42, 30, 35, 92, 100, 96, 88, 110

12. 下列序列中，（）可能是执行第一趟快速排序后所得到的序列（按从大到小排序和从小到大排序来分别讨论）。

I.  $\{68,11,18,69,23,93,73\}$

II.  $\{68,11,69,23,18,93,73\}$

III.  $\{93,73,68,11,69,23,18\}$

IV. {68, 11, 69, 23, 18, 73, 93}

A. I、IV

B. II、III

C. III、IV

D. 只有 IV

13. 对  $n$  个关键字进行快速排序，最大递归深度为（），最小递归深度为（）。

A. 1

B.  $n$

C.  $\log_2 n$

D.  $n \log_2 n$

14. 对8个元素的序列进行快速排序，在最好情况下的关键字比较次数是（）。

A. 7

B. 8

C. 12

D. 13

15.【2010统考真题】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是（）。

A. 递归次数与初始数据的排列次序无关

B. 每次划分后, 先处理较长的分区可以减少递归次数

C. 每次划分后, 先处理较短的分区可以减少递归次数

D. 递归次数与每次划分后得到的分区的处理顺序无关

16.【2011统考真题】为实现快速排序算法，待排序序列宜采用的存储方式是（）。

A. 顺序存储

B. 散列存储

C. 链式存储

D. 索引存储

17.【2014统考真题】下列选项中，不可能是快速排序第二趟排序结果的是（）。

A.  $2,3,5,4,6,7,9$

B. 2, 7, 5, 6, 4, 3, 9

C.  $3,2,5,4,7,6,9$

D.  $4,2,3,5,7,6,9$

18.【2019统考真题】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟。下列序列中，不可能是快速排序第二趟结果的是（）。

A. 5,2,16,12,28,60,32,72

B. 2, 16, 5, 28, 12, 60, 32, 72

C. 2, 12, 16, 5, 28, 32, 72, 60

D. 5,2,12,28,16,32,72,60

19.【2023统考真题】使用快速排序算法对数据进行升序排序，若经过一次划分后得到的数据序列是68,11,70,23,80,77,48,81,93,88，则该次划分的枢轴是（）。

A. 11

B. 70

C. 80

D. 81

20.【2024统考真题】使用快速排序算法对含  $n$  （  $n\geqslant 3$  ）个元素的数组  $M$  进行排序，若第一趟排序将  $M$  中除枢轴外的  $n - 1$  个元素划分为均不为空的  $P$  和  $Q$  两块，则下列叙述中，正确的是（）。

A.  $P$  与  $Q$  块间有序

B.  $P$  与  $Q$  均块内有序

C.  $P$  和  $Q$  的元素个数大致相等

D.  $P$  中和  $Q$  中均不存在相等的元素

# 二、综合应用题

01. 已知线性表按顺序存储，且每个元素都是不相同的整数型元素，设计把所有奇数移动到所有偶数前边的算法（要求时间最短，辅助空间最小）。

02. 试编写一个算法，使之能够在数组  $\mathbb{L}[1\dots n]$  中找出第  $k$  小的元素（从小到大排序后处于第  $k$  个位置的元素）。

03. 荷兰国旗问题：设有一个仅由红、白、蓝三种颜色的条块组成的条块序列，存储在一个顺序表中，请编写一个时间复杂度为  $O(n)$  的算法，使得这些条块按红、白、蓝的顺序排好，即排成荷兰国旗图案。请完成算法实现：

typedef enum{RED，WHITE，BLUE} color; //设置枚举数组void Flag_Arrange(color a[],int n){...}

04.【2016统考真题】已知由  $n(n\geqslant 2)$  个正整数构成的集合  $A = \{a_{k}|0\leqslant k < n\}$ ，将其划分为两个不相交的子集  $A_{1}$  和  $A_{2}$ ，元素个数分别是  $n_1$  和  $n_2$ ， $A_{1}$  和  $A_{2}$  中的元素之和分别为  $S_{1}$  和  $S_{2}$ 。设计一个尽可能高效的划分算法，满足  $|n_1 - n_2|$  最小且  $|S_{1} - S_{2}|$  最大。要求：

1）给出算法的基本设计思想。

2）根据设计思想，采用C或  $\mathrm{C + + }$  语言描述算法，关键之处给出注释。

3）说明所设计算法的平均时间复杂度和空间复杂度。

# 8.3.4 答案与解析

# 一、单项选择题

# 01. A

冒泡排序最少进行1趟冒泡，最多进行  $n - 1$  趟冒泡。初始序列为逆序时，需进行  $n - 1$  趟冒泡，并且元素交换的次数最多。初始序列为正序时，进行1趟冒泡（无交换）就可结束算法。

# 02. C

冒泡排序始终在调整“逆序”，因此交换次数为排列中逆序的个数。对逆序序列进行冒泡排序，每个元素向后调整时都需要进行比较，因此共需要比较  $5 + 4 + 3 + 2 + 1 = 15$  次。

# 03. D

选择排序在每趟结束后可以确定一个元素的最终位置，不对。插入排序，第  $i$  趟后前  $i + 1$  个元素应该是有序的，不对。第二趟  $\{20,15\}$  和  $\{21,25\}$  是反序的，因此不是归并排序。快速排序每趟都将基准元素放在其最终位置，然后以它为基准将序列划分为两个子序列。观察题中的排序过程，可知是快速排序。

# 04. C

以46为基准元素，首先从后往前扫描比46小的元素，并与之进行交换，而后从前往后扫描比46大的元素并将46与该元素交换，得到(40,46,56,38,79,84)。此后，继续重复从后往前扫描与从前往后扫描的操作，直到46处于最终位置。

# 05. D

当待排序数据为基本有序时，每次选取第  $n$  个元素为基准，会导致划分区间分配不均匀，不利于发挥快速排序算法的优势。相反，当待排序数据分布较为随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发挥快速排序的优势。

# 06. D

这里问的是平均性能，选项A、B的平均性能都会达到  $O(n^{2})$  ，而希尔排序虽然大大降低了直接插入排序的时间复杂度，但其平均性能不如快速排序。另外，虽然众多排序算法的平均时间复杂度也是  $O(n\log_2n)$  ，但快速排序算法的常数因子是最小的。

# 07. A

若为插入排序，则前三个元素应该是有序的，显然不对。而冒泡排序和选择排序经过两趟排序后应该有两个元素处于最终位置（最左/右端），无论是按从小到大还是从大到小排序，数据序列中都没有两个满足这样的条件的元素，因此只可能选择选项A。

【另解】先写出排好序的序列，并和题中的序列做对比。

题中序列：2 1 4 9 8 10 6 20

已排好序序列：1 2 4 6 8 9 10 20

在已排好序的序列中，与题中序列相同的元素有4、8和20，最左和最右两个元素与题中的序列不同，所以不可能是冒泡排序、选择排序或插入排序。

# 08. C

从后往前冒泡的过程为，第一趟  $\{1,8,9,10,4,5,6,20,2\}$ ，第二趟  $\{1,2,8,9,10,4,5,6,20\}$ ，第三趟  $\{1,2,4,8,9,10,5,6,20\}$ ，第四趟  $\{1,2,4,5,8,9,10,6,20\}$ ，第五趟  $\{1,2,4,5,6,8,9,10,20\}$ ，经过第五趟冒泡后，序列已经全局有序，因此选择选项C。实际每趟冒泡发生交换后可以判断是否会产生新的逆序对，若不会产生，则本趟冒泡之后序列全局有序，所以最少5趟即可。

# 09. B

第一趟从左往右的排序结果为4,7,3,5,6,8,9,1,2,10；第二趟从右往左的排序结果为1,4,7,3,5,6,8,9,2,10；第三趟从左往右的排序结果为1,4,3,5,6,7,8,2,9,10；第四趟从右往左的排序结果为1,2,4,3,5,6,7,8,9,10；第五趟从左往右的排序结果为1,2,3,4,5,6,7,8,9,10，此时序列已有序，但仍需进行一趟无交换的排序才能确定序列已有序，因此共需6趟排序。

# 10. A、D

当每趟的枢轴值都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或逆序时，速度最慢。选项D中的序列已按关键字排好序，因此它是最慢的，而选项A中第一趟枢轴值21将表划分为两个子表{9,17,5}和{25,23,30}，而后对两个子表划分时，枢轴值再次将它们等分，所以该序列是快速排序最优的情况，速度最快。针对其他选项，可以进行类似的分析。

# 11. B

对各序列分别执行一趟快速排序，可做如下分析（以选项A为例）：枢轴值为92，因此35移动到第一个位置，96移动到第六个位置，30移动到第二个位置，再将枢轴值移动到30所在的单元，即第五个位置，所以选项A中序列移动的次数为4。同样，可以分析出选项B中序列的移动次数为8，选项C中序列的移动次数为4，选项D中序列的移动次数为2。

# 12. C

显然，若按从小到大排序，则最终有序的序列是  $\{11, 18, 23, 68, 69, 73, 93\}$ ；若按从大到小排序，则最终有序的序列是  $\{93, 73, 69, 68, 23, 18, 11\}$ 。对比可知选项 I、II 中没有处于最终位置的元素，所以选项 I、II 都不可能。选项 III 中 73 和 93 处于从大到小排序后的最终位置，而且 73 将序列分割成大于 73 和小于 73 的两部分，所以选项 III 是有可能的。选项 IV 中 73 和 93 处于从小到大排列后的最终位置，73 也将序列分割成大于 73 和小于 73 的两部分。

# 13. B、C

快速排序过程构成一个递归树，递归深度即递归树的高度。枢轴值每次都将子表等分时，递归树的高为  $\log_2n$ ；枢轴值每次都是子表的最大值或最小值时，递归树退化为单链表，树高为  $n$ 。

# 14. D

快速排序的最好情况是每次划分将待排序列划分为等长的两部分。因此，第一趟将第1个元素与后面的7个元素进行比较，将原序列划分为长度为3和4的两个子表，比较7次；第二趟对两个子表进行划分，将长度为3的子表划分为长度为1的两个子表（不用继续划分），比较2次，将长度为4的子表划分为长度为1和2的两个子表，比较3次；第三趟将长度为2的子表划分为长度为1的子表，比较1次。至此，排序结束，共进行的比较次数是  $7 + 2 + 3 + 1 = 13$

# 15. D

快速排序的递归次数与元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少；  
若划分后分区不平衡，则递归次数多。递归次数与分区处理顺序无关。

# 16. A

对于绝大部分内部排序而言，只适用于顺序存储结构。快速排序在排序的过程中，既要从后往前查找，也要从前往后查找，因此宜采用顺序存储。

# 17. C

对  $n$  个元素进行第一趟快速排序后，会确定一个基准元素，根据这个基准元素在数组中的位置，有两种情况：①基准元素在数组的首端或尾端，接下来对剩下的  $n - 1$  个元素构成的子序列进行第二趟快速排序，再确定一个基准元素。这样，在两趟排序后就至少能确定两个元素的最终位

置，其中至少有一个元素是在数组的首端或尾端。②基准元素不在数组的首端或尾端，第二趟快速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这样，两趟排序后就至少能确定三个元素的最终位置。基于上述结论，观察题中的四个选项，选项A的2,3,6,7,9符合第一种或第二种情况；选项B中2,9符合第一种情况；选项D中5,9符合第一种情况；最后看选项C，只有9处于最终位置，因此不可能是快速排序第二趟的结果。

# 18. D

基于上题中分析得出的结论，观察题中的四个选项，选项A的28,72符合第一种情况；选项B的2,72符合第一种情况；选项C的2,28,32符合第一种或第二种情况；最后看选项D，只有12和32处于最终位置，既不符合第一种情况，又不符合第二种情况。

# 19. D

第一趟划分后得到的序列中只有一个枢轴，因此可将当前序列和最终排好序的序列进行比较，如下表所示。枢轴会出现在两个序列的相同位置，可以看出枢轴只可能是77、81，选项只有81。在当前序列中，77左边有比它大的元素80，因此77不是枢轴；而81左边都是比它小的元素，右边都是比它大的元素，因此81是枢轴。

<table><tr><td>当前序列</td><td>68</td><td>11</td><td>70</td><td>23</td><td>80</td><td>77</td><td>48</td><td>81</td><td>93</td><td>88</td></tr><tr><td>最终序列</td><td>11</td><td>23</td><td>48</td><td>68</td><td>70</td><td>77</td><td>80</td><td>81</td><td>88</td><td>93</td></tr></table>

# 20. A

依题意，对数组  $M$  进行第一趟快速排序后，会将  $M$  划分为三部分：小于枢轴值的块  $P$  ，枢轴元素，大于枢轴值的块  $Q$  。  $P$  和  $Q$  块内都是无序的，但是  $P$  块内的数据  $\leqslant$  枢轴值，  $Q$  块内的数据  $\geqslant$  枢轴值，因此  $P$  块内的数据  $\leqslant Q$  块内的数据，即  $P$  与  $Q$  块间有序。

# 二、综合应用题

# 01.【解答】

本题可采用基于快速排序的划分思想来设计算法，只需遍历一次即可，其时间复杂度为  $O(n)$  空间复杂度为  $O(1)$  。假设表为  $\mathsf{L}[1\dots \mathsf{n}]$  ，基本思想是：先从前往后找到一个偶数元素  $\mathsf{L}(\mathsf{i})$  ，再从后往前找到一个奇数元素  $\mathsf{L}(\mathsf{j})$  ，将二者交换；重复上述过程直到  $\dot{\mathbf{i}}$  大于j。

算法的实现如下：

```javascript
void move(ElemType A[],int len){  
//对表A按奇偶进行一趟划分  
int i=0,j=len-1; //i表示左端偶数元素的下标；j表示右端奇数元素的下标  
while(i<j) {  
    while(i<j&&A[i]%2!=0) i++; //从前往后找到一个偶数元素  
    while(i<j&&A[j]%2!=1) j--; //从后往前找到一个奇数元素  
    if (i<j) {  
        Swap(A[i],A[j]); //交换这两个元素  
    i++; j--;  
}  
}
```

# 02.【解答】

显然，本题最直接的做法是用排序算法对数组先进行从小到大的排序，然后直接提取  $\mathbb{L}(\mathbf{k})$  便得到了第  $k$  小的元素，但其平均时间复杂度将达到  $O(n\log_2n)$  以上。此外，还可采用小顶堆的方法，每次堆顶元素都是最小值元素，时间复杂度为  $O(n + k\log_2n)$  。下面介绍一个更精彩的算法，它基于快速排序的划分操作。

这个算法的主要思想如下：从数组L[1..n]中选择枢轴pivot（随机或直接取第一个）进行和

快速排序一样的划分操作后，表 L[1..n] 被划分为 L[1..m-1] 和 L[m+1..n]，其中 L(m) = pivot。

讨论  $m$  与  $k$  的大小关系：

1）当  $m = k$  时，显然pivot就是所要寻找的元素，直接返回pivot即可。

2）当  $m < k$  时，所要寻找的元素一定落在  $\mathsf{L}[\mathsf{m} + 1\dots \mathsf{n}]$  中，因此可对  $\mathsf{L}[\mathsf{m} + 1\dots \mathsf{n}]$  递归地查找第  $k - m$  小的元素。

3）当  $m > k$  时，所要寻找的元素一定落在  $\mathsf{L}[1\dots \mathsf{m} - 1]$  中，因此可对  $\mathsf{L}[1\dots \mathsf{m} - 1]$  递归地查找第  $k$  小的元素。

该算法的时间复杂度在平均情况下可以达到  $O(n)$ ，而所占空间的复杂度则取决于划分的方法。算法的实现如下：

```c
int kth_element(int a[], int low, int high, int k) {
    int pivot = a[low];
    int low_temp = low; //由于下面会修改 low 与 high，在递归时又要用到它们
    int high_temp = high;
    while (low < high) {
        while (low < high && a[high] >= pivot)
            --high;
        a[low] = a[high];
        while (low < high && a[low] <= pivot)
            ++low;
        a[high] = a[low];
    }
    a[low] = pivot;
    //上面为快速排序中的划分算法
    //以下是本算法思想中所述的内容
    if (low == k) //由于与 k 相同，直接返回 pivot 元素
        return a[low];
    else if (low > k) //在前一部分表中递归寻找
        return kth_element(a, low_temp, low - 1, k);
    else //在后一部分表中递归寻找
        return kth_element(a, low + 1, high_temp, k);
}
```

# 03.【解答】

算法思想：顺序扫描线性表，将红色条块交换到线性表的最前面，蓝色条块交换到线性表的最后面。为此，设立三个指针，其中，  $j$  为工作指针，表示当前扫描的元素，  $i$  以前的元素全部为红色，  $k$  以后的元素全部为蓝色。根据  $j$  所指示元素的颜色，决定将其交换到序列的前部或尾部。初始时  $i = 0$  ，  $k = n - 1$  ，算法的实现如下：

```txt
typedefenum{RED,WHITE,BLUE}color;//设置枚举数组  
voidFlag_Arrange(colora[]，intn){int  $\mathrm{i = 0,j = 0,k = n - 1}$  ·while(j<=k)switch(a[j]){//判断条块的颜色case RED:Swap(a[i],a[j]);i++;j++;break; //红色，则和i交换caseWHITE:j++;break;caseBLUE:Swap(a[j],a[k]）;k--；//蓝色，则和k交换//这里没有  $j + +$  语句，以防止交换后a[j]仍为蓝色1
```

例如，将元素值正数、负数和零排序为前面都是负数，接着是0，最后是正数，也用同样的

方法。思考：为什么 case RED 语句不用考虑交换后 a[j]仍为红色，而 case BLUE 语句中却需要考虑交换后 a[j]仍为蓝色？

# 04.【解答】

# 1）算法的基本设计思想

由题意可知，将最小的  $\lfloor n / 2\rfloor$  个元素放在  $A_{1}$  中，其余的元素放在  $A_{2}$  中，分组结果即可满足题目要求。仿照快速排序的思想，基于枢轴将  $n$  个整数划分为两个子集。根据划分后枢轴所处的位置  $i$  分别处理：

① 若  $i = \lfloor n / 2\rfloor$  ，则分组完成，算法结束。

$②$  若  $i <   \lfloor n / 2\rfloor$  ，则枢轴及之前的所有元素均属于  $A_{1}$  ，继续对  $i$  之后的元素进行划分。

$③$  若  $i > \lfloor n / 2\rfloor$  ，则枢轴及之后的所有元素均属于  $A_{2}$  ，继续对  $i$  之前的元素进行划分。

基于该设计思想实现的算法，无须对全部元素进行全排序，其平均时间复杂度是  $O(n)$ ，空间复杂度是  $O(1)$ 。

# 2）算法实现

```txt
int setPartition(int a[], int n) {
    int pivotkey, low = 0, low = 0, high = n - 1, high = n - 1, flag = 1, k = n / 2, i;
    int s1 = 0, s2 = 0;
    while (flag) {
        pivotkey = a[low]; //选择枢轴
        while (low < high) {
            while (low < high && a[high] >= pivotkey) --high;
            if (low != high) a[low] = a[high];
            while (low < high && a[low] <= pivotkey) ++low;
            if (low != high) a[high] = a[low];
        }
    }
    a[low] = pivotkey;
    if (low == k - 1)
        flag = 0;
    else {
        if (low < k - 1) {
            low0 = ++low;
            high = high0;
        }
    else {
        high0 = --high;
        low = low0;
    }
}
```

3）本算法的平均时间复杂度是  $O(n)$  ，空间复杂度是  $O(1)$

# 8.4 选择排序

选择排序的基本思想是：每一趟（如第  $i$  趟）在后面  $n - i + 1$  （ $i = 1,2,\dots,n - 1$ ）个待排序元素中选取关键字最小的元素，作为有序子序列的第  $i$  个元素，直到第  $n - 1$  趟做完，待排序元素只

剩下1个，就不用再选。选择排序中的堆排序是历年统考考查的重点。

# 8.4.1 简单选择排序

根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为L[1..n]，第  $i$  趟排序即从L[i..n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过  $n - 1$  趟排序就可使得整个排序表有序。

简单选择排序算法的过程较为简单，相关举例见本书配套课程，其代码如下：

```txt
void SelectSort(ElemType A[],int n){  
    for(int i=0;i<n-1;i++) { //一共进行n-1趟  
        int min=i; //记录最小元素位置  
        for(int j=i+1;j<n;j++) //在A[i..n-1]中选择最小的元素  
            if(A[j]<A[min]) min=j; //更新最小元素位置  
            if(min!=i) swap(A[i],A[min]); //封装的swap()函数共移动元素3次  
        }  
}
```

简单选择排序算法的性能分析如下：

空间效率：仅使用常数个辅助单元，所以空间效率为  $O(1)$ 。

时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过  $3(n - 1)$  次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是  $n(n - 1) / 2$  次，因此时间复杂度始终是  $O(n^{2})$ 。

稳定性：在第  $i$  趟找到最小元素后，和第  $i$  个元素交换，可能会导致第  $i$  个元素与含有相同关键字的元素的相对位置发生改变。例如，表  $L = \{2,2,1\}$ ，经过一趟排序后  $L = \{1,2,2\}$ ，最终排序序列也是  $L = \{1,2,2\}$ ，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳定的排序算法。

适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。

# 8.4.2 堆排序

堆的定义如下，  $n$  个关键字序列  $\mathbb{L}[1\dots n]$  称为堆，当且仅当该序列满足：

①  $\mathrm{L}(\mathrm{i})\geqslant \mathrm{L}(2\mathrm{i})$  且  $\mathrm{L}(\mathrm{i})\geqslant \mathrm{L}(2\mathrm{i} + 1)$  或

②  $\mathrm{L(i)}\leqslant \mathrm{L(2i)}$  且  $\mathrm{L(i)}\leqslant \mathrm{L(2i + 1)}$  （  $1\leqslant i\leqslant \lfloor n / 2\rfloor$

# 命题追踪 堆的性质与特点（2020）

可以将堆视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆），大根堆的最大元素存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件②的堆称为小根堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9c26b58cc2cb90575ea2bdffe469a74abb364f27571b177626a82a09bc51cf00.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/13f19ae77a877242421a4d70ab2576028eac0dfd11a65a69cf7e4c91fe370b45.jpg)



图8.5 一个大根堆示意图


最新408统考大纲增加了考点“堆的应用”，堆的应用只有两个：堆排序和优先队列（见本节综合题7)，优先队列也利用了堆排序的思想，因此本节仅介绍堆排序。

堆排序的思路很简单：首先将存放在 L[1..n] 中的  $n$  个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆排序需要解决两个问题：①如何将无序序列构造成初始堆？②输出堆顶元素后，如何将剩余元素调整成新的堆？

# 命题追踪 初始建堆的操作（2018、2021）

堆排序的关键是构造初始堆。建堆思路是从后往前检查所有分支结点，看是否满足堆的要求，若不满口，则对以该分支结点为根的子树进行调整。  $n$  个结点的完全二叉树，最后一个结点是第  $\lfloor n / 2\rfloor$  个结点的孩子。对以第  $\lfloor n / 2\rfloor$  个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点（  $\lfloor n / 2\rfloor -1\sim 1)$  为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。

如图8.6所示，初始时调整  $L(4)$  子树，  $09 < 32$  ，交换，交换后满足堆的定义；向前继续调整 $L(3)$  子树，  $78 <$  左右孩子的较大者87，交换，交换后满足堆的定义；向前调整  $L(2)$  子树，  $17 <$  左右孩子的较大者45，交换后满足堆的定义；向前调整至根结点  $L(1)$  ，  $53 <$  左右孩子的较大者87，交换，交换后破坏了  $L(3)$  子树的堆，采用上述方法对  $L(3)$  进行调整，  $53 <$  左右孩子的较大者78，交换，至此该完全二叉树满足堆的定义。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/281cb744baef248c613c31661919a26d178cab1d8d7a318f2c9cff80a5f09f9a.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/96de054a829323189d7406f5582dd6f05a785b128842c056f28ea093f3b84465.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a1a9163b3721ee568ae34c6fa64422d28bd69a6260e8307b0c33d89a52844e83.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9b2716dbf3c52716c01bc6ec54d3b090dcb549f74f1194dda27537d0aa4c766a.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f14e68891b4678e2f605856327f899b3d4285ca6351311f3c33f88827419c494.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fc0d2e129c86fa53ea3e2980bd29f0e784f015f108f4a220181675d9f3f9f888.jpg)



图8.6 自下往上逐步调整为大根堆


# 命题追踪 堆的删除操作及调整操作分析（2015、2024）

输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。将09和左右孩子的较大者78交换，交换后破坏了  $L(3)$  子树的堆，继续对  $L(3)$  子树向下筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/24f9dcdabacc574d6d6fcdb0e6fafaadb8ff64cd2a61fad3c8b0bda41b89c267.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/17e0cf06a865b1e20bd0fe2d1e7bb0b41d743513c2c15e9dad16446fdc96d1e2.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ad8e6a7ca74a830db1c7dd750dd863e69dfcc880abbfdbc371709e72ef47e6be.jpg)



图8.7 输出堆顶元素后再将剩余元素调整成新堆


下面是建立大根堆的算法：

```txt
void BuildMaxHeap(ElemType A[],int len){for(int i = len/2; i > 0; i --) //从  $i = [n / 2] \sim 1$  ，反复调整堆HeadAdjust(A, i, len);  
}  
void HeadAdjust(ElemType A[], int k, int len) {  
//函数HeadAdjust对以元素k为根的子树进行调整  
A[0] = A[k]; //A[0]暂存子树的根结点  
for(int i = 2 * k; i <= len; i *= 2) { //沿key较大的子结点向下筛选if(i < len && A[i] < A[i + 1])  
i++; //取key较大的子结点的下标  
if(A[0] >= A[i]) break; //筛选结束  
else{  
A[k] = A[i]; //将A[i]调整到双亲结点上  
k = i; //修改k值，以便继续向下筛选  
}  
}  
A[k] = A[0]; //被筛选结点的值放入最终位置  
}
```

调整的时间与树高有关，为  $O(h)$  。在建含  $n$  个元素的堆时，关键字的比较总次数不超过  $4n$  时间复杂度为  $O(n)$ ，这说明可以在线性时间内将一个无序数组建成一个堆。

下面是堆排序算法：

```javascript
void HeapSort(ElemType A[],int len){BuildMaxHeap(A,len); //初始建堆for(int i=len;i>1;i--）{ //n-1趟的交换和建堆过程Swap(A[i],A[1]); //输出堆顶元素（和堆底元素交换）HeadAdjust(A,1,i-1)； //调整，把剩余的i-1个元素整理成堆}  
} 公众号：小兔网盘免费分享无水印PDF
```

# 命题追踪 堆的插入操作及调整操作分析（2009、2011）

同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。大根堆的插入操作示例如图8.8所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4f139417daf7c25e1fd2bf246033c3019f66e879399b18f5b8251e415e16d9d1.jpg)



(a)初始，尾部加63


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0f5ed4e41c35cbf55e6a75c9dc714c47c97d9b7de524a3bcbdacd236bb0e2815.jpg)



(b)父结点关键字32下降


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/bb218bbf2c3439721a058189829ca21b3be7d0e8ce1858ae0c133baddddb8f14.jpg)



(c)父结点关键字45下降


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ed713bbe5ab18aa3ceaf8db7f9404c83e11e83921eebfc9b220b34081a296663.jpg)



(d)调整完成



图8.8 大根堆的插入操作示例


# 命题追踪 堆在海量数据中选出最小  $k$  个数的应用及效率分析（2022）

堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。

堆排序算法的性能分析如下：

空间效率：仅使用了常数个辅助单元，所以空间复杂度为  $O(1)$ 。

时间效率：建堆时间为  $O(n)$ ，之后有  $n - 1$  次向下调整操作，每次调整的时间复杂度为  $O(h)$ ，所以在最好、最坏和平均情况下，堆排序的时间复杂度为  $O(n\log_2n)$ 。

稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序算法。例如，表  $L = \{1,2,2\}$  ，构造初始堆时可能将2交换到堆顶，此时  $L = \{2,1,2\}$  最终排序序列为  $L = \{1,2,2\}$  ，显然，2与2的相对次序已发生变化。

适用性：堆排序仅适用于顺序存储的线性表。

# 8.4.3 本节试题精选

# 一、单项选择题

01. 在以下排序算法中，每次从未排序的记录中选取最小关键字的记录，加入已排序记录的末尾，该排序算法是（）。

A. 简单选择排序

B. 冒泡排序

C. 堆排序

D. 直接插入排序

02. 简单选择排序算法的比较次数和移动次数分别为（）。

A.  $O(n), O(\log_2 n)$

B.  $O\left(\log_2 n\right), O\left(n^{2}\right)$

C.  $O(n^{2}), O(n)$

D.  $O(n \log_2 n), O(n)$

03. 若只想得到 100000 个元素组成的序列中第 10 个最小元素之前的部分排序的序列, 用 (   ) 方法最快。

A. 冒泡排序

B. 快速排序

C. 归并排序

D. 堆排序

04. 下列（）是一个堆。

A. 19, 75, 34, 26, 97, 56

B. 97, 26, 34, 75, 19, 56

C. 19, 56, 26, 97, 34, 75

D. 19, 34, 26, 97, 56, 75

05. 在含有  $n$  个元素的小根堆中（下标从 1 开始），关键字最大的元素可能存储在（）位置。

A.  $n / 2$

B.  $n / 2 + 2$

C. 1

D.  $n / 2 - 1$

06. 向具有  $n$  个结点的堆中插入一个新元素的时间复杂度为（），删除一个元素的时间复杂度为（）。

A.  $O(1)$

B.  $O(n)$

C.  $O\left(\log_2 n\right)$

D.  $O\left(n \log_2 n\right)$

07. 构建  $n$  个记录的初始堆，其时间复杂度为（）；对  $n$  个记录进行堆排序，最坏情况下其时间复杂度为（）。

A.  $O(n)$

B.  $O(n^{2})$

C.  $O\left(\log_2 n\right)$

D.  $O\left(n \log_2 n\right)$

08. 下列4种排序算法中，排序过程中的比较次数与序列初始状态无关的是（）。

A. 简单选择排序

B. 直接插入排序

C. 快速排序

D. 冒泡排序

09. 对由相同的  $n$  个整数构成的二叉排序树和小根堆，下列说法中不正确的是（）。

A. 二叉排序树的高度大于或等于小根堆的高度

B. 对二叉排序树进行中序遍历可以得到从小到大的序列

C. 从小根堆的根结点到任意叶结点的路径构成从小到大的序列

D. 对小根堆进行层序遍历可以得到从小到大的序列

10. 有一组数据(15,9,7,8,20,-1,7,4)，用堆排序的筛选方法建立的初始小根堆为（）。

A.  $-1, 4, 8, 9, 20, 7, 15, 7$

B.  $-1, 7, 15, 7, 4, 8, 20, 9$

C.  $-1, 4, 7, 8, 20, 15, 7, 9$

D. A、B、C均不对

11. 对关键字序列  $\{23, 17, 72, 60, 25, 8, 68, 71, 52\}$  进行堆排序，输出两个最小关键字后的剩余堆是（）。

A.  $\{23,72,60,25,68,71,52\}$

B.  $\{23, 25, 52, 60, 71, 72, 68\}$

C.  $\{71, 25, 23, 52, 60, 72, 68\}$

D.  $\{23, 25, 68, 52, 60, 72, 71\}$

12. 堆排序分为两个阶段：第一阶段将给定的序列构造成一个初始堆，第二阶段逐次输出堆顶元素，并调整使其保持堆的性质。设有给定序列{48, 62, 35, 77, 55, 14, 35, 98}，若在堆排序的第一阶段将该序列构造成一个大根堆，则交换元素的次数为（）。

A. 5

B. 6

C. 7

D. 8

13. 已知大根堆  $\{62, 34, 53, 12, 8, 46, 22\}$ ，删除堆顶元素后需要重新调整堆，则在此过程中关键字的比较次数为（）。

A. 2

B. 3

C. 4

D. 5

14. 从根结点到任意叶结点的路径都是有序的数据结构是（）。

A. 红黑树

B. 二叉查找树

C. 哈夫曼树

D. 堆

15.【2009统考真题】已知关键字序列{5,8,12,19,28,20,15,22}是小根堆，插入关键字3，调整好后得到的小根堆是（）。

A. 3,5,12,8,28,20,15,22,19

B. 3,5,12,19,20,15,22,8,28

C.  $3,8,12,5,20,15,22,28,19$

D. 3, 12, 5, 8, 28, 20, 15, 22, 19

16.【2011统考真题】已知序列{25, 13, 10, 12, 9}是大根堆，在序列尾部插入新元素18，再将其调整为大根堆，调整过程中元素之间进行的比较次数是（）。

A. 1

B. 2

C. 4

D. 5

17.【2015统考真题】已知小根堆为8, 15, 10, 21, 34, 16, 12，删除关键字8之后需重建堆，在此过程中，关键字之间的比较次数是（）。

A. 1

B. 2

C. 3

D. 4

18.【2018统考真题】在将序列(6,1,5,9,8,4,7)建成大根堆时，正确的序列变化过程是（）。

A.  $6,1,7,9,8,4,5\to 6,9,7,1,8,4,5\to 9,6,7,1,8,4,5\to 9,8,7,1,6,4,5$

B.  $6, 9, 5, 1, 8, 4, 7 \rightarrow 6, 9, 7, 1, 8, 4, 5 \rightarrow 9, 6, 7, 1, 8, 4, 5 \rightarrow 9, 8, 7, 1, 6, 4, 5$

C.  $6, 9, 5, 1, 8, 4, 7 \rightarrow 9, 6, 5, 1, 8, 4, 7 \rightarrow 9, 6, 7, 1, 8, 4, 5 \rightarrow 9, 8, 7, 1, 6, 4, 5$

D.  $6, 1, 7, 9, 8, 4, 5 \rightarrow 7, 1, 6, 9, 8, 4, 5 \rightarrow 7, 9, 6, 1, 8, 4, 5 \rightarrow 9, 7, 6, 1, 8, 4, 5 \rightarrow 9, 8, 6, 1, 7, 4, 5$

19.【2020统考真题】下列关于大根堆（至少含2个元素）的叙述中，正确的是（）。

I. 可以将堆视为一棵完全二叉树

II. 可以采用顺序存储方式保存堆

III. 可以将堆视为一棵二叉排序树

IV. 堆中的次大值一定在根的下一层

A. 仅 I、II

B. 仅 II、III

C. 仅 I、II 和 IV

D. I、III 和 IV

20.【2021统考真题】将关键字6,9,1,5,8,4,7依次插入初始为空的大根堆H，得到的H是（）。

A. 9,8,7,6,5,4,1

B. 9,8,7,5,6,1,4

C. 9,8,7,5,6,4,1

D. 9,6,7,5,8,4,1

21.【2024统考真题】已知关键字序列28,22,20,19,8,12,15,5是大根堆（最大堆），对该堆

进行两次删除操作后，得到的新堆是（）。

A. 20, 19, 15, 12, 8, 5

B. 20, 19, 15, 5, 8, 12

C. 20, 19, 12, 15, 8, 5

D. 20, 19, 8, 12, 15, 5

# 二、综合应用题

01. 指出堆和二叉排序树的区别？

02. 画出一棵二叉树，使得它既满足大根堆的要求又满足二叉排序树的要求。

03. 若只想得到一个序列中第  $k(k\geqslant 5)$  个最小元素之前的部分的排序序列，则最好采用什么排序算法？

04. 通常使用的堆也称二叉堆，因为它是用完全二叉树来实现的，树中结点最多只有两个孩子。同理可以有  $m$  叉堆，即用完全  $m$  叉树来实现的堆。

1）下图是一个  $m$  叉小根堆，问  $m$  值是多少？向这个堆插入一个元素65后，堆中的元素如何变化？再删除堆顶元素呢？请画出变化后的树形。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2f484f31e4fb5412a954f35fdc287bdb39a87d291ef1671c2982b677d2e8573a.jpg)


2）从0开始对完全4叉树中的结点从左到右、从上到下进行编号。若给定一个结点  $k$  其父结点的编号是多少？（若存在），其第  $i(i = 1,2,3,4)$  个孩子的编号是多少？

3）在  $m$  叉堆中进行插入和删除操作的时间复杂度是多少？

05. 编写一个算法，在基于单链表表示的待排序关键字序列上进行简单选择排序。

06. 试设计一个算法，判断一个数据序列是否构成一个小根堆。

07. 优先队列（Priority Queue）是一种数据结构，它类似于普通队列，但每个元素都有一个优先级。元素在入队时会根据其优先级来排序，而不按照先入先出的顺序来排序。每次从优先队列中出队时，出队的是优先级最高的元素，而不是最早进入队列的元素。

队列中的元素的数据结构的定义如下：

```txt
typedef struct{ int value; //元素的值 int priority; //元素的优先级，priority越大，优先级越高 }PriorityQueueElement;
```

请设计一个优先队列，要求满足：①初始时队列为空；②入队时，不允许增加队列的占用空间；③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间不变；④入队操作和出队操作的时间复杂度始终保持为  $O(\log_2n)$  。请回答：

1）该队列是应选择链式存储结构，还是选择顺序存储结构？

2）给出优先队列的数据结构的定义。

3）用伪代码给出入队操作和出队操作的基本过程（关键之处可用文字描述）。

08.【2022统考真题】现有  $n(n > 100000)$  个数保存在一维数组M中，需要查找M中最小的10个数。请回答下列问题。

1）设计一个完成上述查找任务的算法，要求平均情况下的比较次数尽可能少，简述其算法思想（不需要编程实现）。

2）说明你所设计的算法平均情况下的时间复杂度和空间复杂度。

# 8.4.4 答案与解析

# 一、单项选择题

01. A

02.C

注意，读者应熟练掌握各种排序算法的思想、过程和特点。

03. D

采用堆排序时，读入前10个元素，建立含10个元素的大根堆，而后依次扫描剩余元素，若大于堆顶，则舍弃，否则用该元素取代堆顶并重新调整堆，当元素全部扫描完毕，堆中保存的即是最小的10个元素。冒泡排序需要从后往前执行10趟冒泡才能得到10个最小的元素。两者的时间复杂度都和数据规模  $n$  线性相关，但显然堆排序的常系数更小。而快速排序、归并排序的每一趟都不能保证得到当前序列的最小值，也无法达到线性时间复杂度。

04. D

可将每个选项中的序列表示成完全二叉树，再看父结点与子结点的关系是否全部满足堆的定义。例如，选项A中序列对应的完全二叉树如下图所示。显然，最小元素19在根结点，因此可能是小根堆，但75与26的关系却不满足小根堆的定义，所以选项A中的序列不是一个堆。其他选项采用类似的过程分析。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a816ce006270351e6f2510d80111f83a7b7a2da856ab0a8538f09b833cade106.jpg)


05. B

在小根堆中，关键字最大的元素一定存储在该堆所对应的完全二叉树的叶结点中（位于最底层或次底层）。又因为二叉树中的最后一个非叶结点存储在  $\lfloor n / 2\rfloor$  中，所以关键字最大的元素的存储范围为  $\lfloor n / 2\rfloor +1\sim n$  。注意，读者可类比在大根堆中求关键字最小的元素的存储范围。

06. C、C

在向有  $n$  个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减1，因为树的高度为  $\lfloor \log_2n\rfloor +1$  ，所以堆的向上调整算法的比较次数最多等于  $\lfloor \log_2n\rfloor$  此处需要注意，调整堆和建初始堆的时间复杂度是不一样的，读者可以仔细分析两个算法的具体执行过程。

07. A、D

建堆过程中，向下调整的时间与树高  $h$  有关，为  $O(h)$  。每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为  $n$  的序列上建堆，其时间复杂度为  $O(n)$  。无论是在最好情况下还是在最坏情况下，堆排序的时间复杂度均为  $O(n\log_2n)$  。

08. A

简单选择排序的比较次数始终为  $n(n - 1) / 2$  ，与序列状态无关。

09. D

堆是顺序存储的完全二叉树，因此其高度小于或等于结点数相同的二叉排序树，选项A正确。选项B显然正确。根据小根堆的定义，其根结点到任意叶结点的路径构成从小到大的序列，选项C正确。堆的各层结点之间没有大小要求，因此层序遍历不能保证得到有序序列，选项D错误。

# 10. C

从  $\lfloor n / 2\rfloor \sim 1$  依次筛选堆的过程如下图所示，显然选择选项C。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/749572cbc8aa3364a372f7cdf9730103f74d4e5863860dcab53fca1ab7a34c90.jpg)


# 11. D

筛选法初始建堆为  $\{8,17,23,52,25,72,68,71,60\}$ ，输出8后重建的堆为  $\{17,25,23,52,60,72,68,71\}$ ，输出17后重建的堆为  $\{23,25,68,52,60,72,71\}$ 。

# 12. B

初始序列是一棵顺序存储的完全二叉树，然后根据大根堆的要求，按照从下到上、从右到左的顺序进行调整。98和77比较，98和77交换（交换1次）；14和35比较，35和35比较，不交换；98和55比较，98和62比较，98和62交换（交换1次）；62和77比较，77和62交换（交换1次）；98和35比较，98和48比较，98和48交换（交换1次）；77和55比较，77和48比较，77和48交换（交换1次）；48和62比较，62和48交换（交换1次），共交换6次。

# 13. B

删除堆顶62后，将堆尾22放入堆顶，然后自上而下调整。首先34与53比较（第一次比较），较大者53与根22比较（第二次比较），53被换至堆顶；22只有一个孩子，直接与其左孩子46比较（第3次比较），22与46交换，至此大根堆调整结束，具体过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0426ca420530b6e1a5f8bc47f437ce0f77ebb763e63e784f575e7b307df6b6b9.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/4bb083654faec4d0ac8d7589e9cfc17c4121652fa35ae4243e394f7d109f5993.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/166bae34a36d3035a70ea39bc99c6660cc047b4f12d7832a2db3f68b8608e847.jpg)


# 14. D

红黑树和二叉查找树的中序序列是有序序列，从根结点到任意叶结点的路径不能保证是有序的。哈夫曼树是根据权值按一定规则构造的树，和关键字次序无关。若是小根堆，则从根结点到任意叶结点的路径是升序序列；若是大根堆，则从根结点到叶结点的路径是降序序列。

# 15. A

插入关键字3后，堆的变化过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9c5aab2c29e210f5bd2403ad0504529e9be05e1f84ba1b09c28acb2c1ea63718.jpg)



(a) 原始堆


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/34beadd4611a4bc894575669d575a4d130f6917b5a5eb96f3181374bb757ad07.jpg)



(b) 插入3


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/39b005abde91b599aa27cabcd95ea0949af455d89646dc0aba1e2d229b900c99.jpg)



(c) 调整结束


16. B

首先18与10比较，交换；18与25比较，不交换。共比较2次，调整过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0a624e34297cab4f18824015fe95d0a1ceb0f7f9dfebf6e17b00d38a9da3a3e0.jpg)


17. C

删除8后，将12移动到堆顶，第一次是15和10比较，第二次是10和12比较并交换，第三次还需比较12和16，所以比较次数为3。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ab6f0bb3841083671daef65fd1a517e29533948690cb971ea3b619417b2ef112.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/62355d21ca318d014319919873073e495eb0c8ca882755bcf083d38b5053367d.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/512e6a484f6ca1ace2904ed8d290bdaf434fca93cd8e7bd7f95a87a23830e20e.jpg)


18. A

要熟练掌握建堆和调整堆的方法，从序列末尾开始向前遍历，变换过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a7fc1cdb74527e34419831eb35d78916dbbbc3fcaf564cbac9d4200a99a56cb7.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ce87dfda73cf48ce10d276d78b5631586b14cc3829f56b54248d2d739724d145.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d4a499b0d91d0d91b82649692845011bb244481349975b748607cce224ee88b4.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dfd711008378826a8766b3393755222f9ab8ea40837879d371b0c5a101b0c169.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/176759d29295ba7e0724a21cd3d285ea763e9fe8f0a057ae97625288703097cb.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dd9743e9cd14db07ceaddda47345fb1a66f4fb36ae747f6f490fb1563c365f14.jpg)


19. C

简单概念题。堆是一棵完全树，采用一维数组存储，选项I正确，选项II正确。大根堆只要求根结点值大于左右孩子值，并不要求左右孩子值有序，选项III错误。堆的定义是递归的，所以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子，选项IV正确。

20. B

要熟练掌握调整堆的方法，建堆的过程如下图所示，所以答案选择选项B。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/e160366f5b29fdb7555838f1f5ce168a34f251d85e9167b296736a72f06a8406.jpg)


注意，给定序列依次插入空堆的结果与给定序列直接调整成堆的结果是不同的，最终得到的堆的形式也不同。若对序列6,9,1,5,8,4,7直接调整成堆，则会误选选项C。

# 21. B

该序列已调整成大根堆，接下来进行第一次删除操作：删除28后，将5放入堆顶；然后自上而下调整。22和20比较，较大者22与5比较，交换；19和8比较，较大者19与5比较，交换。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1c342ef3b40636273c777cd0cec60624f69d7a2f9374bb4ee683856fad5b080f.jpg)


接下来进行第二次删除操作：删除22后，将15放入堆顶；然后自上而下调整。19和20比较，较大者20与15比较，交换；15直接与其仅有的左孩子12比较，不交换。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/025331048ff399695259205dcc0fa384f79888e7961347b631d9ab1cbe7380cc.jpg)


因此，进行两次删除操作后，得到的新堆是20,19,15,5,8,12。

# 二、综合应用题

# 01.【解答】

以小根堆为例，堆的特点是双亲结点的关键字必然小于或等于该孩子结点的关键字，而两个孩子结点的关键字没有次序规定。在二叉排序树中，每个双亲结点的关键字均大于左子树结点的关键字，均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关系。这样，当对两种树执行中序遍历后，二叉排序树会得到一个有序的序列，而堆则不一定能得到一个有序的序列。

# 02.【解答】

大根堆要求根结点的关键字值既大于或等于左子女的关键字值，又大于或等于右子女的关键字值。二叉排序树要求根结点的关键字值大于左子女的关键字值，同时小于右子女的关键字值。两者的交集是：根结点的关键字值大于左子女的关键字值。这意味着它是一棵左斜单支树，但大根堆要求是完全二叉树，因此最后得到的只能是如下图所示的两个结点的二叉树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5d46d9d7d390e91a05ad106f2d85e5c78636fcc96e994a4a52eb5c13fd92d78b.jpg)


读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子是为了体现出排序树与大根堆的区别。

# 03.【解答】

在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才能得到前  $k$  个最小的元素序列，算法的效率不高。

冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。采用堆排序最合适，对于  $n$  个元素的序列，建立初始堆的时间不超过  $4n$  ，取得第  $k$  个最小元素之前的排序序列所花的时间为  $k\log_2n$  ，总时间为  $4n + k\log_2n$  ；冒泡和简单选择排序完成此功能所花的时间为  $kn$  ，当  $k \geqslant 5$  时，通过比较可以得出堆排序最优。

# 注意

求前  $k$  个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序。

# 04.【解析】

1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d678d30b229ec1727a0aed7dc4ce06bd89680ded5499143b9e40d553221030ad.jpg)



图1 插入65后的树形


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7eca6dbd173c7c84f9d14c5bed909ee8a6bb2f6a60158841b586b6ac0caf41be.jpg)



图2 删除堆顶元素后的树形


2）父结点的编号为  $(k - 1) / 4$  ，第  $i$  个孩子的编号为  $4\times k + i$  ，  $i = 1,2,3,4$

3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有关。因此，插入和删除操作的时间复杂度都为  $O(\log_m n)$ ，其中  $n$  为元素个数。

# 05.【解答】

算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端。在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形成的结果链表中的结点将按关键字非递减的顺序有序链接。

单链表的定义如第2章所述，假设它不带表头结点。

```txt
void selectSort(LinkedList& L){  
//对不带表头结点的单链表L执行简单选择排序 LinkNode  $\star h = L,\star p,\star q,\star r,\star s;$ $L = NULL$  while  $(h! = NULL)$  { //持续扫描原链表  $p = s = h;q = r = NULL$  //指针s和r记忆最大结点和其前驱；p为工作指针，q为其前驱
```

```txt
while  $(\mathsf{p}! = \mathsf{NULL})$  { //扫描原链表寻找最大结点s if  $(\mathsf{p - > data > s - > data})\{\mathsf{s} = \mathsf{p};\mathsf{r} = \mathsf{q};\}$  //找到更大的，记忆它和它的前驱 q=p;p=p->link; //继续寻找 } if  $(s == h)$ $\mathrm{h = h - > l i n k}$  //最大结点在原链表前端 else r->link=s->link; //最大结点在原链表表内 s->link=L;L=s; //结点s插入结果链前端 } 1
```

# 06.【解答】

将顺序表 L[1...n] 视为一个完全二叉树，扫描所有分支结点，遇到孩子结点的关键字小于根结点的关键字时返回 false，扫描完后返回 true。算法的实现如下：

```javascript
bool IsMinHeap(ElemType A[],int len){ if(len%2==0){ //len为偶数，有一个单分支结点 if(A[len/2]>A[len]) //判断单分支结点 return false; for(i=len/2-1;i>=1;i--)//判断所有双分支结点 if(A[i]>A[2*i]||A[i]>A[2*i+1]) return false; } else{ //len为奇数时，没有单分支结点 for(i=len/2;i>=1;i--)//判断所有双分支结点 if(A[i]>A[2*i]||A[i]>A[2*i+1]) return false; } return true; }
```

# 07.【解答】

1）题目要求整个队列所占用的空间不变，入队操作和出队操作的时间复杂度始终保持为  $O(\log_2n)$ ，则应采用顺序存储结构，即用数组实现大根堆。

2）优先队列的数据结构定义如下：

```c
typedef struct{ PriorityQueueElement heap[MAX_SIZE]; //用数组实现堆 int size; //当前堆中元素的数量 }PriorityQueue
```

3）入队操作：

```c
void enqueue(PriorityQueue \*pq,int value,int priority){ if(pq->size  $\coloneqq$  MAX_SIZE){ 队列已满，无法入队； return; 1 将新元素添加到堆的末尾； 向上调整堆；
```

出队操作：

```txt
PriorityQueueElement deque(PriorityQueue \*pq){if(pq->size==0){队列为空时直接退出；获取堆顶元素（优先级最高的元素）；将堆的最后一个元素放到堆顶；
```

```txt
向下调整堆；返回出队元素；
```

08.【解答】

1）算法思想。

【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。

for M中的每个元素s

if (s<A[9]) 丢弃A[9]并将s按升序插入A;

当数据全部扫描完毕，数组  $\mathrm{A}[0] \sim \mathrm{A}[9]$  保存的就是最小的10个数。

【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。

for M中的每个元素s

if (s<H的堆顶元素) 删除堆顶元素并将s插入H;

当数据全部扫描完毕，堆  $\mathrm{H}$  中保存的就是最小的10个数。

2）算法平均情况下的时间复杂度是  $O(n)$  ，空间复杂度是  $O(1)$  。

# 8.5 归并排序、基数排序和计数排序

# 8.5.1 归并排序

# 命题追踪 二路归并操作的功能（2022）

归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有序表合并成一个新的有序表。假定待排序表含有  $n$  个记录，则可将其视为  $n$  个有序的子表，每个子表的长度为1，然后两两归并，得到「 $n/2$ 」个长度为2或1的有序表；继续两两归并……如此重复，直到合并成一个长度为  $n$  的有序表为止，这种排序算法称为二路归并排序。

图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6dd57b8f545cf6790d5df739f3deb97319d934bffff7b307b81954d8a3af466c.jpg)



图8.9 二路归并排序示例


# 命题追踪 （算法题）归并排序思想的应用（2011）

Merge() 的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表 A[low...mid]、A[mid+1...high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组 B 中。每次从 B 的两段中取出一个记录进行关键字的比较，将较小者放入 A 中，当 B 中有一段的下标超出其对应的表长（该段的所有元素都已复制到 A 中）时，将另一段的剩余部分直接复制到 A 中。算法如下：

```txt
ElemType \*B=(ElemType \*)malloc((n+1)\*sizeof(ElemType));//辅助数组B void Merge(ElemType A[],int low,int mid,int high){
```

```javascript
//表A的两段A[low..mid]和A[mid+1..high]各自有序，将它们合并成一个有序表  
int i,j,k;  
for  $(\mathrm{k} = \mathrm{low};\mathrm{k} <   = \mathrm{high};\mathrm{k}++)$  B[k]=A[k]; //将A中所有元素复制到B中  
for(i  $= 1$  low,j  $=$  mid+1,k=i;i<=mid&&j<=high;k++){if(B[i]<=B[j]) //比较B的两个段中的元素A[k]=B[i++]; //将较小值复制到A中elseA[k]=B[j++]；  
}while(i<=mid) A[k++]=B[i++]; //若第一个表未检测完，复制while(j<=high) A[k++]=B[j++]; //若第二个表未检测完，复制
```

# 注意

在上面的代码中，最后两个while循环只有一个会执行。

一趟归并排序的操作是，调用  $\lceil n / 2h\rceil$  次算法 merge()，将 L[1...n] 中前后相邻且长度为  $h$  的有序段进行两两归并，得到前后相邻、长度为  $2h$  的有序段，整个归并排序需要进行  $\lceil \log_2n\rceil$  趟。

递归形式的二路归并排序算法是基于分治的，其过程如下。

分解：将含有  $n$  个元素的待排序表分成各含  $n / 2$  个元素的子表，采用二路归并排序算法对两个子表递归地进行排序。

合并：合并两个已排序的子表得到排序结果。

```javascript
voidMergeSort(ElemTypeA[],intlow,inthigh){ if(low<high）{ intmid=(low+high)/2; //从中间划分两个子序列 MergeSort(A,low,mid); //对左侧子序列进行递归排序 MergeSort(A,mid+1,high)； //对右侧子序列进行递归排序 Merge(A,low,mid,high)； //归并 }
```

# 命题追踪

归并排序和插入排序的对比（2017）

# 命题追踪

二路归并比较次数的分析（2024）

二路归并排序算法的性能分析如下：

空间效率：Merge() 操作中，辅助空间刚好为  $n$  个单元，因此算法的空间复杂度为  $O(n)$ 。

时间效率：每趟归并的时间复杂度为  $O(n)$ ，共需进行  $\lceil \log_2n\rceil$  趟归并，因此算法的时间复杂度为  $O(n\log_2n)$ 。

稳定性：Merge()操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种稳定的排序算法。

适用性：归并排序适用于顺序存储和链式存储的线性表。

# 注意

一般而言，对于  $N$  个元素进行  $k$  路归并排序时，排序的趟数  $m$  满足  $k^m = N$  ，从而  $m = \log_k N$  ，又考虑到  $m$  为整数，因此  $m = \lceil \log_k N \rceil$  。这和前面的二路归并排序算法是一致的。

# 8.5.2 基数排序

基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大

小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。

假设长度为  $n$  的线性表中每个结点  $a_{j}$  的关键字由  $d$  元组（ $k_{j}^{d-1}, k_{j}^{d-2}, \dots, k_{j}^{1}, k_{j}^{0}$ ）组成，满足  $0 \leqslant k_{j}^{i} \leqslant r - 1$  （ $0 \leqslant j < n, 0 \leqslant i \leqslant d - 1$ ）。其中  $k_{j}^{d-1}$  为最高位关键字， $k_{j}^{0}$  为最低位关键字。

为实现多关键字排序，通常有两种方法：第一种是最高位优先（MSD）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列；第二种是最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列。

下面描述以  $r$  为基数的最低位优先基数排序的过程，在排序过程中，使用  $r$  个队列  $Q_{0}, Q_{1}, \dots, Q_{r-1}$ 。基数排序的过程如下：

对  $i = 0,1,\dots ,d - 1$  ，依次做一次分配和收集（其实是一次稳定的排序过程）。

① 分配：开始时，把  $Q_{0}, Q_{1}, \dots, Q_{r-1}$  各个队列置成空队列，然后依次考察线性表中的每个结点  $a_{j} (j = 0, 1, \dots, n-1)$ ，若  $a_{j}$  的关键字  $k_{j}^{i} = k$ ，就把  $a_{j}$  放进  $Q_{k}$  队列中。

② 收集：把  $Q_{0}, Q_{1}, \dots, Q_{r-1}$  各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。

# 命题追踪 基数排序的中间过程的分析（2013、2021）

通常采用链式基数排序，假设对如下10个记录进行排序：

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6529b50a5473200d2179635f62741d3b3e737643491ce340bf1a38142eeb668a.jpg)


每个关键字是1000以下的正整数，基数  $r = 10$  ，在排序过程中需借助10个链队列，每个关键字由3位子关键字构成—— $\mathrm{K}^1\mathrm{K}^2\mathrm{K}^3$  ，分别代表百位、十位和个位，一共进行三趟“分配”和“收集”操作。第一趟分配用最低位子关键字  $\mathbf{K}^3$  进行，将所有最低位子关键字（个位）相等的记录分配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/2e4452a27d94e6dd7db46ceb006d737cf3475a52d940253fe63b5737753fe597.jpg)



(a) 第一趟分配后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d31708cfb1f2342009be14cfb236919dcdb50b5a9988c4ecbc2fb094822b833d.jpg)



(b）第一趟收集后



图8.10 第一趟链式基数排序操作


第二趟分配用次低位子关键字  $\mathrm{K}^2$  进行，将所有次低位子关键字（十位）相等的记录分配到同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ec904fcb4b28eb5a41f0af90897d3e88f9dc93bd20b68a61e5dc5aa1f13be17b.jpg)



(a) 第二趟分配后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/06604b58639ada16df5e96ec4ee2324b66db522becf5194f4ae39f30cdc04e83.jpg)



(b）第二趟收集后



图8.11 第二趟链式基数排序操作


第三趟分配用最高位子关键字  $\mathbf{K}^{1}$  进行，将所有最高位子关键字（百位）相等的记录分配到同一个队列，如图8.12(a)所示，第三趟收集后的结果如图8.12(b)所示，至此整个排序结束。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dc5dd9492d42079b41984021c9c554555fc40aaf4d21086b9d177c258072ce11.jpg)



(a) 第三趟分配后


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/f342ebaea2555f6cccbb86a0e9bd443dff383c6906b61a88eb9a74552c6dfec2.jpg)



(b）第三趟收集后



图8.12 第三趟链式基数排序操作


基数排序算法的性能分析如下。

空间效率：一趟排序需要的辅助存储空间为  $r$  （ $r$  个队列： $r$  个队头指针和  $r$  个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为  $O(r)$ 。

# 命题追踪 元素的移动次数与序列初态无关的排序算法（2015）

时间效率：基数排序需要进行  $d$  趟“分配”和“收集”操作。一趟分配需要遍历所有关键字，时间复杂度为  $O(n)$  ；一趟收集需要合并  $r$  个队列，时间复杂度为  $O(r)$  。因此基数排序的时间复杂度为  $O(d(n + r))$  ，它与序列的初始状态无关。

稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，因此基数排序是一种稳定的排序算法。

适用性：基数排序适用于顺序存储和链式存储的线性表。

# *8.5.3 计数排序

# 命题追踪 （算法题）计数排序思想的应用（2013、2015、2018）

计数排序也是一种不基于比较的排序算法。计数排序的思想是：对每个待排序元素  $x$  ，统计小于  $x$  的元素个数，利用该信息就可确定  $x$  的最终位置。例如，若有8个元素小于  $x$  ，则  $x$  就排在第9号位置上。当有几个元素相同时，该排序方案还需做一定的优化。

# 注意

计数排序并不在统考大纲的范围内，但其排序思想在历年真题中多次涉及。

在计数排序算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数组：B[n]存放输出的排序序列，C[k]存储计数值。用输入数组A中的元素作为数组C的下标（索引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：

# 命题追踪 计数排序相关的思想和代码的分析（2021）

```txt
void CountSort(ElemType A[],ElemType B[],int n,int k){  
    int i,C[k];  
    for(i=0;i<k;i++)  
        C[i]=0; //初始化计数数组  
    for(i=0;i<n;i++) //遍历输入数组，统计每个元素出现的次数  
        C[A[i]]++; //C[A[i]]保存的是等于A[i]的元素个数
```

```txt
for  $(\mathrm{i} = 1;\mathrm{i} <   \mathrm{k};\mathrm{i} + + )$ $\begin{array}{rl} & {\mathrm{C[i] = C[i] + C[i - 1];}}\\ & {\mathrm{for(i = n - 1;i >= 0;i - - )\{}}\\ & {\mathrm{B[C[A[i]] - 1] = A[i];}}\\ & {\mathrm{C[A[i]] = C[A[i]] - 1;}}\\ & \end{array}$  //从后往前遍历输入数组//将元素A[i]放在输出数组B[]的正确位置上  
1
```

第一个for循环执行完后，数组C的值初始化为0。第二个for循环遍历输入数组A，若一个输入元素的值为x，则将C[x]值加1，该for循环执行完后，C[x]中保存的是等于x的元素个数。第三个for循环通过累加计算后，C[x]中保存的是小于或等于x的元素个数。第四个for循环从后往前遍历数组A，把每个元素A[i]放入它在输出数组B的正确位置上。若数组A中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要将C[A[i]]减1，这样，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数组B中A[i]的前一个位置上。

假设输入数组  $\mathrm{A}[] = \{2,4,3,0,2,3\}$ ，第二个for循环执行完后，辅助数组C的情况如图8.13(a)所示；第三个for循环执行完后，辅助数组C的情况如图8.13(b)所示。图8.13(c)至图8.13(h)分别是第四个for循环每迭代一次后，输出数组B和辅助数组C的情况。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/97fac7e38b42c605a3fbeabdf3c73dff1ca241c7a1ce58025b47393a89c4abf8.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/96298cb7b348d58d1a690ce9193c66d7ee782f85321f68ba816edfe95d985802.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/796a32a00ebb13156b9cb6bd7b31441342d74824123698b0ca976005f13c5c69.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/037a1a863c86ae1e146720825975365c821dca1dfa48f85ef1fd3f92f98dbdfa.jpg)



(b)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9fd597b97488ac4eb85fb8e4938fa1107fc122d18d454feed5b4fa950ca1b0b6.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/90cba4859112304020affee7b7fcddd97622aa08425a7a83157a4f0b7916c167.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/db2b1cbcbd04b53fc36bcd4bf818d0357f94c30f39f2511d55a574b7a65fdf56.jpg)



(c)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d96c465cdb47610b6c26ff29c8b5cd9619bc635b69b3defae7e9aa80ec092a8c.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c8f76be7616ff63eb1573b02e42c9a1f6135e6a951934eda24074dd568ec340c.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d346524421b93cf3c3622fc16e9edf24709d73f8bed1b0b1f0d3b8218288e4f4.jpg)



(d)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/012eab6e635cb1022bc50cd204c007936230348f9ad7c6993bf24135bafef343.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/80cb44052b1f8e8ead678e7a75a834d51c2a1a3f90621f6243bcdec47c731558.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/9021cbce30707bda96e862b05e53beb0ae7f8bac4defc6f1d2391d16b93bea33.jpg)



(e)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ba52057244f28f61b6325e3f692d5596fd3613acae5bcc51c3bb3012883c9afe.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/514e7f5230ed64447ba37f2551fd4cb28c78c724652787832677d3303a967465.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/98b77fb01397e80379d6e1fdd303fdfbd565085c33957f7bc93f10908989ea5a.jpg)



(f)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a35ea42be630f0a5f1d0fc3a9794865cd1f5e03e3f57c48a33b38d9d8d2a8ced.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/c96fe67de95fb89fcc2c248c1f6bca8742a6bc850731aafde0b4ed55f65dc771.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/1a371e002cf404774b5663067efac3ffdf657e9048d89e853f34f48e2a6f6404.jpg)



(g)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/eed8736858e253ec0e0ee185a3a043d32b3e4b6ef68e09b73c818395e70cf4fa.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ca7d19bb85c8a91d5cd658a0469f15a12dbcfa88b4d31b46bb98086f70335f63.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5ce995e3514f320e269b73a3587b5f73f047f853d8eb54ebb1810622ff7aead6.jpg)



(h)



图8.13 计数排序的过程


由上面的过程可知，计数排序的原理是：数组的索引（下标）是递增有序的，通过将序列中的元素作为辅助数组的索引，其个数作为值放入辅助数组，遍历辅助数组来排序。

计数排序算法的性能分析如下。

空间效率：计数排序是一种用空间换时间的做法。输出数组的长度为  $n$ ；辅助的计数数组的长度为  $k$ ，空间复杂度为  $O(n + k)$ 。若不把输出数组视为辅助空间，则空间复杂度为  $O(k)$ 。

时间效率：上述代码的第1个和第3个for循环所花的时间为  $O(k)$ ，第2个和第4个for循环所花的时间为  $O(n)$ ，总时间复杂度为  $O(n + k)$ 。因此，当  $k = O(n)$  时，计数排序的时间复杂度为 $O(n)$ ；但当  $k > O(n\log_2n)$  时，其效率反而不如一些基于比较的排序（如快速排序、堆排序等）。

稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对位置不会改变，因此计数排序是一种稳定的排序算法。

适用性：计数排序更适用于顺序存储的线性表。计数排序适用于序列中的元素是整数且元素范围（ $0 \sim k - 1$ ）不能太大，否则会造成辅助空间的浪费。

# 8.5.4 本节试题精选

# 一、单项选择题

01. 以下排序算法中，（）在一趟结束后不一定能选出一个元素放在其最终位置上。

A. 简单选择排序

B. 冒泡排序

C. 归并排序

D. 堆排序

02. 以下排序算法中，（）不需要进行关键字的比较。

A. 快速排序

B. 归并排序

C. 基数排序

D. 堆排序

03. 在下列排序算法中，平均情况下空间复杂度为  $O(n)$  的是（），最坏情况下空间复杂度为 $O(n)$  的是（）。

I.希尔排序

II. 堆排序

III. 冒泡排序

IV. 归并排序

V. 快速排序

VI. 基数排序

A. I、IV、VI

B. II、V

C. IV、V

D. IV

04. 下列排序算法中，排序过程中比较次数的数量级与序列初始状态无关的是（）。

A. 归并排序

B. 插入排序

C. 快速排序

D. 冒泡排序

05.二路归并排序中，归并趟数的数量级是（）。

A.  $O(n)$

B.  $O\left(\log_2 n\right)$

C.  $O(n \log_2 n)$

D.  $O(n^{2})$

06. 若对27个元素只进行三趟多路归并排序，则选取的归并路数最少为（）。

A. 2

B. 3

C. 4

D. 5

07. 将两个各有  $N$  个元素的有序表合并成一个有序表，最少的比较次数是（），最多的比较次数是（）。

A.  $N$

B.  ${2N} - 1$

C.  $2 N$

D.  $N - 1$

08. 用归并排序算法对序列  $\{1,2,6,4,5,3,8,7\}$  进行排序，共需要进行（）次比较。

A. 12

B. 13

C. 14

D. 15

09. 一组经过第一趟二路归并排序后的记录的关键字为  $\{25, 50, 15, 35, 80, 85, 20, 40, 36, 70\}$ ，其中包含5个长度为2的有序表，用二路归并排序算法对该序列进行第二趟归并后的结果为（）。

A. 15,25,35,50,80,20,85,40,70,36

B. 15,25,35,50,20,40,80,85,36,70

C. 15,25,50,35,80,85,20,36,40,70

D. 15, 25, 35, 50, 80, 20, 36, 40, 70, 85

10. 若将中国人按照生日（不考虑年份，只考虑月、日）来排序，则使用下列排序算法时，最快的是（）。

A. 归并排序

B. 希尔排序

C. 快速排序

D. 基数排序

11. 设线性表中每个元素有两个数据项  $k_{1}$  和  $k_{2}$ ，现对线性表按以下规则进行排序：先看数据项  $k_{1}$ ， $k_{1}$  值小的元素在前，大的元素在后；在  $k_{1}$  值相同的情况下，再看  $k_{2}$ ， $k_{2}$  值小的元素在前，大的元素在后。满足这种要求的排序算法是（）。

A. 先按  $k_{1}$  进行直接插入排序，再按  $k_{2}$  进行简单选择排序

B. 先按  $k_{2}$  进行直接插入排序，再按  $k_{1}$  进行简单选择排序

C. 先按  $k_{1}$  进行简单选择排序，再按  $k_{2}$  进行直接插入排序

D. 先按  $k_{2}$  进行简单选择排序，再按  $k_{1}$  进行直接插入排序

12. 对  $\{05, 46, 13, 55, 94, 17, 42\}$  进行基数排序，一趟排序的结果是（）。

A. 05, 46, 13, 55, 94, 17, 42

B. 05, 13, 17, 42, 46, 55, 94

C. 42, 13, 94, 05, 55, 46, 17

D. 05, 13, 46, 55, 17, 42, 94

13. 有  $n$  个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队列个数是（）。

A.  $n$

B. 2

C. 5

D. 10

14. 下列各种排序算法中，（）需要的附加存储空间最大。

A. 快速排序

B. 堆排序

C. 归并排序

D. 插入排序

15.【2013统考真题】已知两个长度分别为  $m$  和  $n$  的升序链表，若将它们合并为长度为  $m + n$  的一个降序链表，则最坏情况下的时间复杂度是（）。

A.  $O(n)$

B.  $O(mn)$

C.  $O(\min (m,n))$

D.  $O(\max (m,n))$

16.【2013统考真题】对给定的关键字序列110, 119, 007, 911, 114, 120, 122进行基数排序，第二趟分配、收集后得到的关键字序列是（）。

A. 007, 110, 119, 114, 911, 120, 122

B. 007, 110, 119, 114, 911, 122, 120

C. 007, 110, 911, 114, 119, 120, 122

D. 110, 120, 911, 122, 114, 007, 119

17.【2015统考真题】下列排序算法中，元素的移动次数与关键字的初始状态无关的是（）。

A. 直接插入排序

B. 冒泡排序

C. 基数排序

D. 快速排序

18.【2021统考真题】设数组  $S[] = \{93,946,372,9,146,151,301,485,236,327,43,892\}$ ，采用最低位优先（LSD）基数排序将S排列成升序序列。第一趟分配、收集后，元素372之前、之后紧邻的元素分别是（）。

A. 43,892

B. 236, 301

C. 301,892

D. 485, 301

19.【2022统考真题】使用二路归并排序对含  $n$  个元素的数组M进行排序时，二路归并排序的功能是（）。

A. 将两个有序表合并为一个新的有序表

B. 将 M 划分为两部分, 两部分的元素个数大致相等

C. 将  $\mathrm{M}$  划分为  $n$  个部分, 每个部分中仅含有一个元素

D. 将 M 划分为两部分, 一部分元素的值均小于另一部分元素的值

20.【2024统考真题】现有由关键字组成的3个有序序列(3,5)、(7,9)和(6)，若按从左至右的次序选择有序序列进行二路归并排序，则关键字之间的总比较次数是（）。

A. 3

B. 4

C. 5

D. 6

# 二、综合应用题

01. 已知序列  $\{503, 87, 512, 61, 908, 170, 897, 275, 653, 462\}$ ，采用非递归的二路归并排序算法对该序列做升序排序时需要几趟排序？给出每一趟的结果。

02. 设待排序的关键字序列为  $\{12, 2, 16, 30, 28, 10, 16^{*}, 20, 6, 18\}$ ，试写出使用最低位优先（LSD）基数排序算法每趟排序后的结果。

03.【2021统考真题】已知某排序算法如下：

```javascript
void cmpCountSort(int a[],int b[],int n){ int i,j,\*count; count=(int \*）malloc(sizeof(int)\*n); //C++语言：count=new int[n]; for(i=0;i<n;i++) count[i]=0; for(i=0;i<n-1;i++) for(j=i+1;j<n;j++) if(a[i]<a[j]) count[j]++; else count[i]++; for(i=0;i<n;i++) b[count[i]]=a[i]; free(count)； //C++语言：delete count;   
}
```

请回答下列问题。

1）若有int a[] = {25, -10, 25, 10, 11, 19}, b[6]，则调用cmpCountSort(a, b, 6)后数组b中的内容是什么？

2）若a中含有  $n$  个元素，则算法执行过程中，元素之间的比较次数是多少？

3）该算法是稳定的吗？若是，阐述理由；否则，修改为稳定排序算法。

# 8.5.5 答案与解析

# 一、单项选择题

01. C

我们知道插入排序不能保证在一趟排序结束后一定有元素放在最终位置上。事实上，归并排序也不能保证。例如，序列  $\{6,5,7,8,2,1,4,3\}$  进行一趟二路归并排序（从小到大）后为  $\{5,6,7,8,1,2,3,4\}$ ，显然它们都未被放在最终位置上。

02. C

基数排序是基于关键字各位的大小进行排序的，而不是基于关键字的比较进行的。

03. D、C

归并排序在平均情况和最坏情况下的空间复杂度都是  $O(n)$ ，快速排序只在最坏情况下才是  $O(n)$ ，平均情况是  $O(\log_2n)$ 。因此，归并排序是本章所有排序算法中占用辅助空间最多的。

04. A

前面已讲过选择排序的比较次数与序列初始状态无关，归并排序的比较次数的数量级也与序列的初始状态无关。读者应能从算法的原理方面来考虑为什么和初始状态无关。

05. B

$N$  个元素进行  $k$  路归并排序的趟数  $m$  满足  $k^m = N$  ，即  $m = \lceil \log_k N \rceil$  ，本题中为  $\lceil \log_2 n \rceil$  。

06. B

$N$  个元素进行  $k$  路归并排序的趟数  $m$  满足  $k^m = N$  ，这里要求的是  $k$  ，代入可得  $k = 3$  。

07. A、B

注意，当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较  $N$  次；而当两个表中的元素依次间隔地比较时，即  $a_1 < b_1 < a_2 < b_2 < \dots < a_n < b_n$  时，比较的次数是最多的，为  $2N - 1$  次。

建议读者对此举一反三：若将本题中的两个有序表的长度分别设为  $M$  和  $N$  ，则最多（或最少）的比较次数是多少？时间复杂度又是多少？

08. C

第一趟归并后  $\{1,2\}, \{4,6\}, \{3,5\}, \{7,8\}$ ，共比较4次；第二趟归并后  $\{1,2,4,6\}, \{3,5,7,8\}$ ，共比较4次；第三趟归并后  $\{1,2,3,4,5,6,7,8\}$ ，共比较6次。三趟归并共需进行14次比较。

09. B

这里采用二路归并排序算法，且是第二趟排序，因此每4个元素放在一起归并，可将序列划分为{25, 50, 15, 35}, {80, 85, 20, 40}和{36, 70}, 分别对它们进行排序后有{15, 25, 35, 50}, {20, 40, 80, 85}和{36, 70}。

10. D

按照所有中国人的生日排序，一方面  $N$  是非常大的，另一方面关键字所含的排序码数为2，且一个排序码的基数为12，另一个排序码的基数为31，都是较小的常数值，因此采用基数排序可以在  $O(N)$  内完成排序过程。

# 11. D

本题思路来自基数排序的LSD，首先应确定  $k_{1}$  、  $k_{2}$  的排序顺序，若先排  $k_{1}$  再排  $k_{2}$ ，则排序结果不符合题意，排除选项A和C。再考虑排序的稳定性，当  $k_{2}$  排好序后，再对  $k_{1}$  排序，若对  $k_{1}$  排序采用的方法是不稳定的，则对于  $k_{1}$  相同而  $k_{2}$  不同的元素可能会改变相对次序，从而不一定能满足题设要求。直接插入排序是稳定的，而简单选择排序是不稳定的，只能选择选项D。

# 12. C

基数排序有 MSD 和 LSD 两种，基数排序是稳定的。对于选项 A，不符合 LSD 和 MSD；对于选项 B，符合 MSD，但关键字 42、46 的相对位置发生了变化；对于选项 D，不符合 LSD 和 MSD。

# 13. D

基数排序中建立的队列个数等于进制数。

# 14. C

快速排序的平均空间复杂度是  $O(\log_2n)$ ，归并排序的空间复杂度是  $O(n)$ ，其他都是  $O(1)$ 。

# 15. D

考虑两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置（取较小元素，头插法）。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为  $2\max(m, n) \geq m + n$  ，所以时间复杂度为  $O(\max(m, n))$  。此外，每次比较把两个链表中的较小结点插入新链表的表头，直到一个链表为空，因为原链表是升序排列的，要求合并后为降序排列的，因此还要把另一个链表剩下的结点一一插入新链表的表头，不论是最好情况还是最坏情况，都需要遍历两个链表中的所有结点。

# 16. C

基数排序的第一趟排序是按照个位数字的大小来进行的，第二趟排序是按照十位数字的大小来进行的，排序的过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/68d4e4ed00eb1e1e8e2f55a19317977cdb2e218e1044b8795326cb8a247fa830.jpg)


# 17. C

基数排序的元素移动次数与序列初态无关，而其他三种排序算法都与序列初态有关。

# 18. C

基数排序是一种稳定的排序算法。因为采用最低位优先（LSD）的基数排序，即第一趟对个位进行分配和收集操作，所以第一趟分配和收集后的结果是{151,301,372,892,93,43,485,946,

146,236,327,9},元素372之前、之后紧邻的元素分别是301和892。

# 19. A。

送分题。本书对归并的定义原话是“归并的含义是将两个或两个以上的有序表合并成一个新的有序表”，而二路归并是将两个有序表合并为一个新的有序表。

# 20. C

从左至右对这三个有序序列进行二路归并排序的过程如下：

① 合并(3,5)和(7,9)：比较3和7（1次），选择3；比较5和7（1次），选择5；剩余元素7和9直接加入。② 合并(3,5,7,9)和(6)：比较3和6（1次），选择3；比较5和6（1次），选择5；比较7和6（1次），选择6；剩余元素7和9直接加入。总共比较5次。

# 二、综合应用题

# 01.【解答】

$n = 10$  ，需要排序的趟数  $= \lceil \log_210\rceil = 4$  ，各趟的排序结果如下：

初始序列：503,87,512,61,908,170,897,275,653,462

第一趟：87,503,61,512,170,908,275,897,462,653（长度为2）

第二趟：61,87,503,512,170,275,897,908,462,653（长度为4）

第三趟：61,87,170,275,503,512,897,908,462,653（长度为8）

第四趟：61,87,170,275,462,503,512,653,897,908（长度为10）

# 02.【解答】

使用链式队列的基数排序的排序过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5840b13dbb2061863d403ccba1827c57114ef865920377a3a71b5c3cd36c44ef.jpg)



按最低位分配



rear[0] rear[1] rear[2] rear[3] rear[4] rear[5] rear[6] rear[7] rear[8] rear[9]


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0ec39b9ef50e360d7bc52662c89e33108acfd2692dc5a3c82174b81489b7b7b8.jpg)



front[0] front[1] front[2] front[3] front[4] front[5] front[6] front7] front[8] front[9]


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/ae761e6d1fb6f1f0731913719eabe26d667ba60edb96bc9a2bf53d8861e66e53.jpg)



按最高位分配



rear[0] rear[1] rear[2] rear[3] rear[4] rear[5] rear[6] rear[7] rear[8] rear[9]


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7c5b965acf3cc5d2ab4497feee88212ae5e4d5b5dfba2cd47113e609f1cd67bd.jpg)



front[0] front[1] front[2] front[3] front[4] front[5] front[6] front7] front[8] front[9]


收集

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/10a98e3422313f5ab191202abafbae0564164db94ade1ac0c4aa1cf368740372.jpg)


需要通过2次分配和收集完成排序。

# 03.【解答】

cmpCountSort 算法基于计数排序的思想，对序列进行排序。cmpCountSort 算法遍历数组中的元素，count 数组记录比对应待排序数组元素下标大的元素个数，例如，count[1] = 3 的意思是数组 a 中有三个元素比 a[1] 小，即 a[1] 是第四大元素，a[1] 的正确位置应是 b[3]。

1）排序结果为  $\mathsf{b}[6] = \{-10,10,11,19,25,25\}$

2）由代码 for  $(i = 0; i < n - 1; i++)$  和 for  $(j = i + 1; j < n; j++)$  可知，在循环过程中，每个元素都与它后面的所有元素比较一次（所有元素都两两比较一次），比较次数之和为  $(n - 1) + (n - 2) + \dots + 1$  ，所以总比较次数是  $n(n - 1) / 2$  。

3）不是。需要将程序中的if语句修改如下：

```javascript
if(a[i]  $<  =$  a[j])count[j]++; else count[i]++;
```

若不加等号，两个相等的元素比较时，前面元素的 count 值会加 1，则导致原序列中靠前的元素在排序后的序列中处于靠后的位置。

# 8.6 各种内部排序算法的比较及应用

# 8.6.1 内部排序算法的比较

前面讨论的排序算法很多，对各种排序算法的比较是考研常考的内容。一般基于五个因素进行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。

# 命题追踪 各种排序算法的特点、比较和适用场景（2017、2020、2022）

从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为  $O(n^{2})$  ，且实现过程也较为简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到 $O(n)$  ，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在  $O(n\log_2n)$  内完成排序过程。快速排序基于分治的思想，虽然最坏情况下的时间复杂度会达到  $O(n^{2})$  ，但快速排序的平均性能可以达到  $O(n\log_2n)$  ，在实际应用中常常优于其他排序算法。归并排序同样基于分治的思想，但其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度均为  $O(n\log_2n)$  。

从空间复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数个辅助空间。快速排序需要借助一个递归工作栈，平均大小为  $O(\log_2n)$ ，当然在最坏情况下可能会增长到  $O(n)$ 。二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为  $O(n)$ ，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。

# 命题追踪 排序算法的稳定性判断及改进（2021、2023）

从稳定性看：插入排序、冒泡排序、归并排序和基数排序是稳定的排序算法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序算法。平均时间复杂度为  $O(n\log_2n)$  的稳定排序算法只有归并排序，对于不稳定的排序算法，只需举出一个不稳定的实例即可。对于排序算法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。

# 命题追踪 更适合采用顺序存储的排序算法（2017）

从适用性看：折半插入排序、希尔排序、快速排序和堆排序适用于顺序存储。直接插入排序、

冒泡排序、简单选择排序、归并排序和基数排序既适用于顺序存储，又适用于链式存储。

命题追踪 根据排序的中间过程判断所采用的排序算法（2009、2010）

命题追踪 每趟排序后都至少能确定一个元素的最终位置的排序算法（2012）

从过程特征看：采用不同的排序算法，在一趟或几趟处理后的排序结果通常是不同的，考研题中经常出现给出一个待排序的初始序列和已部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，如冒泡排序、简单选择排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等。

表8.1列出了各种排序算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，因为希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。


表 8.1 各种排序算法的性质


<table><tr><td>算法种类</td><td colspan="3">时间复杂度</td><td rowspan="2">空间复杂度</td><td rowspan="2">是否稳定</td></tr><tr><td></td><td>最好情况</td><td>平均情况</td><td>最坏情况</td></tr><tr><td>直接插入排序</td><td>\( O\left( n\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( 1\right) \)</td><td>是</td></tr><tr><td>冒泡排序</td><td>\( O\left( n\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( 1\right) \)</td><td>是</td></tr><tr><td>简单选择排序</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( 1\right) \)</td><td>否</td></tr><tr><td>希尔排序</td><td colspan="3"></td><td>\( O\left( 1\right) \)</td><td>否</td></tr><tr><td>快速排序</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {n}^{2}\right) \)</td><td>\( O\left( {{\log }_{2}n}\right) \)</td><td>否</td></tr><tr><td>堆排序</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( 1\right) \)</td><td>否</td></tr><tr><td>二路归并排序</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( {{nlog}_{2}n}\right) \)</td><td>\( O\left( n\right) \)</td><td>是</td></tr><tr><td>基数排序</td><td>\( O\left( {d\left( {n + r}\right) }\right) \)</td><td>\( O\left( {d\left( {n + r}\right) }\right) \)</td><td>\( O\left( {d\left( {n + r}\right) }\right) \)</td><td>\( O\left( r\right) \)</td><td>是</td></tr></table>

# 8.6.2 内部排序算法的应用

通常情况，对排序算法的比较和应用应考虑以下情况。

命题追踪 选取排序算法时需要考虑的因素（2019）

# 1. 选取排序算法需要考虑的因素

1）待排序的元素个数  $n$ 。

2）待排序的元素的初始状态。

3）关键字的结构及其分布情况。

4）稳定性的要求。

5）存储结构及辅助空间的大小限制等。

# 2. 排序算法小结

1）若  $n$  较小，可采用直接插入排序或简单选择排序。直接插入排序所需的记录移动次数较简单选择排序的多，因此当记录本身信息量较大时，用简单选择排序较好。

2）若  $n$  较大，应采用时间复杂度为  $O(n\log_2n)$  的排序算法：快速排序、堆排序或归并排序。当待排序的关键字随机分布时，快速排序被认为是目前基于比较的内部排序算法中最好的算法。堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能的最坏情况，这两种排序都是不稳定的。若要求稳定且时间复杂度为  $O(n\log_2n)$ ，可选用归并排序。

3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。

4）在基于比较的排序算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，

因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的  $n$  个关键字随机分布时，任何借助于“比较”的排序算法，至少需要  $O(n\log_2n)$  的时间。

5）若  $n$  很大，记录的关键字位数较少且可以分解时，采用基数排序较好。

6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。

# 8.6.3 本节试题精选

# 一、单项选择题

01. 若要求排序是稳定的，且关键字为实数，则在下列排序算法中应选（）。

A. 直接插入排序

B. 选择排序

C. 基数排序

D. 快速排序

02. 以下排序算法中时间复杂度为  $O(n\log_2n)$  且稳定的是（）。

A. 堆排序

B. 快速排序

C. 归并排序

D. 直接插入排序

03. 设被排序的结点序列共有  $n$  个结点，在该序列中的结点已十分接近有序的情况下，用直接插入排序、归并排序和快速排序对其进行排序，这些算法的时间复杂度应为（）。

A.  $O(n), O(n), O(n)$

B.  $O(n), O(n \log_2 n), O(n \log_2 n)$

C.  $O(n), O(n \log_2 n), O(n^2)$

D.  $O(n^{2}), O(n \log_{2} n), O(n^{2})$

04. 下列排序算法中属于稳定排序的是 (①)，平均时间复杂度为  $O(n\log_2n)$  的是 (②)，在最好的情况下，时间复杂度可以达到线性时间的有 (③)。（注：多选题）

I. 冒泡排序

II. 堆排序

III. 选择排序

IV. 直接插入排序

V. 希尔排序

VI. 归并排序

VII. 快速排序

05. 就排序算法所用的辅助空间而言，堆排序、快速排序和归并排序的关系是（）。

A. 堆排序<快速排序<归并排序

B. 堆排序<归并排序<快速排序

C. 堆排序  $>$  归并排序  $>$  快速排序

D. 堆排序>快速排序>归并排序

06. 排序趟数与序列的初始状态无关的排序算法是（）。

I. 快速排序

II. 简单选择排序

III. 冒泡排序

IV. 基数排序

A. I、III

B. II、IV

C. I、II、IV

D. I、IV

07. 排序趟数与序列的初始状态有关的排序算法是（）。

A. 直接插入排序

B. 二路归并排序

C. 快速排序 D. 堆排序

08. 对  $n$  个元素进行排序，其排序趟数肯定为  $n - 1$  趟的排序算法是（）。

A. 直接插入排序和快速排序

B. 冒泡排序和快速排序

C. 简单选择排序和直接插入排序

D. 简单选择排序和冒泡排序

09. 若序列的初始状态为  $\{1,2,3,4,5,10,6,7,8,9\}$ ，要想使得排序过程中的元素比较次数最少，则应该采用（）方法。

A. 插入排序

B. 选择排序

C. 希尔排序

D. 冒泡排序

10. 对于元素个数相同的不同初始序列，总比较次数相同的排序算法是（）。

A. 折半插入排序和简单选择排序

B. 基数排序和归并排序

C. 冒泡排序和快速排序

D. 堆排序

11. 一般情况下，以下查找效率最低的数据结构是（）。

A. 有序顺序表

B. 二叉排序树

C. 堆

D. 平衡二叉树

12. 一台计算机具有多核CPU，可以同时执行相互独立的任务。归并排序的各个归并段可以并行执行，在下列排序算法中，不可以并行执行的有（）。

I. 基数排序

II. 快速排序

III. 冒泡排序

IV. 堆排序

A. I、III

B. I、II

C. I、III、IV

D. II、IV

13.【2009统考真题】若数据元素序列{11, 12, 13, 7, 8, 9, 23, 4, 5}是采用下列排序算法之一得到的第二趟排序后的结果，则该排序算法只能是（）。

A. 冒泡排序

B. 插入排序

C. 选择排序

D. 二路归并排序

14.【2010统考真题】对一组数据(2, 12, 16, 88, 5, 10)进行排序，若前3趟排序结果如下：

第一趟排序结果：2,12,16,5,10,88

第二趟排序结果：2,12,5,10,16,88

第三趟排序结果：2,5,10,12,16,88

则采用的排序算法可能是（）。

A. 冒泡排序

B. 希尔排序

C. 归并排序

D. 基数排序

15.【2012统考真题】在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序算法中，每趟排序结束都至少能够确定一个元素最终位置的方法是（）。

I. 简单选择排序

II. 希尔排序

III. 快速排序

IV. 堆排序

V. 二路归并排序

A. 仅 I、III、IV

B. 仅 I、III、V

C. 仅 II、III、IV

D. 仅III、IV、V

16.【2017统考真题】在内部排序时，若选择了归并排序而未选择插入排序，则可能的理由是（）。

I. 归并排序的程序代码更短

II. 归并排序的占用空间更少

III. 归并排序的运行效率更高

A. 仅 II

B. 仅III

C. 仅 I、II

D. 仅 I、III

17.【2017统考真题】下列排序算法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是（）。

I. 插入排序

II. 选择排序

III. 冒泡排序

IV. 希尔排序

V. 堆排序

A. 仅 I、II

B. 仅 II、III

C. 仅III、IV

D. 仅IV、V

18.【2019统考真题】选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是（）。

I. 数据的规模

II. 数据的存储方式

III. 算法的稳定性

IV. 数据的初始状态

A. 仅III

B. 仅 I、II

C. 仅 II、III、IV

D. I、II、III、

19.【2020统考真题】对大部分元素已有序的数组排序时，直接插入排序比简单选择排序效率更高，其原因是（）。

I. 直接插入排序过程中元素之间的比较次数更少

II. 直接插入排序过程中所需的辅助空间更少

III. 直接插入排序过程中元素的移动次数更少

A. 仅 I

B. 仅III

C. 仅 I、II

D. I、II 和 III

20.【2022统考真题】对数据进行排序时，若采用直接插入排序而不采用快速排序，则可能的原因是（）

I. 大部分元素已有序

II. 待排序元素数量很少

III. 要求空间复杂度为  $O(1)$

IV. 要求排序算法是稳定的

A. 仅I、II

B. 仅III、IV

C. 仅 I、II、IV

D. I、II、III、IV

21.【2023统考真题】下列排序算法中，不稳定的是（）。

I. 希尔排序

II. 归并排序

III. 快速排序

IV. 堆排序

V. 基数排序

A. 仅 I、II

B. 仅 II、V

C. 仅 I、

IV

D. 仅 III、IV、V

# 二、综合应用题

01. 设关键字序列为  $\{3, 7, 6, 9, 7, 1, 4, 5, 20\}$ ，对其进行排序的最小交换次数是多少？

02. 设顺序表用数组 A[] 表示，表中元素存储在数组下标  $1 \sim m + n$  的范围内，前  $m$  个元素递增有序，后  $n$  个元素递增有序，设计一个算法，使得整个顺序表有序。

1）给出算法的基本设计思想。

2）根据设计思想，采用  $C / C + +$  描述算法，关键之处给出注释。

3）说明你所设计算法的时间复杂度与空间复杂度。

03. 设有一个数组中存放了一个无序的关键序列  $K_{1}, K_{2}, \dots, K_{n}$  。现要求将  $K_{n}$  放在将元素排序后的正确位置上，试编写实现该功能的算法，要求比较关键字的次数不超过  $n$  。

# 8.6.4 答案与解析

# 一、单项选择题

01. A

采用排除法。题目要求是稳定排序，因此排除选项B和D，又基数排序不能对float和double类型的实数进行排序，因此排除选项C。

02.C

堆排序和快速排序不是稳定排序算法，而直接插入排序算法的时间复杂度为  $O(n^{2})$ 。

03.C

各种排序算法的时间和空间复杂度、稳定性等见表8.1。

04. ① I、IV、VI ② II、VI、VII ③ I、IV

读者应能从算法的原理上理解算法的稳定性情况。堆排序和归并排序在最坏情况下的时间复杂度与最好情况下的时间复杂度是同一数量级的，都是  $O(n\log_2n)$

05. A

堆排序的空间复杂度为  $O(1)$ ，因此快速排序的空间复杂度在最坏情况下为  $O(n)$ ，平均空间复杂度为  $O(\log_2n)$ ，归并排序的空间复杂度为  $O(n)$ 。

06. B

冒泡排序的趟数为  $1 \sim n - 1$  ，和序列初态有关。简单选择排序每趟都选出一个最小（或最大）的元素，排序趟数固定为  $n - 1$  。基数排序每趟都要进行分配和收集，排序趟数固定为  $d$  。快速排序的趟数和枢轴的选取有关，即和划分是否对称有关，当划分的两个区域分别包含0个元素和  $n - 1$  个元素时，这种最大限度的不对称性发生在序列初态基本有序时。

07. C

直接插入排序的趟数始终为  $n - 1$  ，而与序列的初始状态无关。二路归并排序的趟数始终为  $\lceil \log_2n\rceil$  ，而与序列的初始状态无关。堆排序每趟选出一个最大元素或最小元素，然后调整堆，初始建好堆后，需要  $n - 1$  趟输出和调整堆的操作，而与序列的初始状态无关。

08. C

简单选择排序和直接插入排序的趟数始终为  $n - 1$  。冒泡排序的趟数为  $1 \sim n - 1$ ，快速排序的趟数为  $\log_2 n \sim n - 1$ ，具体取决于序列的初始状态（快速排序还取决于划分方法）。

09. A

选择排序和序列初态无关，直接排除。初始序列基本有序时，插入排序比较次数较少。本题

中，插入排序仅需比较  $n - 1 + 4$  次，而希尔排序和冒泡排序的比较次数均远大于此。

# 10. A

简单选择排序的总比较次数显然是确定的。折半插入排序每趟的比较次数都为  $O(\log_2m)$  （ $m$  为当前已排好序的子序列的长度），因此总比较次数也是确定的。基数排序不是基于比较的排序算法。其他几种排序算法的比较次数显然和序列的初始状态有关。

# 11. C

堆是用于排序的，在查找时它是无序的，所以效率没有其他查找结构的高。

# 12. A

基数排序每趟需要利用前一趟已排好的序列，无法并行执行。快速排序每趟划分的子序列互不影响，可以并行执行。冒泡排序每趟对未排序的所有元素进行一趟处理，无法并行执行。堆排序可以并行执行，因为根结点的左右子树构成的子堆在执行过程中是互不影响的。

# 13. B

每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里{11, 12}和{4, 5}所处的位置并不是最终位置，因此不可能是冒泡和选择排序。二路归并算法经过第二趟后应该是每4个元素有序的，但{11, 12, 13, 7}并非有序，因此也不可能是二路归并排序。

# 14. A

题中给出的排序过程，每一趟都是从前往后依次比较使最大值沉底，符合冒泡排序的特点。分别用其他3种排序算法尝试，归并排序第一趟后的结果为(2,12,16,88,5,10)，基数排序第一趟后的结果为(10,2,12,5,16,88)，希尔排序显然不符合。

# 15. A

对于选项I，简单选择排序每次选择未排序序列中的最小元素放入其最终位置。对于选项II，希尔排序每次对划分的子表进行排序，得到局部有序的结果，所以不能保证每趟结束都能确定一个元素的最终位置。对于选项III，快速排序每趟结束后都将枢轴元素放到最终位置。对于选项IV，堆排序属于选择排序，每次都将大根堆的根结点与表尾结点交换，确定其最终位置。对于选项V，二路归并排序每趟对子表进行两两归并，从而得到若干局部有序的结果，但无法确定最终位置。

# 16. B

归并排序的代码比插入排序的代码更为复杂，前者的空间复杂度是  $O(n)$ ，后者是  $O(1)$ 。但是前者的时间复杂度是  $O(n\log_2n)$ ，后者是  $O(n^2)$ 。

# 17. D

在顺序存储的条件下，插入排序、选择排序、冒泡排序的时间复杂度都是  $O(n^{2})$  ，更换为链式存储后的时间复杂度还是  $O(n^{2})$  。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加。

# 18. D

当数据规模较小时可选择复杂度为  $O(n^{2})$  的简单排序算法，当数据规模较大时应选择复杂度为  $O(n\log_2n)$  的排序算法，当数据规模大到内存无法放下时需选择外部排序算法，选项I正确。数据的存储方式主要分为顺序存储和链式存储，有些排序算法（如堆排序）只能用于顺序存储方式，选项II正确。若对数据稳定性有要求，则不能选择不稳定的排序算法，选项III显然正确。当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是 $O(n)$ ，而归并排序的时间复杂度依旧是  $O(n\log_2n)$ ，选项IV正确。

# 19. A

考虑比较极端的情况，对于有序数组，直接插入排序的比较次数为  $n - 1$ ，简单选择排序的比

较次数始终为  $1 + 2 + \dots + n - 1 = n(n - 1) / 2$  ，选项I正确。两种排序算法的辅助空间都是  $O(1)$  ，无差别，选项II错误。初始有序时，移动次数均为0；对于通常情况，直接插入排序每趟插入都需要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，选项III错误。

# 20. D

直接插入排序和快速排序的特点如下表所示。

<table><tr><td></td><td>适合初始序列情况</td><td>适合元素数量</td><td>空间复杂度</td><td>稳定性</td></tr><tr><td>直接插入排序</td><td>大部分元素有序</td><td>较少</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>基本无序</td><td>较多</td><td>O(log2n)</td><td>不稳定</td></tr></table>

可见，选项I、II、III、IV都是采用直接插入排序而不采用快速排序的可能原因。

# 21. C

稳定的内部排序算法：插入排序、冒泡排序、归并排序和基数排序。不稳定的内部排序算法：简单选择排序、快速排序、希尔排序和堆排序。

# 二、综合应用题

# 01.【解答】

直接插入排序的交换次数更多，因此应当采用简单选择排序。

初始序列：3,7,6,9,7,1,4,5,20

第一次：1,7,6,9,7,3,4,5,20 交换1,3

第二次：1,3,6,9,7,7,4,5,20 交换3,7

第三次：1,3,4,9,7,7,6,5,20 交换4,6

第四次：1,3,4,5,7,7,6,9,20 交换5,9

第五次：1,3,4,5,6,7,7,9,20 交换6,7

所以最小交换次数为5（注意这里求的是交换次数，而不是移动次数或比较次数）。

# 02.【解答】

1）算法的基本设计思想如下：将数组A[1...m+n]视为一个已经过  $m$  趟插入排序的表，则从  $m + 1$  趟开始，将后  $n$  个元素依次插入前面的有序表中。

2）算法的实现如下：

```txt
void Insert_Sort(ElemType A[],int m,int n){ int i,j; for  $(\mathrm{i} = \mathrm{m} + 1;\mathrm{i} <   = \mathrm{m} + \mathrm{n};\mathrm{i} + + )$  { //依次将A[m+1..m+n]插入有序表  $A[0] = A[i]$  ： //复制为哨兵 for(j=i-1;A[j]>A[0];j--） //从后往前插入  $A[j + 1] = A[j]$  ： //元素后移  $A[j + 1] = A[0]$  ： //插入 }
```

3）时间复杂度由  $m$  和  $n$  共同决定，从上面的算法不难看出，在最坏情况下元素的比较次数为  $O(mn)$ ，而元素移动的次数为  $O(mn)$ ，所以时间复杂度为  $O(mn)$ 。

因为算法只用到了常数个辅助空间，所以空间复杂度为  $O(1)$ 。

此外，本题也可采用归并排序，将A[1...m]和A[m+1...m+n]视为两个待归并的有序子序列，算法的时间复杂度为  $O(m + n)$ ，空间复杂度为  $O(m + n)$ 。

# 03.【解答】

基本思想：以  $K_{n}$  为枢轴进行一趟快速排序。将快速排序算法改为以最后一个元素为枢轴，

先从前往后，再从后往前。算法的代码如下：

```txt
int Partition(ElemType K[],int n){  
//交换序列K[1..n]中的记录，使枢轴到位，并返回其所在位置  
int i=1,j=n; //设置两个交替变量初值分别为1和n  
ElemType pivot  $\equiv$  K[j]; //枢轴  
while(i<j){ //循环跳出条件  
while(i<j&&K[i]<  $=$  pivot)  
i++; //从前往后找比枢轴大的元素  
if(i<j)  
K[j]=K[i]; //移动到右端  
while(i<j&&K[j]>  $=$  pivot)  
j--; //从后往前找比枢轴小的元素  
if(i<j)  
K[i]=K[j]; //移动到左端  
} //while  
K[i]=pivot; //枢轴存放在最终位置  
return i; //返回存放枢轴的位置  
}
```

# 8.7 外部排序

外部排序可能会考查相关概念、方法和排序过程，外部排序的算法比较复杂，不会在算法设计上进行考查。本节的主要内容有：

① 外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。

② 为减少平衡归并中外存读/写次数所采取的方法：增大归并路数和减少归并段个数。

③ 利用败者树增大归并路数。

④ 利用置换-选择排序增大归并段长度来减少归并段个数。

⑤ 由长度不等的归并段进行多路平衡归并，需要构造最佳归并树。

# 8.7.1 外部排序的基本概念

前面介绍过的排序算法都是在内存中进行的（称为内部排序）。而在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序算法就称为外部排序。

# 8.7.2 外部排序的方法

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。

# 命题追踪 对大文件排序时使用的排序算法（2016）

外部排序通常采用归并排序算法。它包括两个阶段：①根据内存缓冲区大小，将外存上的文件分成若干长度为  $\ell$  的子文件，依次读入内存并利用内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串；②对这些归并段进行逐趟

归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。

例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排序得到8个初始归并段R1～R8，每段都含250条记录。然后对该文件做如图8.15所示的两两归并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1'）中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1'和R2'、R3'和R4'两两归并，这又是一趟归并。最后把R1"和R2"两个归并段归并，得到最终的有序文件，一共进行了3趟归并。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/fcdb77af80a99323279d8ee7cce278604af777f56ce4293db48608ec8354655a.jpg)



图8.14 二路归并


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/5570daa3c7597d7c9730ae7d6e07ce31b4c2f17acb5f4bc1d7487dbb584de591.jpg)



图8.15 二路归并的排序过程


在外部排序中实现两两归并时，不可能将两个有序段及归并结果段同时存放在内存中，因此需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：

外部排序的总时间 = 内部排序的时间 + 外存信息读/写的时间 + 内部归并的时间

显然，外存信息读/写的时间远大于内部排序和内部归并的时间，因此应着力减少I/O次数。外存信息的读/写是以“磁盘块”为单位的，因此可知每趟归并需进行16次读和16次写，3趟归并加上内部排序时所需进行的读/写，使得总共需进行  $32 \times 3 + 32 = 128$  次读/写。

若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至  $32 \times 2 + 32 = 96$ 。因此，增大归并路数，可减少归并趟数，进而减少总的磁盘I/O次数，如图8.16所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a268e0b64fdecbf57ea8171a4ed71cd3a0fbdba6005368073c891a3e097f4626.jpg)



图8.16 4路归并的排序过程


一般地，对  $r$  个初始归并段，做  $k$  路归并（每趟将  $k$  个或  $k$  个以下的有序子文件归并成一个有序子文件）。第一趟可将  $r$  个初始归并段归并为  $\lceil r / k\rceil$  个归并段，以后每趟归并将  $m$  个归并段归并成  $\lceil m / k\rceil$  个归并段，直至最后形成一个大的归并段为止。树的高度  $-1 = \lceil \log_k r \rceil =$  归并趟数  $S$  。可见，只要增大归并路数  $k$  ，或减少初始归并段个数  $r$  ，都能减少归并趟数  $S$  ，进而减少读/写磁盘的次数，达到提高外部排序速度的目的。

# 8.7.3 多路平衡归并与败者树

增加归并路数  $k$  能减少归并趟数  $S$  ，进而减少I/O次数。然而，增加归并路数  $k$  时，内部归并的时间将增加。做内部归并时，在  $k$  个元素中选择关键字最小的元素需要  $k - 1$  次比较。

每趟归并  $n$  个元素需要做  $(n - 1)(k - 1)$  次比较， $S$  趟归并总共需要的比较次数为

$$
S (n - 1) (k - 1) = \left\lceil \log_ {k} r \right\rceil (n - 1) (k - 1) = \left\lceil \log_ {2} r \right\rceil (n - 1) (k - 1) / \left\lceil \log_ {2} k \right\rceil
$$

式中， $(k - 1)\sqrt{\log_2k}$  随  $k$  增长而增长，因此内部归并时间亦随  $k$  的增长而增长。这将抵消因增大  $k$  而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。

为了使内部归并不受  $k$  的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。 $k$  个叶结点分别存放  $k$  个归并段在归并过程中当前参加比较的元素，内部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。

# 命题追踪 败者树的实现原理（2024）

如图8.17(a)所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，b2是败者，将段号2写入ls[3]。b3与b4的胜者b3与b0比较，b0是败者，将段号0写入ls[2]。最后两个胜者b3与b1比较，b1是败者，将段号1写入ls[1]。而将胜者b3的段号3写入ls[0]。此时，根结点ls[0]所指的段的关键字最小。对于  $k$  路归并，初始构造败者树需要  $k - 1$  次比较。b3中的6输出后，将下一关键字填入b3，继续比较。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/6fc256f26d3cb41d5a63155e3e00290f2bd68e68af7d49360938dd65a54bee5a.jpg)



(a)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/dfb4b774259bf2be43028801a1119c6e48731890bc6654ab282fa8e2c173bb9a.jpg)



(b)



图8.17 实现5路归并的败者树


因为  $k$  路归并的败者树深度为  $\lceil \log_2k\rceil +1$  ，所以从  $k$  个记录中选择最小关键字，仅需进行  $\lceil \log_2k\rceil$  次比较。因此总的比较次数约为

$$
S (n - 1) \lceil \log_ {2} k \rceil = \lceil \log_ {k} r \rceil (n - 1) \lceil \log_ {2} k \rceil = (n - 1) \lceil \log_ {2} r \rceil
$$

可见，使用败者树后，内部归并的比较次数与  $k$  无关了。因此，只要内存空间允许，增大归并路数  $k$  将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。

值得说明的是，归并路数  $k$  并不是越大越好。归并路数  $k$  增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当  $k$  值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。

# 8.7.4 置换-选择排序（生成初始归并段）

从8.7.2节的讨论可知，减少初始归并段个数  $r$  也可以减少归并趟数  $S$  。若总的记录个数为  $n$  每个归并段的长度为  $\ell$  ，则归并段的个数  $r = \lceil n / \ell \rceil$  。采用内部排序算法得到的各个初始归并段长

度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。

# 命题追踪 置换-选择排序生成初始归并段的实例（2023）

设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳  $w$  个记录。置换-选择算法的步骤如下：

1）从FI输入  $w$  个记录到工作区WA。

2）从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。

3）将MINIMAX记录输出到FO中去。

4）若FI不空，则从FI输入下一个记录到WA中。

5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。

6）重复  $3) \sim 5)$ ，直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。

7）重复2） $\sim 6$ ），直至WA为空。由此得到全部初始归并段。

设待排文件  $\mathrm{FI} = \{17,21,05,44,10,12,56,32,29\}$  ，WA容量为3，排序过程如表8.2所示。


表 8.2 置换-选择排序过程示例


<table><tr><td>输出文件 FO</td><td>工作区 WA</td><td>输入文件 FI</td></tr><tr><td>-</td><td>-</td><td>17,21,05,44,10,12,56,32,29</td></tr><tr><td>-</td><td>17 21 05</td><td>44,10,12,56,32,29</td></tr><tr><td>05</td><td>17 21 44</td><td>10,12,56,32,29</td></tr><tr><td>05 17</td><td>10 21 44</td><td>12,56,32,29</td></tr><tr><td>05 17 21</td><td>10 12 44</td><td>56,32,29</td></tr><tr><td>05 17 21 44</td><td>10 12 56</td><td>32,29</td></tr><tr><td>05 17 21 44 56</td><td>10 12 32</td><td>29</td></tr><tr><td>05 17 21 44 56 #</td><td>10 12 32</td><td>29</td></tr><tr><td>10</td><td>29 12 32</td><td>-</td></tr><tr><td>10 12</td><td>29 32</td><td>-</td></tr><tr><td>10 12 29</td><td>32</td><td>-</td></tr><tr><td>10 12 29 32</td><td>-</td><td>-</td></tr><tr><td>10 12 29 32 #</td><td>-</td><td>-</td></tr></table>

上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。

# 8.7.5 最佳归并树

文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等的初始归并段的归并顺序，使得I/O次数最少。假设由置换-选择排序得到9个初始归并段，其长度（记录数）依次为9,30,12,18,3,17,2,6,24。现做3路平衡归并，其归并树如图8.18所示。

在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数  $= 2\times \mathrm{WPL} = 484$

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d45e93e0cec1402d028caa01dfbd3167260a0aaf4b5d6f13df23c7ff885e6a55.jpg)



图8.18 3路平衡归并的归并树


# 命题追踪 构造三叉哈夫曼树及相关的分析和计算（2013）

显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O 次数）亦不同。为了优化归并树的 WPL，可以将哈夫曼树的思想推广到  $m$  叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的 I/O 次数最少的最佳归并树。上述 9 个初始归并段可构造成一棵如图 8.19 所示的归并树，按此树进行归并，仅需对外存进行 446 次读/写，这棵归并树称为最佳归并树。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/d8b2604cb7bda66d8cc42995a1389f94d65effbd6bf2ee07e52d67f2a8729cec.jpg)



图8.19 3路平衡归并的最佳归并树


图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的I/O次数为386。显然，这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格  $k$  叉树（也称正则  $k$  叉树）时，则需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。因此，最佳归并树应如图8.20所示，此时的I/O次数仅为326。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/69d86d00d7518f833af447e2e4352147b51c29d98f4dbba84e9b43a97c6fdccc.jpg)



图8.20 8个归并段的最佳归并树


如何判定添加虚段的数目？

设度为0的结点有  $n_0$  个，度为  $k$  的结点有  $n_k$  个，归并树的结点总数为  $n$  ，则有：

$n = n_{k} + n_{0}$  （总结点数  $=$  度为  $k$  的结点数  $+$  度为0的结点数）

$n = k n_{k} + 1$  （总结点数  $=$  所有结点的度数之和  $+1$ ）

因此，对严格  $k$  叉树有  $n_0 = (k - 1)n_k + 1$  ，由此可得  $n_k = (n_0 - 1) / (k - 1)$  。

- 若  $(n_0 - 1)\% (k - 1) = 0$  （%为取模运算），则说明这  $n_0$  个叶结点（初始归并段）正好可以构造  $k$  叉归并树。此时，内结点有  $n_k$  个。

- 若  $(n_0 - 1)\% (k - 1) = u \neq 0$  ，则说明对于这  $n_0$  个叶结点，其中有  $u$  个多余，不能包含在  $k$  叉归并树中。为构造包含所有  $n_0$  个初始归并段的  $k$  叉归并树，应在原有  $n_k$  个内结点的

基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加上刚才多出的  $u$  个叶结点，即再加上  $k - u - 1$  个空归并段，就可以建立归并树。

# 命题追踪

# 实现最佳归并时需补充的虚段数量的分析（2019）

以图8.20为例，用8个归并段构成3叉树， $(n_0 - 1)\% (k - 1) = (8 - 1)\% (3 - 1) = 1$ ，说明7个归并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子）。为此，将叶子5变成一个内结点，再添加  $3 - 1 - 1 = 1$  个空归并段，就可以构成一棵严格3叉树。

# 8.7.6 本节试题精选

# 一、单项选择题

01. 外部排序和内部排序的主要区别是（）。

A. 内部排序的数据量小, 而外部排序的数据量大

B. 内部排序不涉及内、外存数据交换，而外部排序涉及内、外存数据交换

C. 内部排序的速度快，而外部排序的速度慢

D. 内部排序所需的内存小, 而外部排序所需的内存大

02. 下列关于外部排序的说法中，正确的是（）。

A. 置换选择排序得到的初始归并段的长度一定相等

B. 内外存交换数据的时间只占总排序时间的一小部分

C. 败者树是一棵完全二叉树

D. 外部排序不涉及对文件的读/写操作

03. 多路平衡归并的作用是（）。

A. 减少归并趟数

B. 减少初始归并段的个数

C. 便于实现败者树

D. 以上都对

04. 设在磁盘上存放有 375000 个记录，做 5 路平衡归并排序，内存工作区能容纳 600 个记录，为把所有记录排好序，需要做（）趟归并排序。

A. 3

B. 4

C. 5

D. 6

05. 在下列关于外部排序过程输入/输出缓冲区作用的叙述中，不正确的是（）。

A. 暂存输入/输出记录

B. 内部归并的工作区

C. 产生初始归并段的工作区

D. 传送用户界面的消息

06. 在做  $m$  路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置（①）个输入缓冲区和（②）个输出缓冲区。

$①$  A.2

B.  $m$

C.  ${2m} - 1$

D.  $2 m$

$②$  A.2

B.  $m$

C.  ${2m} - 1$

D.  $2 m$

07. 若只需3趟排序就可完成64个元素的多路归并排序，则选取的归并路数最少是（）。

A. 2

B. 3

C. 4

D. 5

08. 置换-选择排序的作用是（）。

A. 用于生成外部排序的初始归并段

B. 完成将一个磁盘文件排序成有序文件的有效的外部排序算法

C. 生成的初始归并段的长度是内存工作区的2倍

D. 对外部排序中输入/归并/输出的并行处理

09. 一个无序文件的  $n$  个记录采用置换选择排序产生  $m$  个有序段，则  $m$  和  $n$  的关系是（）。

A.  $m$  与  $n$  成正比

B.  $m = \log_2 n$

C.  $m$  与  $n$  成反比

D. 以上都不对

10. 在由  $k$  路归并构建的败者树中选取一个关键字最小的记录，则所需时间为（）。

A.  $O(1)$

B.  $O(k)$

C.  $O\left(\log_2 k\right)$

D. 以上都不对

11. 下列关于小顶堆和败者树的说法中，正确的是（）。

I. 败者树从下往上维护，每上一层，只需和失败结点比较 1 次

II. 败者树的每次维护，必定要从叶结点一直走到根结点，不可能从中间停止

III. 堆从上往下维护，每下一层，若其左右孩子均不为空，则需比较2次

IV. 堆的每次维护，必定要从根结点一直走到叶结点，不可能从中间停止

A. I、III

B. II、III

C. I、II、III

D. I、III、IV

12. 最佳归并树在外部排序中的作用是（）

A. 完成  $m$  路归并排序

B. 设计  $m$  路归并排序的优化方案

C. 产生初始归并段

D. 与锦标赛树的作用类似

13. 在由  $m$  个初始归并段构建的  $k$  阶最佳归并树中，不需要补充虚段，则度为  $k$  的结点个数是（）。

A.  $(m - 1) / k$

B.  $m / k$

C.  $(m - 1) / (k - 1)$

D. 无法确定

14.【2013统考真题】已知三叉树  $T$  中6个叶结点的权分别是2,3,4,5,6,7，  $T$  的带权（外部）路径长度最小是（）。

A. 27

B. 46

C. 54

D. 56

15.【2016统考真题】对10TB的数据文件进行排序，应使用的方法是（）。

A. 希尔排序

B. 堆排序

C. 快速排序

D. 归并排序

16.【2019统考真题】设外存上有120个初始归并段，进行12路归并时，为实现最佳归并，需要补充的虚段个数是（）。

A. 1

B. 2

C. 3

D. 4

17.【2024统考真题】在外排序中，利用败者树对初始为升序的归并段进行多路归并，败者树中记录“冠军”的结点保存的是（）。

A. 最大关键字

B. 最小关键字

C. 最大关键字所在的归并段号

D. 最小关键字所在的归并段号

# 二、综合应用题

01. 若某个文件经内部排序得到 80 个初始归并段，试问：

1）若使用多路平衡归并执行3趟完成排序，则应取得的归并路数至少应为多少？

2) 若操作系统要求一个程序同时可用的输入/输出文件的总数不超过 15 个，则按多路归并至少需要几趟可以完成排序？若限定这个趟数，可取的最低路数是多少？

02. 假设文件有 4500 个记录，在磁盘上每个块可放 75 个记录。计算机中用于排序的内存区可容纳 450 个记录。试问：

1）可以建立多少个初始归并段？每个初始归并段有多少记录？存放于多少个块中？

2）应采用几路归并？请写出归并过程及每趟需要读/写磁盘的块数。

03. 设初始归并段为(10, 15, 31), (9, 20), (22, 34, 37), (6, 15, 42), (12, 37), (84, 95)。试利用败者树进行  $m$  路归并，手工执行选择最小的 5 个关键字的过程。

04. 给出 12 个初始归并段，其长度分别为 30, 44, 8, 6, 3, 20, 60, 18, 9, 62, 68, 85。现要做 4 路外归并排序，试画出表示归并过程的最佳归并树，并计算该归并树的带权路径长度 WPL。

05.【2023统考真题】对含有  $n(n > 0)$  个记录的文件进行外部排序，采用置换-选择排序生成初始归并段时需要使用一个工作区，工作区中能保存  $m$  个记录。请回答：

1)若文件中含有19个记录，其关键字依次是51,94,37,92,14,63,15,99,48,56,23,60,31,17,43,8,90,166,100，则当  $m = 4$  时，可生成几个初始归并段？各是什么？

2）对任意的  $m$  （ $n \gg m > 0$ ），生成的第一个初始归并段的长度最大值和最小值分别是多少？

# 8.7.7 答案与解析

# 一、单项选择题

01. B

外部排序和内部排序最主要的区别是是否涉及内存、外存的数据交换。

02.C

置换选择排序得到的是长度不一定相等的归并段，选项A错误。外部排序的主要时间消耗在内外存之间的数据交换上，选项B错误。败者树是一棵完全二叉树，选项C正确。外部排序包括两个阶段：生成初始归并段和对初始归并段进行归并，这两个阶段都涉及对文件的读/写操作，选项D错误。

03. A

多路平衡归并的目的是减少归并趟数，因为当  $m$  个初始归并段采用  $k$  路平衡归并时，所需趟数  $s = \lceil \log_k m \rceil$  ，若不采用多路平衡归并，则其归并趟数大于  $s$  。

04. B

初始归并段的个数  $r = 375000 / 600 = 625$ ，因此，归并趟数  $S = \lceil \log_m r \rceil = \lceil \log_5 625 \rceil = 4$ 。第一趟把625个归并段归并成  $625 / 5 = 125$  个；第二趟把125个归并段归并成  $125 / 5 = 25$  个；第三趟把25个归并段归并成  $25 / 5 = 5$  个；第四趟把5个归并段归并成  $5 / 5 = 1$  个。

05. D

在外部排序过程中输入/输出缓冲区就是排序的内存工作区，例如做  $m$  路平衡归并需要  $m$  个输入缓冲区和1个输出缓冲区，用以存放参加归并的和归并完成的记录。在产生初始归并段时也可用作内部排序的工作区。它没有传送用户界面的消息的任务。

06. D、A

相比普通的  $m$  路归并：需增加一个输出缓冲区，当一个输出缓冲区满时，输出一个缓冲区的同时归并程序可向另一个输出缓冲区填充数据，这就实现了内部归并和输出的并行。需增加  $m$  个输入缓冲区，当  $m$  个输入缓冲区正在运行时，外部可向新增的  $m$  个缓冲区写入数据，这就实现了输入和内部归并的并行。综上，需设置2个输出缓冲区， $2m$  个输入缓冲区。

07. C

归并趟数  $= \lceil \log_k n \rceil$ ，其中  $k$  表示归并的路数， $n$  表示元素个数，当  $k = 4$ 、 $n = 64$  时，归并趟数恰好等于3，因此选取的归并路数至少是4。

08. A

置换-选择排序是外部排序中生成初始归并段的方法，用此方法得到的初始归并段的长度是不等长的，其长度平均是传统等长初始归并段的2倍，从而使得初始归并段数减少到原来的近二分之一。但是，置换-选择排序不是一种完整的生成有序文件的外部排序算法。

09. D

设内存工作区  $w = 1$ ，则文件{1,2,3,4,5}产生1个有序段，而文件{5,4,3,2,1}产生5个有序段，因此  $m$  与待排文件、内存工作区大小  $w$  和  $n$  都有关，但不是选项A、B、C描述的直接关系。

10. C

在败者树中选取最小关键字的时间复杂度取决于败者树的高度，所需时间为  $O(\log_2k)$

# 11. C

选项I正确，是败者树的性质。在败者树的维护过程中，会让胜利者一直调整到根结点，选项II正确。以小根堆为例，每次调整时，先比较下一层的两个元素（1次），找出较小值，然后比较当前元素和下一层的较小元素（1次），以决定是否向下交换位置，选项III正确。堆在维护时，可能会在中间某层停止（若此处无须调整），而不一定要走到叶结点，选项IV错误。

# 12. B

最佳归并树在外部排序中的作用是设计  $m$  路归并排序的优化方案，仿照构造哈夫曼树的方法，以初始归并段的长度为权值，构造具有最小带权路径长度的  $m$  叉哈夫曼树，可以有效地减少归并过程中的读/写记录数，加快外部排序的速度。

# 13. C

$k$  阶最佳归并树中只有度为0和  $k$  的结点。设结点总数为  $n$  ，度为0的结点数为  $n_0$  ，度为  $k$  的结点数为  $n_k$  ，则  $n_0 = m, n - 1 = k \times n_k, n = n_0 + n_k$  ，因此  $k \times n_k = m + n_k - 1$  ，求得  $n_k = (m - 1) / (k - 1)$  。

# 14. B

题中的三叉树为使WPL最小，必须构造三叉哈夫曼树，应满足  $(n_0 - 1)\% (3 - 1) = 0$  的条件，因此需添加1个权值为0的虚叶结点，说明7个叶结点刚好可构成一棵严格的三叉树。按照哈夫曼树的原则，权为0的叶结点应离树根最远，构造三叉哈夫曼树的过程如下：

① 合并权值最小的三个结点0,2,3，得到新结点的权值  $= 5$  ，剩下5,4,5,6,7。

② 合并权值最小的三个结点4,5,5，得到新结点的权值  $= 14$  ，剩下14,6,7。

③ 合并权值最小的三个结点6,7,14，得到新结点的权值  $= 27$  ，仅有27，建树完成。

$$
\mathrm {W P L} = \sum_ {1} ^ {n} \text {权 值} W _ {\text {叶 结 点} i} \times \text {深 度} D _ {\text {叶 结 点} i} = (2 + 3) \times 3 + (4 + 5) \times 2 + (6 + 7) \times 1 = 4 6
$$

或

$$
\mathrm {W P L} = \sum_ {1} ^ {m} \text {权 值} W _ {\text {分 支 结 点} j} = 2 7 + 1 4 + 5 = 4 6
$$

每个分支结点的权值都累加了其下面所有分支结点的权值，因此采用第二种方法更方便。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/7be86b7020f4ac69dbb1129bfe7441865f3a4ed253cd7d1775be20d1ac9a9145.jpg)


# 15. D

外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。外部排序通常采用归并排序算法。选项A、B、C都是内部排序的方法。

# 16. B

在12路归并树中只存在度为0和度为12的结点，设度为0的结点数、度为12的结点数和要补充的结点数分别为  $n_0$  、  $n_{12}$  和  $n_{\text{补}}$ ，则有  $n_0 = 120 + n_{\text{补}}$ ，  $n_0 = (12 - 1)n_{12} + 1$ ，可得  $n_{12} = (120 - 1 + n_{\text{补}}) / (12 - 1)$ 。因为结点数  $n_{12}$  为整数，所以  $n_{\text{补}}$  是使上式整除的最小整数，求得  $n_{\text{补}} = 2$ 。

此外，题中为实现最佳归并，应满足12叉哈夫曼树，  $n = 120$  ，  $m = 12$  ，不满足  $(n - 1)\% (m - 1) = 0$  的条件，因此需要添加两个权值为0的叶结点，使得  $n = 122$  ，才能满足条件。

# 17. D

利用败者树归并升序归并段，每次需要得到当前的最小关键字，因此记录“冠军”的结点保存的只能是最小关键字或最小关键字所在的归并段号。通过败者树找出最小关键字后，还需要找

到该关键字所在的归并段，并移动段内元素，以继续比较下一个元素，下面分别进行讨论：①假设记录“冠军”的结点保存的是最小关键字所在的归并段号，则能直接得到最小关键字及其所在的段，时间复杂度低。②假设记录“冠军”的结点保存的是最小关键字，则查找其所在的段需要检索所有段的首元素是否与该最小关键字相等，时间复杂度高。为了提高效率，记录“冠军”的结点保存的是最小关键字所在的归并段号，而不是最小关键字。

# 二、综合应用题

01.【解答】

1）设归并路数为  $m$  ，初始归并段个数  $r = 80$  ，根据归并趟数计算公式  $S = \lceil \log_m r \rceil = \lceil \log_m 80 \rceil = 3$  ，得  $\log_m 80 \leqslant 3$  ， $m^3 \geqslant 80$  。由此解得  $m \geqslant 5$  ，即应取的归并路数至少为5。

2）设多路归并的归并路数为  $m$  ，需要  $m$  个输入缓冲区和1个输出缓冲区。一个缓冲区对应一个文件，有  $m + 1 = 15$  ，因此  $m = 14$  ，可做14路归并。由  $S = \lceil \log_m r \rceil = \lceil \log_{14}80 \rceil = 2$  即至少需要2趟归并可完成排序。若限定趟数为2，由  $S = \lceil \log_m 80 \rceil = 2$  ，有  $80 \leqslant m^2$  ，可取的最低路数为9。即要在2趟内完成排序，进行9路归并排序即可。

02.【解答】

1）文件有4500个记录，用于排序的内存区可容纳450个记录，可建立的初始归并段有 $4500 / 450 = 10$  个。每个初始归并段中有450个记录，存于  $450 / 75 = 6$  个块中。

2）内存区可容纳6个块，可建立6个缓冲区，其中5个缓冲区用于输入，1个缓冲区用于输出，因此可采用5路归并，归并过程如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/535f571424ab529288449224f9dfdadcfce5af3d70aca7c1539dcfc4ab9a7c81.jpg)


共做了2趟归并，每趟需要读60块、写60块。

03.【解答】

做6路归并排序，选择最小的5个关键字的败者树如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/0176c078941b0d2a54839af8db474515bb1cf823d6f253e9bce90261b91c8b6f.jpg)


# 04.【解答】

设初始归并段个数  $n = 12$ ，外归并路数  $k = 4$ ，计算  $(n - 1)\% (k - 1) = 11\% 3 = 2 \neq 0$ ，说明不能做完全的4路归并，因为多出了两个初始归并段，必须添加  $k - 2 - 1 = 1$  个长度为0的空归并段，才能构成严格的4路归并树，即每次归并都有  $k$  个归并段参加归并。

此时，归并树的内结点应有  $(n - 1 + 1) / (k - 1) = 12 / 3 = 4$  个，如下图所示。

![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/3820f8deaa7495a749fc0ca21a196404388279f37ae6a6dfe718c4a3437eeb94.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/96591d8fa0fc4bfaf71299742a1f01cafd789636edab16df6132ef84e62a6d0a.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/a3fc3279e338f85be58ac7760eb3061e6264f1b03d3c582292e0b86c3d492766.jpg)


![image](https://cdn-mineru.openxlab.org.cn/result/2026-01-01/fb4b23be-e3fd-4168-9382-71a14c116048/58a09aa4eae8fb7be07dcc3332434c3fe5c8bd3dfa4b66d4989c87fb86dbde27.jpg)


$$
\mathrm {W P L} = (3 + 6 + 8) \times 3 + (9 + 1 8 + 2 0 + 3 0 + 4 4 + 6 0 + 6 2) \times 2 + (6 8 + 8 5) \times 1 = 5 1 + 4 8 6 + 1 5 3 = 6 9 0 。
$$

# 05.【解答】

1）当文件中的  $n$  个记录升序排列时，只生成一个归并段，长度达到最大，为  $n$  。若初始工作区内的  $m$  个元素都大于输入文件中剩下的所有记录，则第一个归并段的长度就为  $m$  ，此时为第一个归并段长度最小的情况。排序过程如下表所示。

<table><tr><td>输出文件 FO</td><td>工作区 WA</td><td>输入文件 FI</td></tr><tr><td>—</td><td>—</td><td>51,94,37,92,14,63,15,99,48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>—</td><td>51,94,37,92</td><td>14,63,15,99,48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37</td><td>51,94,14,92</td><td>63,15,99,48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37,51</td><td>94,14,92,63</td><td>15,99,48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37,51,63</td><td>15,94,14,92</td><td>99,48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37,51,63,92,94</td><td>15,94,14,99</td><td>48,56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37,51,63,92,94,99#</td><td>15,14,99,48</td><td>56,23,60,31,17,43,8,90,166,100</td></tr><tr><td>37,51,63,92,94,99#</td><td>15,14,56,48</td><td>23,60,31,17,43,8,90,166,100</td></tr><tr><td>14</td><td>15,23,56,48</td><td>60,31,17,43,8,90,166,100</td></tr><tr><td>14,15</td><td>60,23,56,48</td><td>31,17,43,8,90,166,100</td></tr><tr><td>14,15,23</td><td>60,31,56,48</td><td>17,43,8,90,166,100</td></tr><tr><td>14,15,23,31</td><td>60,17,56,48</td><td>43,8,90,166,100</td></tr><tr><td>14,15,23,31,48</td><td>60,17,56,43</td><td>8,90,166,100</td></tr><tr><td>14,15,23,31,48,56</td><td>60,17,8,43</td><td>90,166,100</td></tr><tr><td>14,15,23,31,48,56,60</td><td>90,17,8,43</td><td>166,100</td></tr><tr><td>14,15,23,31,48,56,60,90</td><td>166,17,8,43</td><td>100</td></tr><tr><td>14,15,23,31,48,56,60,90,166</td><td>100,17,8,43</td><td>—</td></tr><tr><td>14,15,23,31,48,56,60,90,166#</td><td>100,17,8,43</td><td>—</td></tr><tr><td>8</td><td>100,17,43</td><td>—</td></tr><tr><td>8,17</td><td>100,43</td><td>—</td></tr><tr><td>8,17,43</td><td>100</td><td>—</td></tr><tr><td>8,17,43,100</td><td>—</td><td>—</td></tr><tr><td>8,17,43,100#</td><td>—</td><td>—</td></tr></table>

生成三个初始归并段，分别是37,51,63,92,94,99;14,15,23,31,48,56,60,90,166;8,17,43,100。2）最大值为  $n$  ，最小值为  $m$  。

# 归纳总结

下面对本章所介绍的排序算法进行一次系统的比较和复习。

1. 直接插入排序、冒泡排序和简单选择排序是基本的排序算法，它们主要用于元素个数  $n$  不是很大（ $n < 10000$ ）的情形。

它们的平均时间复杂度均为  $O(n^{2})$  ，实现也都非常简单。直接插入排序对于规模很小的元素序列（ $n \leqslant 25$ ）非常有效。它的时间复杂度与待排序元素序列的初始排列有关。在最好情况下，直接插入排序只需要  $n - 1$  次比较操作就可以完成，且不需要交换操作。在平均情况下和最差情况下，直接插入排序的比较和交换操作都是  $O(n^{2})$  。冒泡排序在最好情况下只需要一趟排序过程就可以完成，此时也只需要  $n - 1$  次比较操作，不需要交换操作。简单选择排序的关键字比较次数与待排序元素序列的初始排列无关，其比较次数总是  $O(n^{2})$  ，但元素移动次数则与待排序元素序列的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过  $3(n - 1)$  。

从空间复杂度来看，这三种基本的排序算法除一个辅助元素外，都不需要其他额外空间。从稳定性来看，直接插入排序和冒泡排序都是稳定的，但简单选择排序不是。

2. 对于中等规模的元素序列（ $n \leqslant 1000$ ），希尔排序是一种很好的选择。

在希尔排序中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移动次数较少，且移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记录数越多，但同时记录次序也越来越接近有序，因而记录的比较和移动次数也都比较少。从理论上和实验上都已证明，在希尔排序中，记录的总比较次数和总移动次数比直接插入排序时少得多，特别是当  $n$  越大时效果越明显。而且，希尔排序代码简单，基本上不需要什么额外内存，但希尔排序是一种不稳定的排序算法。公众号：小兔网盘免费分享无水印PDF

3. 对于元素个数  $n$  很大的情况，可以采用快速排序、堆排序、归并排序或基数排序，其中快速排序和堆排序都是不稳定的，而归并排序和基数排序是稳定的排序算法。

快速排序是最通用的高效内部排序算法，特别是它的划分思想经常在很多算法设计题中出现。平均情况下它的时间复杂度为  $O(n\log_2n)$ ，一般情况下所需要的额外空间也是  $O(\log_2n)$ 。但是快速排序在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到  $O(n^2)$ ，空间复杂度也会增加到  $O(n)$ 。但我们可以通过“三者取中”法来避免最坏情况的发生。

堆排序也是一种高效的内部排序算法，它的时间复杂度是  $O(n\log_2n)$ ，而且没有什么最坏情况会导致堆排序的运行明显变慢，并且堆排序基本上不需要额外的空间。但堆排序不大可能提供比快速排序更好的平均性能。

归并排序也是一个重要的高效排序算法，它的一个重要特性是性能与输入元素序列无关，时间复杂度总是  $O(n\log_2n)$  。归并排序的主要缺点是需要  $O(n)$  的额外存储空间。

基数排序是一种相对特殊的排序算法，这类算法不仅是对元素序列的关键字进行比较，更重要的是它们对关键字的不同位部分进行处理和比较。虽然基数排序具有线性增长的时间复杂度，但由于在常规编程环境中，基数排序的线性时间开销实际上并不比快速排序的时间开销小很多，并且由于基数排序基于的关键字抽取算法受到操作系统和排序元素的影响，其适应性远不如普通

的进行比较和交换操作的排序算法。因此，在实际工作中，常规的高效排序算法如快速排序的应用要比基数排序广泛得多。基数排序需要的额外存储空间包括和待排序元素序列规模相同的存储空间及与基数数目相等的一系列桶（一般用队列实现）。

# 4. 混合使用。

我们可以混合使用不同的排序算法，这也是得到普遍应用的一种算法改进方法，例如，可以将直接插入排序集成到归并排序的算法中。这种混合算法能够充分发挥不同算法各自的优势，从而在整体上得到更好的性能。

# 思维拓展

下面是一道看起来很吓人的题目：对  $n$  个整数进行排序，要求时间复杂度为  $O(n)$ ，空间复杂度为  $O(1)$ 。

# 提示

设待排序整数的范围为  $0 \sim 65535$ ，设定一个数组int count[65535]并初始化为0，则所需空间与  $n$  无关，为  $O(1)$ 。扫描一遍待排序列X[]，count[X[i]]++，时间复杂度为  $O(n)$ ；再扫描一次count[]，当count[i]  $>0$  时，输出count[i]个i，排序完毕所需的时间复杂度也为  $O(n)$ ；所以总时间复杂度为  $O(n)$ ，空间复杂度为  $O(1)$ 。另外，读者可能会问假如有负整数怎么办，这种情况下可以给所有整数都加上一个偏移量，使之都变成正整数，再使用上述方法。

# 参考文献



[1] 严蔚敏，吴伟民．数据结构（C语言版）[M]. 北京：清华大学出版社，2018.





[2]托马斯·科尔曼，查尔斯·雷瑟尔森，罗纳德·李维斯特，等．算法导论[M].北京：机械工业出版社，2013.





[3] 李春葆，陈良臣，尹为民，等．数据结构教程（C++语言描述）[M].北京：清华大学出版社，2009.





[4] 陈守孔，胡潇琨，李玲．算法与数据结构考研试题精析[M].北京：机械工业出版社，2007.





[5] 夏清国．数据结构考研教案[M]. 西安：西北工业大学出版社，2006.





[6] 全国考研计算机大纲配套教材专家委员会. 全国硕士研究生入学统一考试计算机专业基础综合考试大纲解析[M]. 北京：高等教育出版社，2023.





[7] 李春葆，尹为民，陈良臣．数据结构联考辅导教程[M].北京：清华大学出版社，2010.

